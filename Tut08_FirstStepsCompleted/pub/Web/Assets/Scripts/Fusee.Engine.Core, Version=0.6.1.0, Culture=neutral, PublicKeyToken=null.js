/* Generated by JSIL v0.8.2 build 31050. See http://jsil.org/ for more information. */ 
'use strict';
var $asm04 = JSIL.DeclareAssembly("Fusee.Engine.Core, Version=0.6.1.0, Culture=neutral, PublicKeyToken=null");

JSIL.DeclareNamespace("Fusee");
JSIL.DeclareNamespace("Fusee.Engine");
JSIL.DeclareNamespace("Fusee.Engine.Common");
/* class Fusee.Engine.Common.ResizeEventArgs */ 

(function ResizeEventArgs$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.EventArgs)) ();
  };


  function ResizeEventArgs__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.EventArgs"), 
      Name: "Fusee.Engine.Common.ResizeEventArgs", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ResizeEventArgs__ctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("Fusee.Engine.Core");
/* class Fusee.Engine.Core.Audio */ 

(function Audio$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm01.Fusee.Base.Core.Diagnostics)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.DummyAudioImp)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioImp.CloseDevice)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioImp.GetVolume)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioImp.LoadFile)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioImp.OpenDevice)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioImp.SetPanning)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioImp.SetVolume)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioImp.Stop)) ();
  };


  function Audio__ctor () {
  }; 

  function Audio_CloseDevice () {
    $IM00().Call(this._audioImp, null);
  }; 

  function Audio_Dispose () {
    $thisType._instance = null;
  }; 

  function Audio_get_Instance () {
    var arg_15_0 = null;
    if ((arg_15_0 = $thisType._instance) === null) {
      arg_15_0 = $thisType._instance = new $thisType();
    }
    return arg_15_0;
  }; 

  function Audio_GetVolume () {
    return $IM01().Call(this._audioImp, null);
  }; 

  function Audio_LoadFile (fileName, streaming) {
    return $IM02().Call(this._audioImp, null, fileName, streaming);
  }; 

  function Audio_set_AudioImp (value) {
    if (value === null) {
      $T03().Log("WARNING: No Audio implementation set. To enable Audio functionality inject an appropriate implementation of IAudioImp in your platform specific application main module.");
      this._audioImp = new ($T04())();
    } else {
      this._audioImp = value;
      $IM03().Call(this._audioImp, null);
    }
  }; 

  function Audio_SetPanning (val) {
    $IM04().Call(this._audioImp, null, val);
  }; 

  function Audio_SetVolume (val) {
    $IM05().Call(this._audioImp, null, val);
  }; 

  function Audio_Stop () {
    $IM06().Call(this._audioImp, null);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Audio", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Audio__ctor
    );

    $.Method({Static:false, Public:false}, "CloseDevice", 
      JSIL.MethodSignature.Void, 
      Audio_CloseDevice
    );

    $.Method({Static:false, Public:false}, "Dispose", 
      JSIL.MethodSignature.Void, 
      Audio_Dispose
    );

    $.Method({Static:true , Public:true }, "get_Instance", 
      JSIL.MethodSignature.Return($.Type), 
      Audio_get_Instance
    );

    $.Method({Static:false, Public:true }, "GetVolume", 
      JSIL.MethodSignature.Return($.Single), 
      Audio_GetVolume
    );

    $.Method({Static:false, Public:true }, "LoadFile", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.IAudioStreamImp"), [$.String, $.Boolean]), 
      Audio_LoadFile
    );

    $.Method({Static:false, Public:false}, "set_AudioImp", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IAudioImp")), 
      Audio_set_AudioImp
    );

    $.Method({Static:false, Public:true }, "SetPanning", 
      JSIL.MethodSignature.Action($.Single), 
      Audio_SetPanning
    );

    $.Method({Static:false, Public:true }, "SetVolume", 
      JSIL.MethodSignature.Action($.Single), 
      Audio_SetVolume
    );

    $.Method({Static:false, Public:true }, "Stop", 
      JSIL.MethodSignature.Void, 
      Audio_Stop
    );

    $.Field({Static:true , Public:false}, "_instance", $.Type);

    $.Field({Static:false, Public:false}, "_audioImp", $asm03.TypeRef("Fusee.Engine.Common.IAudioImp"));

    $.Property({Static:false, Public:false}, "AudioImp", $asm03.TypeRef("Fusee.Engine.Common.IAudioImp"));

    $.Property({Static:true , Public:true }, "Instance", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.DummyAudioImp */ 

(function DummyAudioImp$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.DummyAudioStreamImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Single)) ();
  };


  function DummyAudioImp__ctor () {
  }; 

  function DummyAudioImp_CloseDevice () {
  }; 

  function DummyAudioImp_GetVolume () {
    return 0;
  }; 

  function DummyAudioImp_LoadFile (fileName, streaming) {
    return new ($T02())();
  }; 

  function DummyAudioImp_OpenDevice () {
  }; 

  function DummyAudioImp_SetPanning (val) {
  }; 

  function DummyAudioImp_SetVolume (volume) {
  }; 

  function DummyAudioImp_Stop () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.DummyAudioImp", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      DummyAudioImp__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "CloseDevice", 
      JSIL.MethodSignature.Void, 
      DummyAudioImp_CloseDevice
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetVolume", 
      JSIL.MethodSignature.Return($.Single), 
      DummyAudioImp_GetVolume
    );

    $.Method({Static:false, Public:true , Virtual:true }, "LoadFile", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.IAudioStreamImp"), [$.String, $.Boolean]), 
      DummyAudioImp_LoadFile
    );

    $.Method({Static:false, Public:true , Virtual:true }, "OpenDevice", 
      JSIL.MethodSignature.Void, 
      DummyAudioImp_OpenDevice
    );

    $.Method({Static:false, Public:true , Virtual:true }, "SetPanning", 
      JSIL.MethodSignature.Action($.Single), 
      DummyAudioImp_SetPanning
    );

    $.Method({Static:false, Public:true , Virtual:true }, "SetVolume", 
      JSIL.MethodSignature.Action($.Single), 
      DummyAudioImp_SetVolume
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Stop", 
      JSIL.MethodSignature.Void, 
      DummyAudioImp_Stop
    );

    $.ImplementInterfaces(
      /* 0 */ $asm03.TypeRef("Fusee.Engine.Common.IAudioImp")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.DummyAudioStreamImp */ 

(function DummyAudioStreamImp$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Single)) ();
  };


  function DummyAudioStreamImp__ctor () {
  }; 

  function DummyAudioStreamImp_get_Loop () {
    return this.DummyAudioStreamImp$Loop$value;
  }; 

  function DummyAudioStreamImp_get_Panning () {
    return this.DummyAudioStreamImp$Panning$value;
  }; 

  function DummyAudioStreamImp_get_Volume () {
    return this.DummyAudioStreamImp$Volume$value;
  }; 

  function DummyAudioStreamImp_Pause () {
  }; 

  function DummyAudioStreamImp_Play$00 () {
  }; 

  function DummyAudioStreamImp_Play$01 (loop) {
  }; 

  function DummyAudioStreamImp_set_Loop (value) {
    this.DummyAudioStreamImp$Loop$value = value;
  }; 

  function DummyAudioStreamImp_set_Panning (value) {
    this.DummyAudioStreamImp$Panning$value = +value;
  }; 

  function DummyAudioStreamImp_set_Volume (value) {
    this.DummyAudioStreamImp$Volume$value = +value;
  }; 

  function DummyAudioStreamImp_Stop () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.DummyAudioStreamImp", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      DummyAudioStreamImp__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Loop", 
      JSIL.MethodSignature.Return($.Boolean), 
      DummyAudioStreamImp_get_Loop
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Panning", 
      JSIL.MethodSignature.Return($.Single), 
      DummyAudioStreamImp_get_Panning
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Volume", 
      JSIL.MethodSignature.Return($.Single), 
      DummyAudioStreamImp_get_Volume
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Pause", 
      JSIL.MethodSignature.Void, 
      DummyAudioStreamImp_Pause
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Play", 
      JSIL.MethodSignature.Void, 
      DummyAudioStreamImp_Play$00
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Play", 
      JSIL.MethodSignature.Action($.Boolean), 
      DummyAudioStreamImp_Play$01
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Loop", 
      JSIL.MethodSignature.Action($.Boolean), 
      DummyAudioStreamImp_set_Loop
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Panning", 
      JSIL.MethodSignature.Action($.Single), 
      DummyAudioStreamImp_set_Panning
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Volume", 
      JSIL.MethodSignature.Action($.Single), 
      DummyAudioStreamImp_set_Volume
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Stop", 
      JSIL.MethodSignature.Void, 
      DummyAudioStreamImp_Stop
    );

    $.Field({Static:false, Public:false}, "DummyAudioStreamImp$Volume$value", $.Single);

    $.Field({Static:false, Public:false}, "DummyAudioStreamImp$Loop$value", $.Boolean);

    $.Field({Static:false, Public:false}, "DummyAudioStreamImp$Panning$value", $.Single);

    $.Property({Static:false, Public:true , Virtual:true }, "Volume", $.Single);

    $.Property({Static:false, Public:true , Virtual:true }, "Loop", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Panning", $.Single);

    $.ImplementInterfaces(
      /* 0 */ $asm03.TypeRef("Fusee.Engine.Common.IAudioStreamImp")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.AudioStream */ 

(function AudioStream$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Void)) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0E.TypeRef("System.Boolean")))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp.get_Loop)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp.get_Panning)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp.get_Volume)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp.Pause)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp.Play)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp.set_Loop)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp.set_Panning)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp.set_Volume)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioStreamImp.Stop)) ();
  };


  function AudioStream__ctor () {
  }; 

  function AudioStream_get_Loop () {
    return $IM00().Call(this._asImp, null);
  }; 

  function AudioStream_get_Panning () {
    return $IM01().Call(this._asImp, null);
  }; 

  function AudioStream_get_Volume () {
    return $IM02().Call(this._asImp, null);
  }; 

  function AudioStream_Pause () {
    $IM03().Call(this._asImp, null);
  }; 

  function AudioStream_Play$00 () {
    $S00().CallVirtual($IM04(), null, this._asImp);
  }; 

  function AudioStream_Play$01 (loop) {
    $S01().CallVirtual($IM04(), null, this._asImp, loop);
  }; 

  function AudioStream_set_Loop (value) {
    $IM05().Call(this._asImp, null, value);
  }; 

  function AudioStream_set_Panning (value) {
    $IM06().Call(this._asImp, null, value);
  }; 

  function AudioStream_set_Volume (value) {
    $IM07().Call(this._asImp, null, value);
  }; 

  function AudioStream_Stop () {
    $IM08().Call(this._asImp, null);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.AudioStream", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AudioStream__ctor
    );

    $.Method({Static:false, Public:true }, "get_Loop", 
      JSIL.MethodSignature.Return($.Boolean), 
      AudioStream_get_Loop
    );

    $.Method({Static:false, Public:true }, "get_Panning", 
      JSIL.MethodSignature.Return($.Single), 
      AudioStream_get_Panning
    );

    $.Method({Static:false, Public:true }, "get_Volume", 
      JSIL.MethodSignature.Return($.Single), 
      AudioStream_get_Volume
    );

    $.Method({Static:false, Public:true }, "Pause", 
      JSIL.MethodSignature.Void, 
      AudioStream_Pause
    );

    $.Method({Static:false, Public:true }, "Play", 
      JSIL.MethodSignature.Void, 
      AudioStream_Play$00
    );

    $.Method({Static:false, Public:false}, "Play", 
      JSIL.MethodSignature.Action($.Boolean), 
      AudioStream_Play$01
    );

    $.Method({Static:false, Public:true }, "set_Loop", 
      JSIL.MethodSignature.Action($.Boolean), 
      AudioStream_set_Loop
    );

    $.Method({Static:false, Public:true }, "set_Panning", 
      JSIL.MethodSignature.Action($.Single), 
      AudioStream_set_Panning
    );

    $.Method({Static:false, Public:true }, "set_Volume", 
      JSIL.MethodSignature.Action($.Single), 
      AudioStream_set_Volume
    );

    $.Method({Static:false, Public:true }, "Stop", 
      JSIL.MethodSignature.Void, 
      AudioStream_Stop
    );

    $.Field({Static:false, Public:true }, "_asImp", $asm03.TypeRef("Fusee.Engine.Common.IAudioStreamImp"));

    $.Property({Static:false, Public:true }, "Volume", $.Single);

    $.Property({Static:false, Public:true }, "Loop", $.Boolean);

    $.Property({Static:false, Public:true }, "Panning", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.CollisionShape */ 

(function CollisionShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_LocalScaling)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function CollisionShape__ctor () {
  }; 

  function CollisionShape_get_LocalScaling () {
    return $IM00().Call(this._collisionShapeImp, null);
  }; 

  function CollisionShape_get_Margin () {
    return $IM01().Call(this._collisionShapeImp, null);
  }; 

  function CollisionShape_set_LocalScaling (value) {
    var o = $thisType.$Cast($IM02().Call(this._collisionShapeImp, null));
    (o._collisionShapeImp.LocalScaling = value.MemberwiseClone());
  }; 

  function CollisionShape_set_Margin (value) {
    var o = $thisType.$Cast($IM02().Call(this._collisionShapeImp, null));
    $IM03().Call(o._collisionShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.CollisionShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CollisionShape__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_LocalScaling", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      CollisionShape_get_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      CollisionShape_get_Margin
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_LocalScaling", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      CollisionShape_set_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      CollisionShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_collisionShapeImp", $asm03.TypeRef("Fusee.Engine.Common.ICollisionShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);

    $.Property({Static:false, Public:true , Virtual:true }, "LocalScaling", $asm09.TypeRef("Fusee.Math.Core.float3"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.BoxShape */ 

(function BoxShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IBoxShapeImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IBoxShapeImp.get_HalfExtents)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_LocalScaling)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function BoxShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function BoxShape_get_HalfExtents () {
    return $IM00().Call(this._boxShapeImp, null);
  }; 

  function BoxShape_get_LocalScaling () {
    return $IM01().Call(this._boxShapeImp, null);
  }; 

  function BoxShape_get_Margin () {
    return $IM02().Call(this._boxShapeImp, null);
  }; 

  function BoxShape_set_LocalScaling (value) {
    var o = $thisType.$Cast($IM03().Call(this._boxShapeImp, null));
    (o._boxShapeImp.LocalScaling = value.MemberwiseClone());
  }; 

  function BoxShape_set_Margin (value) {
    var o = $thisType.$Cast($IM03().Call(this._boxShapeImp, null));
    $IM04().Call(o._boxShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.BoxShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      BoxShape__ctor
    );

    $.Method({Static:false, Public:true }, "get_HalfExtents", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      BoxShape_get_HalfExtents
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_LocalScaling", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      BoxShape_get_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      BoxShape_get_Margin
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_LocalScaling", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      BoxShape_set_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      BoxShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_boxShapeImp", $asm03.TypeRef("Fusee.Engine.Common.IBoxShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "LocalScaling", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "HalfExtents", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.CapsuleShape */ 

(function CapsuleShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICapsuleShapeImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICapsuleShapeImp.get_HalfHeight)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_LocalScaling)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICapsuleShapeImp.get_Radius)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICapsuleShapeImp.get_UpAxis)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function CapsuleShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function CapsuleShape_get_HalfHeight () {
    return $IM00().Call(this._capsuleShapeImp, null);
  }; 

  function CapsuleShape_get_LocalScaling () {
    return $IM01().Call(this._capsuleShapeImp, null);
  }; 

  function CapsuleShape_get_Margin () {
    return $IM02().Call(this._capsuleShapeImp, null);
  }; 

  function CapsuleShape_get_Radius () {
    return $IM03().Call(this._capsuleShapeImp, null);
  }; 

  function CapsuleShape_get_UpAxis () {
    var retval = ($IM04().Call(this._capsuleShapeImp, null) | 0);
    return +retval;
  }; 

  function CapsuleShape_set_LocalScaling (value) {
    var o = $thisType.$Cast($IM05().Call(this._capsuleShapeImp, null));
    (o._capsuleShapeImp.LocalScaling = value.MemberwiseClone());
  }; 

  function CapsuleShape_set_Margin (value) {
    var o = $thisType.$Cast($IM05().Call(this._capsuleShapeImp, null));
    $IM06().Call(o._capsuleShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.CapsuleShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CapsuleShape__ctor
    );

    $.Method({Static:false, Public:true }, "get_HalfHeight", 
      JSIL.MethodSignature.Return($.Single), 
      CapsuleShape_get_HalfHeight
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_LocalScaling", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      CapsuleShape_get_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      CapsuleShape_get_Margin
    );

    $.Method({Static:false, Public:true }, "get_Radius", 
      JSIL.MethodSignature.Return($.Single), 
      CapsuleShape_get_Radius
    );

    $.Method({Static:false, Public:true }, "get_UpAxis", 
      JSIL.MethodSignature.Return($.Single), 
      CapsuleShape_get_UpAxis
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_LocalScaling", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      CapsuleShape_set_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      CapsuleShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_capsuleShapeImp", $asm03.TypeRef("Fusee.Engine.Common.ICapsuleShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);

    $.Property({Static:false, Public:true , Virtual:true }, "LocalScaling", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "HalfHeight", $.Single);

    $.Property({Static:false, Public:true }, "Radius", $.Single);

    $.Property({Static:false, Public:true }, "UpAxis", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.CompoundShape */ 

(function CompoundShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.BoxShape)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICompoundShapeImp)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.SphereShape)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.CapsuleShape)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm04.Fusee.Engine.Core.ConeShape)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm04.Fusee.Engine.Core.CylinderShape)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Engine.Core.MultiSphereShape)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Engine.Core.EmptyShape)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize(System.Array.Of($asm0E.System.Single))) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.Fusee.Math.Core.float4x4, $asm03.Fusee.Engine.Common.IBoxShapeImp]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.Fusee.Math.Core.float4x4, $asm03.Fusee.Engine.Common.ISphereShapeImp]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.Fusee.Math.Core.float4x4, $asm03.Fusee.Engine.Common.ICapsuleShapeImp]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.Fusee.Math.Core.float4x4, $asm03.Fusee.Engine.Common.IConeShapeImp]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.Fusee.Math.Core.float4x4, $asm03.Fusee.Engine.Common.ICylinderShapeImp]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.Fusee.Math.Core.float4x4, $asm03.Fusee.Engine.Common.IMultiSphereShapeImp]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.Fusee.Math.Core.float4x4, $asm03.Fusee.Engine.Common.IEmptyShapeImp]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICompoundShapeImp.AddChildShape)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICompoundShapeImp.CalculatePrincipalAxisTransform)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function CompoundShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function CompoundShape_AddChildShape$00 (localTransform, childShape) {
    $S00().CallVirtual($IM00(), null, this._compoundShapeImp, localTransform.MemberwiseClone(), childShape._boxShapeImp);
  }; 

  function CompoundShape_AddChildShape$01 (localTransform, childShape) {
    $S01().CallVirtual($IM00(), null, this._compoundShapeImp, localTransform.MemberwiseClone(), childShape._sphereShapeImp);
  }; 

  function CompoundShape_AddChildShape$02 (localTransform, childShape) {
    $S02().CallVirtual($IM00(), null, this._compoundShapeImp, localTransform.MemberwiseClone(), childShape._capsuleShapeImp);
  }; 

  function CompoundShape_AddChildShape$03 (localTransform, childShape) {
    $S03().CallVirtual($IM00(), null, this._compoundShapeImp, localTransform.MemberwiseClone(), childShape._coneShapeImp);
  }; 

  function CompoundShape_AddChildShape$04 (localTransform, childShape) {
    $S04().CallVirtual($IM00(), null, this._compoundShapeImp, localTransform.MemberwiseClone(), childShape._cylinderShapeImp);
  }; 

  function CompoundShape_AddChildShape$05 (localTransform, childShape) {
    $S05().CallVirtual($IM00(), null, this._compoundShapeImp, localTransform.MemberwiseClone(), childShape._multiSphereShapeImp);
  }; 

  function CompoundShape_AddChildShape$06 (localTransform, childShape) {
    $S06().CallVirtual($IM00(), null, this._compoundShapeImp, localTransform.MemberwiseClone(), childShape._emtyShapeImp);
  }; 

  function CompoundShape_CalculatePrincipalAxisTransform (masses, principal, inertia) {
    $IM01().Call(this._compoundShapeImp, null, masses, principal.MemberwiseClone(), inertia.MemberwiseClone());
  }; 

  function CompoundShape_get_Margin () {
    return $IM02().Call(this._compoundShapeImp, null);
  }; 

  function CompoundShape_set_Margin (value) {
    var o = $T02().$Cast($IM03().Call(this._compoundShapeImp, null));
    $IM04().Call(o._boxShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.CompoundShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CompoundShape__ctor
    );

    $.Method({Static:false, Public:true }, "AddChildShape", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm04.TypeRef("Fusee.Engine.Core.BoxShape")]), 
      CompoundShape_AddChildShape$00
    );

    $.Method({Static:false, Public:true }, "AddChildShape", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm04.TypeRef("Fusee.Engine.Core.SphereShape")]), 
      CompoundShape_AddChildShape$01
    );

    $.Method({Static:false, Public:true }, "AddChildShape", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm04.TypeRef("Fusee.Engine.Core.CapsuleShape")]), 
      CompoundShape_AddChildShape$02
    );

    $.Method({Static:false, Public:true }, "AddChildShape", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm04.TypeRef("Fusee.Engine.Core.ConeShape")]), 
      CompoundShape_AddChildShape$03
    );

    $.Method({Static:false, Public:true }, "AddChildShape", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm04.TypeRef("Fusee.Engine.Core.CylinderShape")]), 
      CompoundShape_AddChildShape$04
    );

    $.Method({Static:false, Public:true }, "AddChildShape", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm04.TypeRef("Fusee.Engine.Core.MultiSphereShape")]), 
      CompoundShape_AddChildShape$05
    );

    $.Method({Static:false, Public:true }, "AddChildShape", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm04.TypeRef("Fusee.Engine.Core.EmptyShape")]), 
      CompoundShape_AddChildShape$06
    );

    $.Method({Static:false, Public:true }, "CalculatePrincipalAxisTransform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Single]), $asm09.TypeRef("Fusee.Math.Core.float4x4"), 
          $asm09.TypeRef("Fusee.Math.Core.float3")
        ]), 
      CompoundShape_CalculatePrincipalAxisTransform
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      CompoundShape_get_Margin
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      CompoundShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_compoundShapeImp", $asm03.TypeRef("Fusee.Engine.Common.ICompoundShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ConeShape */ 

(function ConeShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeShapeImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeShapeImp.get_ConeUpIndex)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeShapeImp.get_Height)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_LocalScaling)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeShapeImp.get_Radius)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeShapeImp.set_ConeUpIndex)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function ConeShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function ConeShape_get_ConeUpIndex () {
    return $IM00().Call(this._coneShapeImp, null);
  }; 

  function ConeShape_get_Height () {
    return $IM01().Call(this._coneShapeImp, null);
  }; 

  function ConeShape_get_LocalScaling () {
    return $IM02().Call(this._coneShapeImp, null);
  }; 

  function ConeShape_get_Margin () {
    return $IM03().Call(this._coneShapeImp, null);
  }; 

  function ConeShape_get_Radius () {
    return $IM04().Call(this._coneShapeImp, null);
  }; 

  function ConeShape_set_ConeUpIndex (value) {
    var o = $thisType.$Cast($IM05().Call(this._coneShapeImp, null));
    $IM06().Call(o._coneShapeImp, null, value);
  }; 

  function ConeShape_set_LocalScaling (value) {
    var o = $thisType.$Cast($IM05().Call(this._coneShapeImp, null));
    (o._coneShapeImp.LocalScaling = value.MemberwiseClone());
  }; 

  function ConeShape_set_Margin (value) {
    var o = $thisType.$Cast($IM05().Call(this._coneShapeImp, null));
    $IM07().Call(o._coneShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.ConeShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ConeShape__ctor
    );

    $.Method({Static:false, Public:true }, "get_ConeUpIndex", 
      JSIL.MethodSignature.Return($.Int32), 
      ConeShape_get_ConeUpIndex
    );

    $.Method({Static:false, Public:true }, "get_Height", 
      JSIL.MethodSignature.Return($.Single), 
      ConeShape_get_Height
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_LocalScaling", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      ConeShape_get_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      ConeShape_get_Margin
    );

    $.Method({Static:false, Public:true }, "get_Radius", 
      JSIL.MethodSignature.Return($.Single), 
      ConeShape_get_Radius
    );

    $.Method({Static:false, Public:true }, "set_ConeUpIndex", 
      JSIL.MethodSignature.Action($.Int32), 
      ConeShape_set_ConeUpIndex
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_LocalScaling", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      ConeShape_set_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      ConeShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_coneShapeImp", $asm03.TypeRef("Fusee.Engine.Common.IConeShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);

    $.Property({Static:false, Public:true , Virtual:true }, "LocalScaling", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "ConeUpIndex", $.Int32);

    $.Property({Static:false, Public:true }, "Height", $.Single);

    $.Property({Static:false, Public:true }, "Radius", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ConeTwistConstraint */ 

(function ConeTwistConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm04.Fusee.Engine.Core.RigidBody)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm09.Fusee.Math.Core.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Int32, $asm0E.System.Single]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.CalcAngleInfo)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.CalcAngleInfo2)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.EnableMotor)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_AFrame)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_BFrame)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_FixThresh)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_FrameOffsetA)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_FrameOffsetB)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_IsPastSwingLimit)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_UserObject)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyA)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyB)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_SolveSwingLimit)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_SolveTwistLimit)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_SwingSpan1)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_SwingSpan2)) ();
  };
  var $IM10 = function () {
    return ($IM10 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_TwistAngle)) ();
  };
  var $IM11 = function () {
    return ($IM11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_TwistLimitSign)) ();
  };
  var $IM12 = function () {
    return ($IM12 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.get_TwistSpan)) ();
  };
  var $IM13 = function () {
    return ($IM13 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.GetPointForAngle)) ();
  };
  var $IM14 = function () {
    return ($IM14 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.GetUid)) ();
  };
  var $IM15 = function () {
    return ($IM15 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_UserObject)) ();
  };
  var $IM16 = function () {
    return ($IM16 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.set_FixThresh)) ();
  };
  var $IM17 = function () {
    return ($IM17 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.SetAngularOnly)) ();
  };
  var $IM18 = function () {
    return ($IM18 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.SetDamping)) ();
  };
  var $IM19 = function () {
    return ($IM19 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.SetLimit)) ();
  };
  var $IM1A = function () {
    return ($IM1A = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.SetMaxMotorImpulse)) ();
  };
  var $IM1B = function () {
    return ($IM1B = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.SetMaxMotorImpulseNormalized)) ();
  };
  var $IM1C = function () {
    return ($IM1C = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.SetMotorTarget)) ();
  };
  var $IM1D = function () {
    return ($IM1D = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.SetMotorTargetInConstraintSpace)) ();
  };
  var $IM1E = function () {
    return ($IM1E = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp.UpdateRhs)) ();
  };


  function ConeTwistConstraint__ctor () {
  }; 

  function ConeTwistConstraint_CalcAngleInfo () {
    $IM00().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_CalcAngleInfo2 (transA, transB, invInertiaWorldA, invInertiaWorldB) {
    $IM01().Call(this._iCTConstraintImp, null, transA.MemberwiseClone(), transB.MemberwiseClone(), invInertiaWorldA.MemberwiseClone(), invInertiaWorldB.MemberwiseClone());
  }; 

  function ConeTwistConstraint_EnableMotor (b) {
    $IM02().Call(this._iCTConstraintImp, null, b);
  }; 

  function ConeTwistConstraint_get_AFrame () {
    return $IM03().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_BFrame () {
    return $IM04().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_FixThresh () {
    return $IM05().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_FrameOffsetA () {
    return $IM06().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_FrameOffsetB () {
    return $IM07().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_IsPastSwingLimit () {
    return $IM08().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_RigidBodyA () {
    var retval = $IM09().Call($IM0A().Call(this._iCTConstraintImp, null), null);
    return $T06().$Cast(retval);
  }; 

  function ConeTwistConstraint_get_RigidBodyB () {
    var retval = $IM09().Call($IM0B().Call(this._iCTConstraintImp, null), null);
    return $T06().$Cast(retval);
  }; 

  function ConeTwistConstraint_get_SolveSwingLimit () {
    return $IM0C().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_SolveTwistLimit () {
    return $IM0D().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_SwingSpan1 () {
    return $IM0E().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_SwingSpan2 () {
    return $IM0F().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_TwistAngle () {
    return $IM10().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_TwistLimitSign () {
    return $IM11().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_get_TwistSpan () {
    return $IM12().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_GetPointForAngle (fAngleInRadius, fLength) {
    return $IM13().Call(this._iCTConstraintImp, null, fAngleInRadius, fLength);
  }; 

  function ConeTwistConstraint_GetUid () {
    return $IM14().Call(this._iCTConstraintImp, null);
  }; 

  function ConeTwistConstraint_set_FixThresh (value) {
    var o = $thisType.$Cast($IM15().Call(this._iCTConstraintImp, null));
    $IM16().Call(o._iCTConstraintImp, null, value);
  }; 

  function ConeTwistConstraint_SetAngularOnly (angularOnly) {
    $IM17().Call(this._iCTConstraintImp, null, angularOnly);
  }; 

  function ConeTwistConstraint_SetDamping (damping) {
    $IM18().Call(this._iCTConstraintImp, null, damping);
  }; 

  function ConeTwistConstraint_SetLimit$00 (limitIndex, limitValue) {
    $S00().CallVirtual($IM19(), null, this._iCTConstraintImp, limitIndex, limitValue);
  }; 

  function ConeTwistConstraint_SetLimit$01 (swingSpan1, swingSpan2, twistSpan, softness, biasFactor, relaxationFactor) {
    $S01().CallVirtual($IM19(), null, this._iCTConstraintImp, 
      swingSpan1, 
      swingSpan2, 
      twistSpan, 
      softness, 
      biasFactor, 
      relaxationFactor
    );
  }; 

  function ConeTwistConstraint_SetMaxMotorImpulse (maxMotorImpulse) {
    $IM1A().Call(this._iCTConstraintImp, null, maxMotorImpulse);
  }; 

  function ConeTwistConstraint_SetMaxMotorImpulseNormalized (maxMotorImpulse) {
    $IM1B().Call(this._iCTConstraintImp, null, maxMotorImpulse);
  }; 

  function ConeTwistConstraint_SetMotorTarget (q) {
    $IM1C().Call(this._iCTConstraintImp, null, q.MemberwiseClone());
  }; 

  function ConeTwistConstraint_SetMotorTargetInConstraintSpace (q) {
    $IM1D().Call(this._iCTConstraintImp, null, q.MemberwiseClone());
  }; 

  function ConeTwistConstraint_UpdateRhs (timeStep) {
    $IM1E().Call(this._iCTConstraintImp, null, timeStep);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.ConeTwistConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ConeTwistConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "CalcAngleInfo", 
      JSIL.MethodSignature.Void, 
      ConeTwistConstraint_CalcAngleInfo
    );

    $.Method({Static:false, Public:true }, "CalcAngleInfo2", 
      new JSIL.MethodSignature(null, [
          $asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4"), 
          $asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4")
        ]), 
      ConeTwistConstraint_CalcAngleInfo2
    );

    $.Method({Static:false, Public:true }, "EnableMotor", 
      JSIL.MethodSignature.Action($.Boolean), 
      ConeTwistConstraint_EnableMotor
    );

    $.Method({Static:false, Public:true }, "get_AFrame", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      ConeTwistConstraint_get_AFrame
    );

    $.Method({Static:false, Public:true }, "get_BFrame", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      ConeTwistConstraint_get_BFrame
    );

    $.Method({Static:false, Public:true }, "get_FixThresh", 
      JSIL.MethodSignature.Return($.Single), 
      ConeTwistConstraint_get_FixThresh
    );

    $.Method({Static:false, Public:true }, "get_FrameOffsetA", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      ConeTwistConstraint_get_FrameOffsetA
    );

    $.Method({Static:false, Public:true }, "get_FrameOffsetB", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      ConeTwistConstraint_get_FrameOffsetB
    );

    $.Method({Static:false, Public:true }, "get_IsPastSwingLimit", 
      JSIL.MethodSignature.Return($.Boolean), 
      ConeTwistConstraint_get_IsPastSwingLimit
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyA", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      ConeTwistConstraint_get_RigidBodyA
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyB", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      ConeTwistConstraint_get_RigidBodyB
    );

    $.Method({Static:false, Public:true }, "get_SolveSwingLimit", 
      JSIL.MethodSignature.Return($.Int32), 
      ConeTwistConstraint_get_SolveSwingLimit
    );

    $.Method({Static:false, Public:true }, "get_SolveTwistLimit", 
      JSIL.MethodSignature.Return($.Int32), 
      ConeTwistConstraint_get_SolveTwistLimit
    );

    $.Method({Static:false, Public:true }, "get_SwingSpan1", 
      JSIL.MethodSignature.Return($.Single), 
      ConeTwistConstraint_get_SwingSpan1
    );

    $.Method({Static:false, Public:true }, "get_SwingSpan2", 
      JSIL.MethodSignature.Return($.Single), 
      ConeTwistConstraint_get_SwingSpan2
    );

    $.Method({Static:false, Public:true }, "get_TwistAngle", 
      JSIL.MethodSignature.Return($.Single), 
      ConeTwistConstraint_get_TwistAngle
    );

    $.Method({Static:false, Public:true }, "get_TwistLimitSign", 
      JSIL.MethodSignature.Return($.Single), 
      ConeTwistConstraint_get_TwistLimitSign
    );

    $.Method({Static:false, Public:true }, "get_TwistSpan", 
      JSIL.MethodSignature.Return($.Single), 
      ConeTwistConstraint_get_TwistSpan
    );

    $.Method({Static:false, Public:true }, "GetPointForAngle", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.float3"), [$.Single, $.Single]), 
      ConeTwistConstraint_GetPointForAngle
    );

    $.Method({Static:false, Public:true }, "GetUid", 
      JSIL.MethodSignature.Return($.Int32), 
      ConeTwistConstraint_GetUid
    );

    $.Method({Static:false, Public:true }, "set_FixThresh", 
      JSIL.MethodSignature.Action($.Single), 
      ConeTwistConstraint_set_FixThresh
    );

    $.Method({Static:false, Public:true }, "SetAngularOnly", 
      JSIL.MethodSignature.Action($.Boolean), 
      ConeTwistConstraint_SetAngularOnly
    );

    $.Method({Static:false, Public:true }, "SetDamping", 
      JSIL.MethodSignature.Action($.Single), 
      ConeTwistConstraint_SetDamping
    );

    $.Method({Static:false, Public:true }, "SetLimit", 
      new JSIL.MethodSignature(null, [$.Int32, $.Single]), 
      ConeTwistConstraint_SetLimit$00
    );

    $.Method({Static:false, Public:true }, "SetLimit", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      ConeTwistConstraint_SetLimit$01
    );

    $.Method({Static:false, Public:true }, "SetMaxMotorImpulse", 
      JSIL.MethodSignature.Action($.Single), 
      ConeTwistConstraint_SetMaxMotorImpulse
    );

    $.Method({Static:false, Public:true }, "SetMaxMotorImpulseNormalized", 
      JSIL.MethodSignature.Action($.Single), 
      ConeTwistConstraint_SetMaxMotorImpulseNormalized
    );

    $.Method({Static:false, Public:true }, "SetMotorTarget", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.Quaternion")), 
      ConeTwistConstraint_SetMotorTarget
    );

    $.Method({Static:false, Public:true }, "SetMotorTargetInConstraintSpace", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.Quaternion")), 
      ConeTwistConstraint_SetMotorTargetInConstraintSpace
    );

    $.Method({Static:false, Public:true }, "UpdateRhs", 
      JSIL.MethodSignature.Action($.Single), 
      ConeTwistConstraint_UpdateRhs
    );

    $.Field({Static:false, Public:false}, "_iCTConstraintImp", $asm03.TypeRef("Fusee.Engine.Common.IConeTwistConstraintImp"));

    $.Property({Static:false, Public:true }, "AFrame", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "BFrame", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "FixThresh", $.Single);

    $.Property({Static:false, Public:true }, "FrameOffsetA", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "FrameOffsetB", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "IsPastSwingLimit", $.Boolean);

    $.Property({Static:false, Public:true }, "SolveSwingLimit", $.Int32);

    $.Property({Static:false, Public:true }, "SolveTwistLimit", $.Int32);

    $.Property({Static:false, Public:true }, "SwingSpan1", $.Single);

    $.Property({Static:false, Public:true }, "SwingSpan2", $.Single);

    $.Property({Static:false, Public:true }, "TwistAngle", $.Single);

    $.Property({Static:false, Public:true }, "TwistLimitSign", $.Single);

    $.Property({Static:false, Public:true }, "TwistSpan", $.Single);

    $.Property({Static:false, Public:true }, "RigidBodyA", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));

    $.Property({Static:false, Public:true }, "RigidBodyB", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ConvexHullShape */ 

(function ConvexHullShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConvexHullShapeImp)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConvexHullShapeImp.AddPoint)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConvexHullShapeImp.GetNumPoints)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConvexHullShapeImp.GetScaledPoint)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConvexHullShapeImp.GetUnscaledPoints)) ();
  };


  function ConvexHullShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function ConvexHullShape_AddPoint (point) {
    var o = $thisType.$Cast($IM00().Call(this._convexHullShapeImp, null));
    $IM01().Call(o._convexHullShapeImp, null, point.MemberwiseClone());
  }; 

  function ConvexHullShape_GetNumPoints () {
    return $IM02().Call(this._convexHullShapeImp, null);
  }; 

  function ConvexHullShape_GetScaledPoint (index) {
    return $IM03().Call(this._convexHullShapeImp, null, index);
  }; 

  function ConvexHullShape_GetUnscaledPoints () {
    return $IM04().Call(this._convexHullShapeImp, null);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.ConvexHullShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ConvexHullShape__ctor
    );

    $.Method({Static:false, Public:true }, "AddPoint", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      ConvexHullShape_AddPoint
    );

    $.Method({Static:false, Public:true }, "GetNumPoints", 
      JSIL.MethodSignature.Return($.Int32), 
      ConvexHullShape_GetNumPoints
    );

    $.Method({Static:false, Public:true }, "GetScaledPoint", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.float3"), [$.Int32]), 
      ConvexHullShape_GetScaledPoint
    );

    $.Method({Static:false, Public:true }, "GetUnscaledPoints", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")])), 
      ConvexHullShape_GetUnscaledPoints
    );

    $.Field({Static:false, Public:false}, "_convexHullShapeImp", $asm03.TypeRef("Fusee.Engine.Common.IConvexHullShapeImp"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Mesh */ 

(function Mesh$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float4))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt32))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt16))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.get_BoneIndicesSet)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.get_BoneWeightsSet)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.get_ColorsSet)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.get_NormalsSet)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.get_TrianglesSet)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.get_UVsSet)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.get_VerticesSet)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.InvalidateBoneIndices)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.InvalidateBoneWeights)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.InvalidateColors)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.InvalidateNormals)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.InvalidateTriangles)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.InvalidateUVs)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.IMeshImp.InvalidateVertices)) ();
  };


  function Mesh__ctor () {
  }; 

  function Mesh_get_BoneIndices () {
    return this._boneIndices;
  }; 

  function Mesh_get_BoneIndicesSet () {
    return ((this._meshImp !== null) && $IM00().Call(this._meshImp, null));
  }; 

  function Mesh_get_BoneWeights () {
    return this._boneWeights;
  }; 

  function Mesh_get_BoneWeightsSet () {
    return ((this._meshImp !== null) && $IM01().Call(this._meshImp, null));
  }; 

  function Mesh_get_Colors () {
    return this._colors;
  }; 

  function Mesh_get_ColorsSet () {
    return ((this._meshImp !== null) && $IM02().Call(this._meshImp, null));
  }; 

  function Mesh_get_Normals () {
    return this._normals;
  }; 

  function Mesh_get_NormalsSet () {
    return ((this._meshImp !== null) && $IM03().Call(this._meshImp, null));
  }; 

  function Mesh_get_Triangles () {
    return this._triangles;
  }; 

  function Mesh_get_TrianglesSet () {
    return ((this._meshImp !== null) && $IM04().Call(this._meshImp, null));
  }; 

  function Mesh_get_UVs () {
    return this._uvs;
  }; 

  function Mesh_get_UVsSet () {
    return ((this._meshImp !== null) && $IM05().Call(this._meshImp, null));
  }; 

  function Mesh_get_Vertices () {
    return this._vertices;
  }; 

  function Mesh_get_VerticesSet () {
    return ((this._meshImp !== null) && $IM06().Call(this._meshImp, null));
  }; 

  function Mesh_set_BoneIndices (value) {
    if (this._meshImp !== null) {
      $IM07().Call(this._meshImp, null);
    }
    this._boneIndices = value;
  }; 

  function Mesh_set_BoneWeights (value) {
    if (this._meshImp !== null) {
      $IM08().Call(this._meshImp, null);
    }
    this._boneWeights = value;
  }; 

  function Mesh_set_Colors (value) {
    if (this._meshImp !== null) {
      $IM09().Call(this._meshImp, null);
    }
    this._colors = value;
  }; 

  function Mesh_set_Normals (value) {
    if (this._meshImp !== null) {
      $IM0A().Call(this._meshImp, null);
    }
    this._normals = value;
  }; 

  function Mesh_set_Triangles (value) {
    if (this._meshImp !== null) {
      $IM0B().Call(this._meshImp, null);
    }
    this._triangles = value;
  }; 

  function Mesh_set_UVs (value) {
    if (this._meshImp !== null) {
      $IM0C().Call(this._meshImp, null);
    }
    this._uvs = value;
  }; 

  function Mesh_set_Vertices (value) {
    if (this._meshImp !== null) {
      $IM0D().Call(this._meshImp, null);
    }
    this._vertices = value;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Mesh", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Mesh__ctor
    );

    $.Method({Static:false, Public:true }, "get_BoneIndices", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4")])), 
      Mesh_get_BoneIndices
    );

    $.Method({Static:false, Public:true }, "get_BoneIndicesSet", 
      JSIL.MethodSignature.Return($.Boolean), 
      Mesh_get_BoneIndicesSet
    );

    $.Method({Static:false, Public:true }, "get_BoneWeights", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4")])), 
      Mesh_get_BoneWeights
    );

    $.Method({Static:false, Public:true }, "get_BoneWeightsSet", 
      JSIL.MethodSignature.Return($.Boolean), 
      Mesh_get_BoneWeightsSet
    );

    $.Method({Static:false, Public:true }, "get_Colors", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.UInt32])), 
      Mesh_get_Colors
    );

    $.Method({Static:false, Public:true }, "get_ColorsSet", 
      JSIL.MethodSignature.Return($.Boolean), 
      Mesh_get_ColorsSet
    );

    $.Method({Static:false, Public:true }, "get_Normals", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")])), 
      Mesh_get_Normals
    );

    $.Method({Static:false, Public:true }, "get_NormalsSet", 
      JSIL.MethodSignature.Return($.Boolean), 
      Mesh_get_NormalsSet
    );

    $.Method({Static:false, Public:true }, "get_Triangles", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.UInt16])), 
      Mesh_get_Triangles
    );

    $.Method({Static:false, Public:true }, "get_TrianglesSet", 
      JSIL.MethodSignature.Return($.Boolean), 
      Mesh_get_TrianglesSet
    );

    $.Method({Static:false, Public:true }, "get_UVs", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float2")])), 
      Mesh_get_UVs
    );

    $.Method({Static:false, Public:true }, "get_UVsSet", 
      JSIL.MethodSignature.Return($.Boolean), 
      Mesh_get_UVsSet
    );

    $.Method({Static:false, Public:true }, "get_Vertices", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")])), 
      Mesh_get_Vertices
    );

    $.Method({Static:false, Public:true }, "get_VerticesSet", 
      JSIL.MethodSignature.Return($.Boolean), 
      Mesh_get_VerticesSet
    );

    $.Method({Static:false, Public:true }, "set_BoneIndices", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4")])), 
      Mesh_set_BoneIndices
    );

    $.Method({Static:false, Public:true }, "set_BoneWeights", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4")])), 
      Mesh_set_BoneWeights
    );

    $.Method({Static:false, Public:true }, "set_Colors", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.UInt32])), 
      Mesh_set_Colors
    );

    $.Method({Static:false, Public:true }, "set_Normals", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")])), 
      Mesh_set_Normals
    );

    $.Method({Static:false, Public:true }, "set_Triangles", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.UInt16])), 
      Mesh_set_Triangles
    );

    $.Method({Static:false, Public:true }, "set_UVs", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float2")])), 
      Mesh_set_UVs
    );

    $.Method({Static:false, Public:true }, "set_Vertices", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")])), 
      Mesh_set_Vertices
    );

    $.Field({Static:false, Public:false}, "_meshImp", $asm03.TypeRef("Fusee.Engine.Common.IMeshImp"));

    $.Field({Static:false, Public:false}, "_vertices", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "_colors", $jsilcore.TypeRef("System.Array", [$.UInt32]));

    $.Field({Static:false, Public:false}, "_normals", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "_uvs", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float2")]));

    $.Field({Static:false, Public:false}, "_boneWeights", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4")]));

    $.Field({Static:false, Public:false}, "_boneIndices", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4")]));

    $.Field({Static:false, Public:false}, "_triangles", $jsilcore.TypeRef("System.Array", [$.UInt16]));

    $.Property({Static:false, Public:true }, "Vertices", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]));

    $.Property({Static:false, Public:true }, "VerticesSet", $.Boolean);

    $.Property({Static:false, Public:true }, "Colors", $jsilcore.TypeRef("System.Array", [$.UInt32]));

    $.Property({Static:false, Public:true }, "ColorsSet", $.Boolean);

    $.Property({Static:false, Public:true }, "Normals", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]));

    $.Property({Static:false, Public:true }, "NormalsSet", $.Boolean);

    $.Property({Static:false, Public:true }, "UVs", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float2")]));

    $.Property({Static:false, Public:true }, "UVsSet", $.Boolean);

    $.Property({Static:false, Public:true }, "BoneWeights", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4")]));

    $.Property({Static:false, Public:true }, "BoneWeightsSet", $.Boolean);

    $.Property({Static:false, Public:true }, "BoneIndices", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4")]));

    $.Property({Static:false, Public:true }, "BoneIndicesSet", $.Boolean);

    $.Property({Static:false, Public:true }, "Triangles", $jsilcore.TypeRef("System.Array", [$.UInt16]));

    $.Property({Static:false, Public:true }, "TrianglesSet", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm10.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* class Fusee.Engine.Core.Cube */ 

(function Cube$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.UInt16)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float3, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };


  function Cube__ctor () {
    $T00().prototype._ctor.call(this);
    var expr_10 = JSIL.Array.New($T02(), 24);
    var float = new ($T02())();
    float.x = 0.5;
    float.y = -0.5;
    float.z = 0.5;
    expr_10[0] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = 0.5;
    float.z = 0.5;
    expr_10[1] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = 0.5;
    float.z = 0.5;
    expr_10[2] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = -0.5;
    float.z = 0.5;
    expr_10[3] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = -0.5;
    float.z = -0.5;
    expr_10[4] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = 0.5;
    float.z = -0.5;
    expr_10[5] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = 0.5;
    float.z = 0.5;
    expr_10[6] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = -0.5;
    float.z = 0.5;
    expr_10[7] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = -0.5;
    float.z = -0.5;
    expr_10[8] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = 0.5;
    float.z = -0.5;
    expr_10[9] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = 0.5;
    float.z = -0.5;
    expr_10[10] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = -0.5;
    float.z = -0.5;
    expr_10[11] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = -0.5;
    float.z = 0.5;
    expr_10[12] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = 0.5;
    float.z = 0.5;
    expr_10[13] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = 0.5;
    float.z = -0.5;
    expr_10[14] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = -0.5;
    float.z = -0.5;
    expr_10[15] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = 0.5;
    float.z = 0.5;
    expr_10[16] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = 0.5;
    float.z = -0.5;
    expr_10[17] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = 0.5;
    float.z = -0.5;
    expr_10[18] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = 0.5;
    float.z = 0.5;
    expr_10[19] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = -0.5;
    float.z = -0.5;
    expr_10[20] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = 0.5;
    float.y = -0.5;
    float.z = 0.5;
    expr_10[21] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = -0.5;
    float.z = 0.5;
    expr_10[22] = float.MemberwiseClone();
    float = new ($T02())();
    float.x = -0.5;
    float.y = -0.5;
    float.z = -0.5;
    expr_10[23] = float.MemberwiseClone();
    this.set_Vertices(expr_10);
    this.set_Triangles(JSIL.Array.New($T03(), [0, 2, 1, 0, 3, 2, 4, 6, 5, 4, 7, 6, 8, 10, 9, 8, 11, 10, 12, 14, 13, 12, 15, 14, 16, 18, 17, 16, 19, 18, 20, 22, 21, 20, 23, 22]));
    this.set_Normals(JSIL.Array.New($T02(), [$S00().Construct(0, 0, 1), $S00().Construct(0, 0, 1), $S00().Construct(0, 0, 1), $S00().Construct(0, 0, 1), $S00().Construct(1, 0, 0), $S00().Construct(1, 0, 0), $S00().Construct(1, 0, 0), $S00().Construct(1, 0, 0), $S00().Construct(0, 0, -1), $S00().Construct(0, 0, -1), $S00().Construct(0, 0, -1), $S00().Construct(0, 0, -1), $S00().Construct(-1, 0, 0), $S00().Construct(-1, 0, 0), $S00().Construct(-1, 0, 0), $S00().Construct(-1, 0, 0), $S00().Construct(0, 1, 0), $S00().Construct(0, 1, 0), $S00().Construct(0, 1, 0), $S00().Construct(0, 1, 0), $S00().Construct(0, -1, 0), $S00().Construct(0, -1, 0), $S00().Construct(0, -1, 0), $S00().Construct(0, -1, 0)]));
    this.set_UVs(JSIL.Array.New($T04(), [$S01().Construct(1, 0), $S01().Construct(1, 1), $S01().Construct(0, 1), $S01().Construct(0, 0), $S01().Construct(1, 0), $S01().Construct(1, 1), $S01().Construct(0, 1), $S01().Construct(0, 0), $S01().Construct(1, 0), $S01().Construct(1, 1), $S01().Construct(0, 1), $S01().Construct(0, 0), $S01().Construct(1, 0), $S01().Construct(1, 1), $S01().Construct(0, 1), $S01().Construct(0, 0), $S01().Construct(1, 0), $S01().Construct(1, 1), $S01().Construct(0, 1), $S01().Construct(0, 0), $S01().Construct(1, 0), $S01().Construct(1, 1), $S01().Construct(0, 1), $S01().Construct(0, 0)]));
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.Mesh"), 
      Name: "Fusee.Engine.Core.Cube", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Cube__ctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.CylinderShape */ 

(function CylinderShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICylinderShapeImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICylinderShapeImp.get_HalfExtents)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_LocalScaling)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICylinderShapeImp.get_Radius)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICylinderShapeImp.get_UpAxis)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function CylinderShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function CylinderShape_get_HalfExtents () {
    return $IM00().Call(this._cylinderShapeImp, null);
  }; 

  function CylinderShape_get_LocalScaling () {
    return $IM01().Call(this._cylinderShapeImp, null);
  }; 

  function CylinderShape_get_Margin () {
    return $IM02().Call(this._cylinderShapeImp, null);
  }; 

  function CylinderShape_get_Radius () {
    return $IM03().Call(this._cylinderShapeImp, null);
  }; 

  function CylinderShape_get_UpAxis () {
    var retval = ($IM04().Call(this._cylinderShapeImp, null) | 0);
    return +retval;
  }; 

  function CylinderShape_set_LocalScaling (value) {
    var o = $thisType.$Cast($IM05().Call(this._cylinderShapeImp, null));
    (o._cylinderShapeImp.LocalScaling = value.MemberwiseClone());
  }; 

  function CylinderShape_set_Margin (value) {
    var o = $thisType.$Cast($IM05().Call(this._cylinderShapeImp, null));
    $IM06().Call(o._cylinderShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.CylinderShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CylinderShape__ctor
    );

    $.Method({Static:false, Public:true }, "get_HalfExtents", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      CylinderShape_get_HalfExtents
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_LocalScaling", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      CylinderShape_get_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      CylinderShape_get_Margin
    );

    $.Method({Static:false, Public:true }, "get_Radius", 
      JSIL.MethodSignature.Return($.Single), 
      CylinderShape_get_Radius
    );

    $.Method({Static:false, Public:true }, "get_UpAxis", 
      JSIL.MethodSignature.Return($.Single), 
      CylinderShape_get_UpAxis
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_LocalScaling", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      CylinderShape_set_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      CylinderShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_cylinderShapeImp", $asm03.TypeRef("Fusee.Engine.Common.ICylinderShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);

    $.Property({Static:false, Public:true , Virtual:true }, "LocalScaling", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "HalfExtents", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "Radius", $.Single);

    $.Property({Static:false, Public:true }, "UpAxis", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.DeferredShaderHelper */ 

(function DeferredShaderHelper$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.FullscreenQuad)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize(System.Array.Of($asm0E.System.String))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm0E.System.Single]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };


  function DeferredShaderHelper_DeferredDrawPassPixelShader () {
    return JSIL.ConcatString.apply(null, JSIL.Array.New($T02(), [$thisType.GlslVersion(), "\r\n                #ifdef GL_ES\r\n                    precision highp float\r\n                #endif", $thisType.MaxLights(), "\n", $thisType.LightStructDeclaration(), "varying vec2 uv;\r\n                \r\n                uniform mat4 FUSEE_IMV;\r\n\r\n                uniform sampler2D gPosition;\r\n                uniform sampler2D gNormal;\r\n                uniform sampler2D gAlbedoSpec;\r\n                uniform sampler2D gDepth;\r\n                uniform sampler2D gViewDir;\r\n\r\n                uniform vec2 gScreenSize;\r\n\r\n                uniform mat4 FUSEE_MV;\r\n\r\n                vec2 CalcTexCoord()\r\n                {\r\n                    return gl_FragCoord.xy / gScreenSize;\r\n                }         \r\n                \r\n            vec3 ApplyLight(vec3 position, vec3 intensities, vec3 coneDirection, float attenuation, float ambientCoefficient, float coneAngle, int lightType) {\r\n\r\n                vec3 surfacePos = texture2D(gPosition, CalcTexCoord()).rgb;\r\n                vec3 normal = texture2D(gNormal, CalcTexCoord()).rgb;\r\n                vec3 albedo = texture2D(gAlbedoSpec, CalcTexCoord()).rgb;              \r\n                float specularIntensity = texture2D(gAlbedoSpec, uv).a;\r\n                float depth = texture2D(gDepth, CalcTexCoord()).r; \r\n\r\n                vec3 CameraFromMatrix = FUSEE_IMV[3].xyz;\r\n\r\n                vec3 L = normalize(position - surfacePos.xyz); // This is parallel Light\r\n                //vec3 L = normalize(vec3(0.0,0.0,1.0)); // This is legacy light\r\n                vec3 N = normalize((normal * 0.5) + 0.5);\r\n                vec3 V = normalize(-surfacePos.xyz);              \r\n\r\n                vec3 H = normalize(L + V);\r\n\r\n                float diffFactor = dot(L, N);\r\n                float specFactor = 0.0;\r\n\r\n                if(diffFactor > 0.0)\r\n                     specFactor = pow(max(dot(N, H), 0.0), 16.0);\r\n\r\n                //return specFactor * vec3(0.9,0.9,0.9)  + clamp(diffFactor, 0.0, 1.0) *  vec3(0.6,0.1,0.8) + albedo; // albedo does not work... \r\n                return albedo;\r\n            }   \r\n\r\n\r\n            // TODO: Custom Light and Material Params\r\n            void main()\r\n            {               \r\n                vec3 result = vec3(0.0);\r\n\r\n         \r\n                for(int i = 0; i < MAX_LIGHTS;i++) {\r\n\r\n                vec3 currentPosition = allLights[i].position;\r\n                vec3 currentIntensities = allLights[i].intensities;\r\n                vec3 currentConeDirection = allLights[i].coneDirection;\r\n                float currentAttenuation = allLights[i].attenuation;\r\n                float currentAmbientCoefficient = allLights[i].ambientCoefficient;\r\n                float currentConeAngle = allLights[i].coneAngle;\r\n                int currentLightType = allLights[i].lightType;\r\n             \r\n                 result += ApplyLight(currentPosition, currentIntensities, currentConeDirection, currentAttenuation, currentAmbientCoefficient, currentConeAngle, currentLightType);\r\n                \r\n                }\r\n\r\n               // vec3 albedo = texture2D(gAlbedoSpec, uv).rgb;\r\n\r\n                gl_FragColor = vec4(result,1.0);\r\n\r\n            }"]));
  }; 

  function DeferredShaderHelper_DeferredDrawPassVertexShader () {
    return JSIL.ConcatString($thisType.GlslVersion(), "\r\n\r\n                attribute vec3 fuVertex;\r\n                attribute vec2 fuUV; \r\n                           \r\n                \r\n                varying vec2 uv;       \r\n\r\n                void main()\r\n                {                  \r\n\t                gl_Position = vec4(fuVertex, 1.0);\r\n                    uv = fuUV;\r\n                }");
  }; 

  function DeferredShaderHelper_DeferredFullscreenQuad () {
    return $thisType.Quad;
  }; 

  function DeferredShaderHelper_DeferredPassPixelShader () {
    return JSIL.ConcatString($thisType.GlslVersion(), "\r\n                #ifdef GL_ES\r\n                    precision highp float\r\n                #endif      \r\n                   \r\n                varying vec2 uv;\r\n                varying vec3 normal;\r\n                varying vec3 surfacePos;\r\n                varying vec3 vViewDir;\r\n       \r\n                uniform vec3 DiffuseColor;\r\n                uniform sampler2D tDiffuse;\r\n                uniform vec3 SpecularIntensity;\r\n                \r\n            void main()\r\n            { \r\n                // Store the fragment position vector in the first gbuffer texture\r\n                gl_FragData[0] = vec4(surfacePos,1.0);\r\n                // Also store the per-fragment normals into the gbuffer\r\n                gl_FragData[1] = vec4(normal,1.0);\r\n                // And the diffuse per-fragment color   \r\n                // Store specular intensity in gAlbedoSpec's alpha component                     \r\n                gl_FragData[2] = vec4(DiffuseColor, 1.0);\r\n                gl_FragData[3] = vec4(gl_FragCoord.rrr, 1.0);\r\n          }");
  }; 

  function DeferredShaderHelper_DeferredPassVertexShader () {
    return JSIL.ConcatString($thisType.GlslVersion(), "\r\n                \r\n                attribute vec3 fuVertex;\r\n                attribute vec3 fuNormal;\r\n                attribute vec2 fuUV;\r\n\r\n                uniform mat4 FUSEE_MVP;\r\n                uniform mat4 FUSEE_ITMV;\r\n                uniform mat4 FUSEE_MV;\r\n                uniform mat4 FUSEE_IMV;\r\n                uniform mat4 FUSEE_M;\r\n                \r\n                varying vec2 uv;\r\n                varying vec3 normal;\r\n                varying vec3 surfacePos;\r\n                varying vec3 vViewDir;\r\n\r\n                void main()\r\n                {\r\n                    normal =  normalize(mat3(FUSEE_ITMV) * fuNormal);\r\n\t                uv = fuUV;\r\n                   \r\n\t                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n                    surfacePos = FUSEE_MV * vec4(fuVertex, 1.0);\r\n                }");
  }; 

  function DeferredShaderHelper_get_ShadowMapMVP () {
    return $thisType.DeferredShaderHelper$ShadowMapMVP$value;
  }; 

  function DeferredShaderHelper_GlslVersion () {
    return "";
  }; 

  function DeferredShaderHelper_LightStructDeclaration () {
    return "\r\n            struct Light \r\n            {\r\n                vec3 position;\r\n                vec3 intensities;\r\n                vec3 coneDirection;\r\n                float attenuation;\r\n                float ambientCoefficient;\r\n                float coneAngle;\r\n                int lightType;\r\n            };\r\n            uniform Light allLights[MAX_LIGHTS];  \r\n            ";
  }; 

  function DeferredShaderHelper_MaxLights () {
    return $T02().Format("\n\n#define MAX_LIGHTS {0}\n", JSIL.Array.New($T04(), [$T05().$Box($thisType.Maxlights)]));
  }; 

  function DeferredShaderHelper_OrtographicShadowMapMvPixelShader () {
    return JSIL.ConcatString($thisType.GlslVersion(), "\r\n            void main()\r\n            {  \r\n               // This is not necessary, only for debugging purposes                                            \r\n               gl_FragColor = gl_FragCoord;\r\n            }");
  }; 

  function DeferredShaderHelper_OrtographicShadowMapMvVertexShader () {
    return JSIL.ConcatString($thisType.GlslVersion(), "\r\n                attribute vec3 fuVertex;\r\n\r\n                uniform mat4 LightMVP;\r\n                uniform mat4 FUSEE_MV;\r\n\r\n                void main()\r\n                {\r\n                    vec4 fuVertexMVSpace = FUSEE_MV * vec4(fuVertex,1.0);\r\n                    gl_Position = LightMVP * fuVertexMVSpace;\r\n                }");
  }; 

  function DeferredShaderHelper_set_ShadowMapMVP (value) {
    $thisType.DeferredShaderHelper$ShadowMapMVP$value = value.MemberwiseClone();
  }; 

  function DeferredShaderHelper_SetShadowMapMVP (lightPosition, coneDirection, sceneScale, currentView) {
    var lightCone = coneDirection.MemberwiseClone();
    lightCone.Normalize();
    var target = lightCone;
    var depthViewMatrix = $T01().LookAt(
      lightPosition.x, 
      lightPosition.y, 
      lightPosition.z, 
      target.x, 
      target.y, 
      target.z, 
      0, 
      1, 
      0
    );
    var scale = $S00().CallStatic($T01(), "CreateScale", null, sceneScale);
    var depthModelMatrix = scale;
    var projection = $T01().CreateOrthographic(50, 50, -40, 50).MemberwiseClone();
    var lightModelView = $S01().CallStatic($T01(), "op_Multiply", null, depthViewMatrix.MemberwiseClone(), depthModelMatrix.MemberwiseClone()).MemberwiseClone();
    var invView = $T01().Invert(currentView.MemberwiseClone()).MemberwiseClone();
    ($thisType.DeferredShaderHelper$ShadowMapMVP$value = $S01().CallStatic($T01(), "op_Multiply", null, $S01().CallStatic($T01(), "op_Multiply", null, projection.MemberwiseClone(), lightModelView.MemberwiseClone()).MemberwiseClone(), invView.MemberwiseClone()).MemberwiseClone());
  }; 

  JSIL.MakeStaticClass("Fusee.Engine.Core.DeferredShaderHelper", true, [], function ($ib) {
    $ = $ib;

    $.Method({Static:true , Public:true }, "DeferredDrawPassPixelShader", 
      JSIL.MethodSignature.Return($.String), 
      DeferredShaderHelper_DeferredDrawPassPixelShader
    );

    $.Method({Static:true , Public:true }, "DeferredDrawPassVertexShader", 
      JSIL.MethodSignature.Return($.String), 
      DeferredShaderHelper_DeferredDrawPassVertexShader
    );

    $.Method({Static:true , Public:true }, "DeferredFullscreenQuad", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      DeferredShaderHelper_DeferredFullscreenQuad
    );

    $.Method({Static:true , Public:true }, "DeferredPassPixelShader", 
      JSIL.MethodSignature.Return($.String), 
      DeferredShaderHelper_DeferredPassPixelShader
    );

    $.Method({Static:true , Public:true }, "DeferredPassVertexShader", 
      JSIL.MethodSignature.Return($.String), 
      DeferredShaderHelper_DeferredPassVertexShader
    );

    $.Method({Static:true , Public:true }, "get_ShadowMapMVP", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      DeferredShaderHelper_get_ShadowMapMVP
    );

    $.Method({Static:true , Public:true }, "GlslVersion", 
      JSIL.MethodSignature.Return($.String), 
      DeferredShaderHelper_GlslVersion
    );

    $.Method({Static:true , Public:false}, "LightStructDeclaration", 
      JSIL.MethodSignature.Return($.String), 
      DeferredShaderHelper_LightStructDeclaration
    );

    $.Method({Static:true , Public:true }, "MaxLights", 
      JSIL.MethodSignature.Return($.String), 
      DeferredShaderHelper_MaxLights
    );

    $.Method({Static:true , Public:true }, "OrtographicShadowMapMvPixelShader", 
      JSIL.MethodSignature.Return($.String), 
      DeferredShaderHelper_OrtographicShadowMapMvPixelShader
    );

    $.Method({Static:true , Public:true }, "OrtographicShadowMapMvVertexShader", 
      JSIL.MethodSignature.Return($.String), 
      DeferredShaderHelper_OrtographicShadowMapMvVertexShader
    );

    $.Method({Static:true , Public:false}, "set_ShadowMapMVP", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      DeferredShaderHelper_set_ShadowMapMVP
    );

    $.Method({Static:true , Public:true }, "SetShadowMapMVP", 
      new JSIL.MethodSignature(null, [
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $.Single, $asm09.TypeRef("Fusee.Math.Core.float4x4")
        ]), 
      DeferredShaderHelper_SetShadowMapMVP
    );

    $.Field({Static:true , Public:true }, "CurrentRenderPass", $.Int32);

    $.Field({Static:true , Public:true }, "ShadowPassShaderEffect", $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), null);

    $.Field({Static:true , Public:true }, "GBufferPassShaderEffect", $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), null);

    $.Field({Static:true , Public:true }, "GBufferDrawPassShaderEffect", $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), null);

    $.Field({Static:true , Public:true }, "EnvMapPassShaderEffect", $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), null);

    $.Field({Static:true , Public:true }, "ShadowTexture", $asm03.TypeRef("Fusee.Engine.Common.ITexture"), null);

    $.Field({Static:true , Public:true }, "GBufferTexture", $asm03.TypeRef("Fusee.Engine.Common.ITexture"), null);

    $.Field({Static:true , Public:true }, "EnvMapTexture", $asm03.TypeRef("Fusee.Engine.Common.ITexture"), null);

    $.Field({Static:true , Public:true }, "EnvMapTextureOrientation", $.Int32, 0);

    $.Field({Static:true , Public:true }, "Quad", $asm04.TypeRef("Fusee.Engine.Core.Mesh"));

    $.Field({Static:true , Public:true }, "Maxlights", $.Int32, 1);

    $.Field({Static:true , Public:false}, "DeferredShaderHelper$ShadowMapMVP$value", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:true , Public:true }, "EnvMapVertexShader", $.String, "\r\n                attribute vec3 fuVertex;\r\n                attribute vec3 fuNormal;\r\n                attribute vec2 fuUV;\r\n\r\n                uniform mat4 FUSEE_MVP;\r\n                uniform mat4 FUSEE_ITMV;\r\n                uniform mat4 FUSEE_MV;\r\n                uniform mat4 FUSEE_IMV;\r\n                uniform mat4 FUSEE_M;\r\n\r\n                varying vec3 normal;\r\n                \r\n                uniform mat4 ViewMatrix;\r\n\r\n\r\n                void main()\r\n                {\r\n                    normal =  normalize(mat3(FUSEE_ITMV) * fuNormal);\r\n\t                gl_Position = ViewMatrix * vec4(fuVertex, 1.0);\r\n                }");

    $.Field({Static:true , Public:true }, "EnvMapPixelShader", $.String, "\r\n                #ifdef GL_ES\r\n                    precision highp float\r\n                #endif      \r\n                   \r\n                uniform vec3 DiffuseColor;\r\n                varying vec3 normal;\r\n\r\n                vec3 diffuseLighting(vec3 N, vec3 L)\r\n                {\r\n                   // calculation as for Lambertian reflection\r\n                   float diffuseTerm = clamp(dot(N, L), 0.0, 1.0) ;\r\n                  return (DiffuseColor * diffuseTerm);\r\n                }\r\n\r\n                void main() {\r\n                    vec3 diff = diffuseLighting(normal, vec3(0.0,0.0,-1.0));\r\n                    gl_FragColor = vec4(diff, 1.0);\r\n                }");


    function DeferredShaderHelper__cctor () {
      $thisType.DeferredShaderHelper$ShadowMapMVP$value = new $asm09.Fusee.Math.Core.float4x4();
      $thisType.ShadowPassShaderEffect = null;
      $thisType.GBufferPassShaderEffect = null;
      $thisType.GBufferDrawPassShaderEffect = null;
      $thisType.EnvMapPassShaderEffect = null;
      $thisType.ShadowTexture = null;
      $thisType.GBufferTexture = null;
      $thisType.EnvMapTexture = null;
      $thisType.EnvMapTextureOrientation = 0;
      $thisType.Quad = new ($T00())();
      $thisType.Maxlights = 1;
      $thisType.DeferredShaderHelper$ShadowMapMVP$value = $T01().Identity.MemberwiseClone();
      $thisType.EnvMapVertexShader = "\r\n                attribute vec3 fuVertex;\r\n                attribute vec3 fuNormal;\r\n                attribute vec2 fuUV;\r\n\r\n                uniform mat4 FUSEE_MVP;\r\n                uniform mat4 FUSEE_ITMV;\r\n                uniform mat4 FUSEE_MV;\r\n                uniform mat4 FUSEE_IMV;\r\n                uniform mat4 FUSEE_M;\r\n\r\n                varying vec3 normal;\r\n                \r\n                uniform mat4 ViewMatrix;\r\n\r\n\r\n                void main()\r\n                {\r\n                    normal =  normalize(mat3(FUSEE_ITMV) * fuNormal);\r\n\t                gl_Position = ViewMatrix * vec4(fuVertex, 1.0);\r\n                }";
      $thisType.EnvMapPixelShader = "\r\n                #ifdef GL_ES\r\n                    precision highp float\r\n                #endif      \r\n                   \r\n                uniform vec3 DiffuseColor;\r\n                varying vec3 normal;\r\n\r\n                vec3 diffuseLighting(vec3 N, vec3 L)\r\n                {\r\n                   // calculation as for Lambertian reflection\r\n                   float diffuseTerm = clamp(dot(N, L), 0.0, 1.0) ;\r\n                  return (DiffuseColor * diffuseTerm);\r\n                }\r\n\r\n                void main() {\r\n                    vec3 diff = diffuseLighting(normal, vec3(0.0,0.0,-1.0));\r\n                    gl_FragColor = vec4(diff, 1.0);\r\n                }";
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      DeferredShaderHelper__cctor
    );

    $.Property({Static:true , Public:true }, "ShadowMapMVP", $asm09.TypeRef("Fusee.Math.Core.float4x4"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.FullscreenQuad */ 

(function FullscreenQuad$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.UInt16)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float3, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };


  function FullscreenQuad__ctor () {
    $T00().prototype._ctor.call(this);
    this.set_Vertices(JSIL.Array.New($T01(), [$S00().Construct(-1, -1, 0), $S00().Construct(1, -1, 0), $S00().Construct(1, 1, 0), $S00().Construct(-1, 1, 0)]));
    this.set_Normals(JSIL.Array.New($T01(), [$S00().Construct(-1, 0, 0), $S00().Construct(0, -1, 0), $S00().Construct(0, 0, -1), $S00().Construct(-1, 0, 0), $S00().Construct(0, 1, 0), $S00().Construct(0, 0, -1), $S00().Construct(1, 0, 0), $S00().Construct(0, -1, 0), $S00().Construct(0, 0, -1), $S00().Construct(1, 0, 0), $S00().Construct(0, 1, 0), $S00().Construct(0, 0, -1)]));
    this.set_Triangles(JSIL.Array.New($T02(), [0, 1, 2, 2, 3, 0]));
    this.set_UVs(JSIL.Array.New($T03(), [$S01().Construct(0, 0), $S01().Construct(1, 0), $S01().Construct(1, 1), $S01().Construct(0, 1)]));
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.Mesh"), 
      Name: "Fusee.Engine.Core.FullscreenQuad", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      FullscreenQuad__ctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.DynamicWorld */ 

(function DynamicWorld$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IBoxShapeImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.BoxShape)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICapsuleShapeImp)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm04.Fusee.Engine.Core.CapsuleShape)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICompoundShapeImp)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm04.Fusee.Engine.Core.CompoundShape)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeShapeImp)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm04.Fusee.Engine.Core.ConeShape)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm04.Fusee.Engine.Core.RigidBody)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeTwistConstraintImp)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm04.Fusee.Engine.Core.ConeTwistConstraint)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConvexHullShapeImp)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm04.Fusee.Engine.Core.ConvexHullShape)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICylinderShapeImp)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm04.Fusee.Engine.Core.CylinderShape)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm03.Fusee.Engine.Common.IEmptyShapeImp)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm04.Fusee.Engine.Core.EmptyShape)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGearConstraintImp)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm04.Fusee.Engine.Core.GearConstraint)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm04.Fusee.Engine.Core.Generic6DofConstraint)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize(System.Array.Of($asm0E.System.Int32))) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt16))) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm0E.System.Convert)) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGImpactMeshShapeImp)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm04.Fusee.Engine.Core.GImpactMeshShape)) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp)) ();
  };
  var $T25 = function () {
    return ($T25 = JSIL.Memoize($asm04.Fusee.Engine.Core.HingeConstraint)) ();
  };
  var $T26 = function () {
    return ($T26 = JSIL.Memoize(System.Array.Of($asm0E.System.Single))) ();
  };
  var $T27 = function () {
    return ($T27 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMultiSphereShapeImp)) ();
  };
  var $T28 = function () {
    return ($T28 = JSIL.Memoize($asm04.Fusee.Engine.Core.MultiSphereShape)) ();
  };
  var $T29 = function () {
    return ($T29 = JSIL.Memoize($asm03.Fusee.Engine.Common.IPoint2PointConstraintImp)) ();
  };
  var $T2A = function () {
    return ($T2A = JSIL.Memoize($asm04.Fusee.Engine.Core.Point2PointConstraint)) ();
  };
  var $T2B = function () {
    return ($T2B = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T2C = function () {
    return ($T2C = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T2D = function () {
    return ($T2D = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T2E = function () {
    return ($T2E = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T2F = function () {
    return ($T2F = JSIL.Memoize($asm04.$lPrivateImplementationDetails$g)) ();
  };
  var $T30 = function () {
    return ($T30 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp)) ();
  };
  var $T31 = function () {
    return ($T31 = JSIL.Memoize($asm04.Fusee.Engine.Core.StaticPlaneShape)) ();
  };
  var $T32 = function () {
    return ($T32 = JSIL.Memoize($asm04.Fusee.Engine.Core.SphereShape)) ();
  };
  var $T33 = function () {
    return ($T33 = JSIL.Memoize($asm11.System.Diagnostics.Debug)) ();
  };
  var $T34 = function () {
    return ($T34 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp)) ();
  };
  var $T35 = function () {
    return ($T35 = JSIL.Memoize($asm04.Fusee.Engine.Core.SliderConstraint)) ();
  };
  var $T36 = function () {
    return ($T36 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISphereShapeImp)) ();
  };
  var $T37 = function () {
    return ($T37 = JSIL.Memoize($asm03.Fusee.Engine.Common.IStaticPlaneShapeImp)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IBoxShapeImp, [$asm0E.System.Single]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IBoxShapeImp, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IBoxShapeImp, [$asm09.Fusee.Math.Core.float3]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IConeTwistConstraintImp, [$asm03.Fusee.Engine.Common.IRigidBodyImp, $asm09.Fusee.Math.Core.float4x4]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IConeTwistConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm03.Fusee.Engine.Common.IRigidBodyImp, 
        $asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.IConvexHullShapeImp")))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IConvexHullShapeImp, [System.Array.Of($asm09.Fusee.Math.Core.float3), $asm0E.System.Boolean]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.ICylinderShapeImp, [$asm0E.System.Single]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.ICylinderShapeImp, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.ICylinderShapeImp, [$asm09.Fusee.Math.Core.float3]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm09.Fusee.Math.Core.float4x4, 
        $asm0E.System.Boolean
      ]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm03.Fusee.Engine.Common.IRigidBodyImp, 
        $asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4, 
        $asm0E.System.Boolean
      ]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Int32, [$asm0E.System.UInt16]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IHingeConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm09.Fusee.Math.Core.float4x4, 
        $asm0E.System.Boolean
      ]))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IHingeConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm09.Fusee.Math.Core.float3, 
        $asm09.Fusee.Math.Core.float3, $asm0E.System.Boolean
      ]))) ();
  };
  var $S0F = function () {
    return ($S0F = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IHingeConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm03.Fusee.Engine.Common.IRigidBodyImp, 
        $asm09.Fusee.Math.Core.float3, $asm09.Fusee.Math.Core.float3, 
        $asm09.Fusee.Math.Core.float3, $asm09.Fusee.Math.Core.float3, 
        $asm0E.System.Boolean
      ]))) ();
  };
  var $S10 = function () {
    return ($S10 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IHingeConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm03.Fusee.Engine.Common.IRigidBodyImp, 
        $asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4, 
        $asm0E.System.Boolean
      ]))) ();
  };
  var $S11 = function () {
    return ($S11 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IPoint2PointConstraintImp, [$asm03.Fusee.Engine.Common.IRigidBodyImp, $asm09.Fusee.Math.Core.float3]))) ();
  };
  var $S12 = function () {
    return ($S12 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.IPoint2PointConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm03.Fusee.Engine.Common.IRigidBodyImp, 
        $asm09.Fusee.Math.Core.float3, $asm09.Fusee.Math.Core.float3
      ]))) ();
  };
  var $S13 = function () {
    return ($S13 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0E.TypeRef("System.String")))) ();
  };
  var $S14 = function () {
    return ($S14 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.ISliderConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm03.Fusee.Engine.Common.IRigidBodyImp, 
        $asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4, 
        $asm0E.System.Boolean
      ]))) ();
  };
  var $S15 = function () {
    return ($S15 = JSIL.Memoize(new JSIL.MethodSignature($asm03.Fusee.Engine.Common.ISliderConstraintImp, [
        $asm03.Fusee.Engine.Common.IRigidBodyImp, $asm09.Fusee.Math.Core.float4x4, 
        $asm0E.System.Boolean
      ]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddBoxShape)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_UserObject)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddCapsuleShape)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddCompoundShape)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddConeShape)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddConeTwistConstraint)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.set_UserObject)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddConvexHullShape)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddCylinderShape)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddEmptyShape)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddGearConstraint)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddGeneric6DofConstraint)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddGImpactMeshShape)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddHingeConstraint)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddMultiSphereShape)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddPoint2PointConstraint)) ();
  };
  var $IM10 = function () {
    return ($IM10 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddRigidBody)) ();
  };
  var $IM11 = function () {
    return ($IM11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.set_UserObject)) ();
  };
  var $IM12 = function () {
    return ($IM12 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddSliderConstraint)) ();
  };
  var $IM13 = function () {
    return ($IM13 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddSphereShape)) ();
  };
  var $IM14 = function () {
    return ($IM14 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.AddStaticPlaneShape)) ();
  };
  var $IM15 = function () {
    return ($IM15 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.Dispose)) ();
  };
  var $IM16 = function () {
    return ($IM16 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.get_Gravity)) ();
  };
  var $IM17 = function () {
    return ($IM17 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.GetRigidBody)) ();
  };
  var $IM18 = function () {
    return ($IM18 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_UserObject)) ();
  };
  var $IM19 = function () {
    return ($IM19 = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.NumberConstraints)) ();
  };
  var $IM1A = function () {
    return ($IM1A = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.NumberRigidBodies)) ();
  };
  var $IM1B = function () {
    return ($IM1B = JSIL.Memoize($asm03.Fusee.Engine.Common.IDynamicWorldImp.StepSimulation)) ();
  };


  function DynamicWorld__ctor (dynamicWorld) {
    this._dwi = dynamicWorld;
  }; 

  function DynamicWorld_AddBoxShape$00 (boxHalfExtents) {
    var iBoxShapeImp = $S00().CallVirtual($IM00(), null, this._dwi, boxHalfExtents);
    var retval = new ($T03())();
    retval._boxShapeImp = iBoxShapeImp;
    $IM01().Call(iBoxShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddBoxShape$01 (boxHalfExtentsX, boxHalfExtentsY, boxHalfExtentsZ) {
    var iBoxShapeImp = $S01().CallVirtual($IM00(), null, this._dwi, boxHalfExtentsX, boxHalfExtentsY, boxHalfExtentsZ);
    var retval = new ($T03())();
    retval._boxShapeImp = iBoxShapeImp;
    $IM01().Call(iBoxShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddBoxShape$02 (boxHalfExtents) {
    var iBoxShapeImp = $S02().CallVirtual($IM00(), null, this._dwi, boxHalfExtents.MemberwiseClone());
    var retval = new ($T03())();
    retval._boxShapeImp = iBoxShapeImp;
    $IM01().Call(iBoxShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddCapsuleShape (radius, height) {
    var iCapsuleShapeImp = $IM02().Call(this._dwi, null, radius, height);
    var retval = new ($T07())();
    retval._capsuleShapeImp = iCapsuleShapeImp;
    $IM01().Call(iCapsuleShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddCompoundShape (enableDynamicAabbTree) {
    var iCompoundImp = $IM03().Call(this._dwi, null, enableDynamicAabbTree);
    var retval = new ($T0A())();
    retval._compoundShapeImp = iCompoundImp;
    $IM01().Call(iCompoundImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddConeShape (radius, height) {
    var iConeShapeImp = $IM04().Call(this._dwi, null, radius, height);
    var retval = new ($T0C())();
    retval._coneShapeImp = iConeShapeImp;
    $IM01().Call(iConeShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddConeTwistConstraint$03 (rigidBodyA, rbAFrame) {
    var icti = $S03().CallVirtual($IM05(), null, this._dwi, rigidBodyA._iRigidBodyImp, rbAFrame.MemberwiseClone());
    var retval = new ($T10())();
    retval._iCTConstraintImp = icti;
    $IM06().Call(icti, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddConeTwistConstraint$04 (rigidBodyA, rigidBodyB, rbAFrame, rbBFrame) {
    var icti = $S04().CallVirtual($IM05(), null, this._dwi, rigidBodyA._iRigidBodyImp, rigidBodyB._iRigidBodyImp, rbAFrame.MemberwiseClone(), rbBFrame.MemberwiseClone());
    var retval = new ($T10())();
    retval._iCTConstraintImp = icti;
    $IM06().Call(icti, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddConvexHullShape$05 () {
    var iConvexHullShapeImp = $S05().CallVirtual($IM07(), null, this._dwi);
    var retval = new ($T13())();
    retval._convexHullShapeImp = iConvexHullShapeImp;
    $IM01().Call(iConvexHullShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddConvexHullShape$06 (points, optimized) {
    var iConvexHullShapeImp = $S06().CallVirtual($IM07(), null, this._dwi, points, optimized);
    var retval = new ($T13())();
    retval._convexHullShapeImp = iConvexHullShapeImp;
    $IM01().Call(iConvexHullShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddCylinderShape$07 (halfExtents) {
    var iCylinderShapeImp = $S07().CallVirtual($IM08(), null, this._dwi, halfExtents);
    var retval = new ($T16())();
    retval._cylinderShapeImp = iCylinderShapeImp;
    $IM01().Call(iCylinderShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddCylinderShape$08 (halfExtentsX, halfExtentsY, halfExtentsZ) {
    var iCylinderShapeImp = $S08().CallVirtual($IM08(), null, this._dwi, halfExtentsX, halfExtentsY, halfExtentsZ);
    var retval = new ($T16())();
    retval._cylinderShapeImp = iCylinderShapeImp;
    $IM01().Call(iCylinderShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddCylinderShape$09 (halfExtents) {
    var iCylinderShapeImp = $S09().CallVirtual($IM08(), null, this._dwi, halfExtents.MemberwiseClone());
    var retval = new ($T16())();
    retval._cylinderShapeImp = iCylinderShapeImp;
    $IM01().Call(iCylinderShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddEmptyShape () {
    var iEmptyShapeImp = $IM09().Call(this._dwi, null);
    var retval = new ($T18())();
    retval._emtyShapeImp = iEmptyShapeImp;
    $IM01().Call(iEmptyShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddGearConstraint (rigidBodyA, rigidBodyB, axisInA, axisInB, ratio) {
    var igci = $IM0A().Call(this._dwi, null, 
      rigidBodyA._iRigidBodyImp, 
      rigidBodyB._iRigidBodyImp, 
      axisInA.MemberwiseClone(), 
      axisInB.MemberwiseClone(), 
      ratio
    );
    var retval = new ($T1A())();
    retval._iGearConstraintImp = igci;
    $IM06().Call(igci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddGeneric6DofConstraint$0A (rigidBodyA, frameInA, useReferenceFrameA) {
    var ig6dofci = $S0A().CallVirtual($IM0B(), null, this._dwi, rigidBodyA._iRigidBodyImp, frameInA.MemberwiseClone(), useReferenceFrameA);
    var retval = new ($T1C())();
    retval._IG6DofConstraintImp = ig6dofci;
    $IM06().Call(ig6dofci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddGeneric6DofConstraint$0B (rigidBodyA, rigidBodyB, frameInA, frameInB, useReferenceFrameA) {
    var ig6dofci = $S0B().CallVirtual($IM0B(), null, this._dwi, 
      rigidBodyA._iRigidBodyImp, 
      rigidBodyB._iRigidBodyImp, 
      frameInA.MemberwiseClone(), 
      frameInB.MemberwiseClone(), 
      useReferenceFrameA
    );
    var retval = new ($T1C())();
    retval._IG6DofConstraintImp = ig6dofci;
    $IM06().Call(ig6dofci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddGImpactMeshShape (mesh) {
    var meshTrianglesArray = JSIL.Array.New($T1F(), mesh.get_Triangles().length);

    for (var c = 0; c < (mesh.get_Triangles().length | 0); c = ((c + 1) | 0)) {
      meshTrianglesArray[c] = ($S0C().CallStatic($T21(), "ToInt32", null, mesh.get_Triangles()[c]) | 0);
    }
    var meshVerteciesCount = (mesh.get_Vertices().length | 0);
    var meshVerteciesArray = JSIL.Array.New($T05(), meshVerteciesCount);
    meshVerteciesArray = mesh.get_Vertices();
    var iGImpactMeshShapeImp = $IM0C().Call(this._dwi, null, meshTrianglesArray, mesh.get_Vertices());
    var retval = new ($T23())();
    retval._gImpactMeshShapeImp = iGImpactMeshShapeImp;
    $IM01().Call(iGImpactMeshShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddHingeConstraint$0C (rigidBodyA, frameInA, useReferenceFrameA) {
    var ip2pci = $S0D().CallVirtual($IM0D(), null, this._dwi, rigidBodyA._iRigidBodyImp, frameInA.MemberwiseClone(), useReferenceFrameA);
    var retval = new ($T25())();
    retval._iHConstraintImp = ip2pci;
    $IM06().Call(ip2pci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddHingeConstraint$0D (rigidBodyA, pivotInA, axisInA, useReferenceFrameA) {
    var ip2pci = $S0E().CallVirtual($IM0D(), null, this._dwi, rigidBodyA._iRigidBodyImp, pivotInA.MemberwiseClone(), axisInA.MemberwiseClone(), useReferenceFrameA);
    var retval = new ($T25())();
    retval._iHConstraintImp = ip2pci;
    $IM06().Call(ip2pci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddHingeConstraint$0E (rigidBodyA, rigidBodyB, pivotInA, pivotInB, axisInA, axisInB, useReferenceFrameA) {
    var ip2pci = $S0F().CallVirtual($IM0D(), null, this._dwi, 
      rigidBodyA._iRigidBodyImp, 
      rigidBodyB._iRigidBodyImp, 
      pivotInA.MemberwiseClone(), 
      pivotInB.MemberwiseClone(), 
      axisInA.MemberwiseClone(), 
      axisInB.MemberwiseClone(), 
      useReferenceFrameA
    );
    var retval = new ($T25())();
    retval._iHConstraintImp = ip2pci;
    $IM06().Call(ip2pci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddHingeConstraint$0F (rigidBodyA, rigidBodyB, brAFrame, brBFrame, useReferenceFrameA) {
    var ip2pci = $S10().CallVirtual($IM0D(), null, this._dwi, 
      rigidBodyA._iRigidBodyImp, 
      rigidBodyB._iRigidBodyImp, 
      brAFrame.MemberwiseClone(), 
      brBFrame.MemberwiseClone(), 
      useReferenceFrameA
    );
    var retval = new ($T25())();
    retval._iHConstraintImp = ip2pci;
    $IM06().Call(ip2pci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddMultiSphereShape (positions, radi) {
    var iMultiSphereShapeImp = $IM0E().Call(this._dwi, null, positions, radi);
    var retval = new ($T28())();
    retval._multiSphereShapeImp = iMultiSphereShapeImp;
    $IM01().Call(iMultiSphereShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddPoint2PointConstraint$10 (rigidBodyA, pivotInA) {
    var ip2pci = $S11().CallVirtual($IM0F(), null, this._dwi, rigidBodyA._iRigidBodyImp, pivotInA.MemberwiseClone());
    var retval = new ($T2A())();
    retval._iP2PConstraintImp = ip2pci;
    $IM06().Call(ip2pci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddPoint2PointConstraint$11 (rigidBodyA, rigidBodyB, pivotInA, pivotInB) {
    var ip2pci = $S12().CallVirtual($IM0F(), null, this._dwi, rigidBodyA._iRigidBodyImp, rigidBodyB._iRigidBodyImp, pivotInA.MemberwiseClone(), pivotInB.MemberwiseClone());
    var retval = new ($T2A())();
    retval._iP2PConstraintImp = ip2pci;
    $IM06().Call(ip2pci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddRigidBody (mass, position, orientation, colShape) {

    var $label0 = 0;
  $labelgroup0: 
    while (true) {
      switch ($label0) {
        case 0: /* $entry0 */ 
          var shapeType = (JSIL.GetType(colShape)).toString();
          var text = shapeType;
          var num = ($T2F().ComputeStringHash(text) >>> 0);
          if (num <= 1844105875) {
            if (num <= 1319428916) {
              if (num !== 505077084) {
                if (num === 1319428916) {
                  if (text == "Fusee.Engine.MultiSphereShape") {
                    var multiSphere = $T28().$Cast(colShape);
                    var rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), multiSphere._multiSphereShapeImp);
                    break $labelgroup0;
                  }
                }
              } else if (text == "Fusee.Engine.CylinderShape") {
                var cylinder = $T16().$Cast(colShape);
                rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), cylinder._cylinderShapeImp);
                break $labelgroup0;
              }
            } else if (num !== 1574939861) {
              if (num !== 1681802816) {
                if (num === 1844105875) {
                  if (text == "Fusee.Engine.BoxShape") {
                    var box = $T03().$Cast(colShape);
                    rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), box._boxShapeImp);
                    break $labelgroup0;
                  }
                }
              } else if (text == "Fusee.Engine.StaticPlaneShape") {
                var staticPaneShape = $T31().$Cast(colShape);
                rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), staticPaneShape._staticPlaneShapeImp);
                break $labelgroup0;
              }
            } else if (text == "Fusee.Engine.CompoundShape") {
              var compShape = $T0A().$Cast(colShape);
              rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), compShape._compoundShapeImp);
              break $labelgroup0;
            }
          } else if (num <= 2828003299) {
            if (num !== 2569625669) {
              if (num !== 2615718639) {
                if (num === 2828003299) {
                  if (text == "Fusee.Engine.ConeShape") {
                    var cone = $T0C().$Cast(colShape);
                    rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), cone._coneShapeImp);
                    break $labelgroup0;
                  }
                }
              } else if (text == "Fusee.Engine.EmptyShape") {
                var empty = $T18().$Cast(colShape);
                rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), empty._emtyShapeImp);
                break $labelgroup0;
              }
            } else if (text == "Fusee.Engine.CapsuleShape") {
              var capsule = $T07().$Cast(colShape);
              rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), capsule._capsuleShapeImp);
              break $labelgroup0;
            }
          } else if (num !== 3405169718) {
            if (num !== 3680950897) {
              if (num === 4129887654) {
                if (text == "Fusee.Engine.GImpactMeshShape") {
                  var gImpMeshShape = $T23().$Cast(colShape);
                  rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), gImpMeshShape._gImpactMeshShapeImp);
                  break $labelgroup0;
                }
              }
            } else if (text == "Fusee.Engine.SphereShape") {
              var sphere = $T32().$Cast(colShape);
              rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), sphere._sphereShapeImp);
              break $labelgroup0;
            }
          } else if (text == "Fusee.Engine.ConvexHullShape") {
            var convHullShape = $T13().$Cast(colShape);
            rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), convHullShape._convexHullShapeImp);
            break $labelgroup0;
          }
          var defaultShape = new ($T18())();
          $S13().CallStatic($T33(), "WriteLine", null, "default");
          rbi = $IM10().Call(this._dwi, null, mass, position.MemberwiseClone(), orientation.MemberwiseClone(), defaultShape._emtyShapeImp);
          break $labelgroup0;

      }
    }
    /* Original label IL_361 */ 
    var retval = new ($T0D())();
    retval._iRigidBodyImp = rbi;
    $IM11().Call(rbi, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddSliderConstraint$12 (rigidBodyA, rigidBodyB, frameInA, frameInB, useLinearReferenceFrameA) {
    var isci = $S14().CallVirtual($IM12(), null, this._dwi, 
      rigidBodyA._iRigidBodyImp, 
      rigidBodyB._iRigidBodyImp, 
      frameInA.MemberwiseClone(), 
      frameInB.MemberwiseClone(), 
      useLinearReferenceFrameA
    );
    var retval = new ($T35())();
    retval._iSliderConstraintImp = isci;
    $IM06().Call(isci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddSliderConstraint$13 (rigidBodyA, frameInA, useLinearReferenceFrameA) {
    var isci = $S15().CallVirtual($IM12(), null, this._dwi, rigidBodyA._iRigidBodyImp, frameInA.MemberwiseClone(), useLinearReferenceFrameA);
    var retval = new ($T35())();
    retval._iSliderConstraintImp = isci;
    $IM06().Call(isci, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddSphereShape (radius) {
    var iSphereShapeImp = $IM13().Call(this._dwi, null, radius);
    var retval = new ($T32())();
    retval._sphereShapeImp = iSphereShapeImp;
    $IM01().Call(iSphereShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_AddStaticPlaneShape (planeNormal, planeConstant) {
    var iStaticPlaneShapeImp = $IM14().Call(this._dwi, null, planeNormal.MemberwiseClone(), planeConstant);
    var retval = new ($T31())();
    retval._staticPlaneShapeImp = iStaticPlaneShapeImp;
    $IM01().Call(iStaticPlaneShapeImp, null, retval);
    return retval;
  }; 

  function DynamicWorld_Dispose () {
    $IM15().Call(this._dwi, null);
  }; 

  function DynamicWorld_get_Gravity () {
    return $IM16().Call(this._dwi, null);
  }; 

  function DynamicWorld_GetRigidBody (i) {
    var rbi = $IM17().Call(this._dwi, null, i);
    return $T0D().$Cast($IM18().Call(rbi, null));
  }; 

  function DynamicWorld_NumberConstraints () {
    return $IM19().Call(this._dwi, null);
  }; 

  function DynamicWorld_NumberRigidBodies () {
    return $IM1A().Call(this._dwi, null);
  }; 

  function DynamicWorld_set_Gravity (value) {
    (this._dwi.Gravity = value.MemberwiseClone());
  }; 

  function DynamicWorld_StepSimulation (timeSteps, maxSubSteps, fixedTimeSteps) {
    return $IM1B().Call(this._dwi, null, timeSteps, maxSubSteps, fixedTimeSteps);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.DynamicWorld", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IDynamicWorldImp")), 
      DynamicWorld__ctor
    )
      .Parameter(0, "dynamicWorld", function (_) {
          _.Attribute($asm00.TypeRef("Fusee.Base.Common.InjectMeAttribute"))
        });

    $.Method({Static:false, Public:true }, "AddBoxShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.BoxShape"), [$.Single]), 
      DynamicWorld_AddBoxShape$00
    );

    $.Method({Static:false, Public:true }, "AddBoxShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.BoxShape"), [
          $.Single, $.Single, 
          $.Single
        ]), 
      DynamicWorld_AddBoxShape$01
    );

    $.Method({Static:false, Public:true }, "AddBoxShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.BoxShape"), [$asm09.TypeRef("Fusee.Math.Core.float3")]), 
      DynamicWorld_AddBoxShape$02
    );

    $.Method({Static:false, Public:true }, "AddCapsuleShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.CapsuleShape"), [$.Single, $.Single]), 
      DynamicWorld_AddCapsuleShape
    );

    $.Method({Static:false, Public:true }, "AddCompoundShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.CompoundShape"), [$.Boolean]), 
      DynamicWorld_AddCompoundShape
    );

    $.Method({Static:false, Public:true }, "AddConeShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ConeShape"), [$.Single, $.Single]), 
      DynamicWorld_AddConeShape
    );

    $.Method({Static:false, Public:true }, "AddConeTwistConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ConeTwistConstraint"), [$asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm09.TypeRef("Fusee.Math.Core.float4x4")]), 
      DynamicWorld_AddConeTwistConstraint$03
    );

    $.Method({Static:false, Public:true }, "AddConeTwistConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ConeTwistConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), 
          $asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4")
        ]), 
      DynamicWorld_AddConeTwistConstraint$04
    );

    $.Method({Static:false, Public:true }, "AddConvexHullShape", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.ConvexHullShape")), 
      DynamicWorld_AddConvexHullShape$05
    );

    $.Method({Static:false, Public:true }, "AddConvexHullShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ConvexHullShape"), [$jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]), $.Boolean]), 
      DynamicWorld_AddConvexHullShape$06
    );

    $.Method({Static:false, Public:true }, "AddCylinderShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.CylinderShape"), [$.Single]), 
      DynamicWorld_AddCylinderShape$07
    );

    $.Method({Static:false, Public:true }, "AddCylinderShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.CylinderShape"), [
          $.Single, $.Single, 
          $.Single
        ]), 
      DynamicWorld_AddCylinderShape$08
    );

    $.Method({Static:false, Public:true }, "AddCylinderShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.CylinderShape"), [$asm09.TypeRef("Fusee.Math.Core.float3")]), 
      DynamicWorld_AddCylinderShape$09
    );

    $.Method({Static:false, Public:true }, "AddEmptyShape", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.EmptyShape")), 
      DynamicWorld_AddEmptyShape
    );

    $.Method({Static:false, Public:true }, "AddGearConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.GearConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), 
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $.Single
        ]), 
      DynamicWorld_AddGearConstraint
    );

    $.Method({Static:false, Public:true }, "AddGeneric6DofConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.Generic6DofConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm09.TypeRef("Fusee.Math.Core.float4x4"), 
          $.Boolean
        ]), 
      DynamicWorld_AddGeneric6DofConstraint$0A
    );

    $.Method({Static:false, Public:true }, "AddGeneric6DofConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.Generic6DofConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), 
          $asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4"), 
          $.Boolean
        ]), 
      DynamicWorld_AddGeneric6DofConstraint$0B
    );

    $.Method({Static:false, Public:true }, "AddGImpactMeshShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.GImpactMeshShape"), [$asm04.TypeRef("Fusee.Engine.Core.Mesh")]), 
      DynamicWorld_AddGImpactMeshShape
    );

    $.Method({Static:false, Public:true }, "AddHingeConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.HingeConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm09.TypeRef("Fusee.Math.Core.float4x4"), 
          $.Boolean
        ]), 
      DynamicWorld_AddHingeConstraint$0C
    );

    $.Method({Static:false, Public:true }, "AddHingeConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.HingeConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $asm09.TypeRef("Fusee.Math.Core.float3"), $.Boolean
        ]), 
      DynamicWorld_AddHingeConstraint$0D
    );

    $.Method({Static:false, Public:true }, "AddHingeConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.HingeConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), 
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $.Boolean
        ]), 
      DynamicWorld_AddHingeConstraint$0E
    );

    $.Method({Static:false, Public:true }, "AddHingeConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.HingeConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), 
          $asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4"), 
          $.Boolean
        ]), 
      DynamicWorld_AddHingeConstraint$0F
    );

    $.Method({Static:false, Public:true }, "AddMultiSphereShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.MultiSphereShape"), [$jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]), $jsilcore.TypeRef("System.Array", [$.Single])]), 
      DynamicWorld_AddMultiSphereShape
    );

    $.Method({Static:false, Public:true }, "AddPoint2PointConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.Point2PointConstraint"), [$asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm09.TypeRef("Fusee.Math.Core.float3")]), 
      DynamicWorld_AddPoint2PointConstraint$10
    );

    $.Method({Static:false, Public:true }, "AddPoint2PointConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.Point2PointConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), 
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3")
        ]), 
      DynamicWorld_AddPoint2PointConstraint$11
    );

    $.Method({Static:false, Public:true }, "AddRigidBody", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.RigidBody"), [
          $.Single, $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm04.TypeRef("Fusee.Engine.Core.CollisionShape")
        ]), 
      DynamicWorld_AddRigidBody
    );

    $.Method({Static:false, Public:true }, "AddSliderConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.SliderConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), 
          $asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4"), 
          $.Boolean
        ]), 
      DynamicWorld_AddSliderConstraint$12
    );

    $.Method({Static:false, Public:true }, "AddSliderConstraint", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.SliderConstraint"), [
          $asm04.TypeRef("Fusee.Engine.Core.RigidBody"), $asm09.TypeRef("Fusee.Math.Core.float4x4"), 
          $.Boolean
        ]), 
      DynamicWorld_AddSliderConstraint$13
    );

    $.Method({Static:false, Public:true }, "AddSphereShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.SphereShape"), [$.Single]), 
      DynamicWorld_AddSphereShape
    );

    $.Method({Static:false, Public:true }, "AddStaticPlaneShape", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.StaticPlaneShape"), [$asm09.TypeRef("Fusee.Math.Core.float3"), $.Single]), 
      DynamicWorld_AddStaticPlaneShape
    );

    $.Method({Static:false, Public:true }, "Dispose", 
      JSIL.MethodSignature.Void, 
      DynamicWorld_Dispose
    );

    $.Method({Static:false, Public:true }, "get_Gravity", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      DynamicWorld_get_Gravity
    );

    $.Method({Static:false, Public:true }, "GetRigidBody", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.RigidBody"), [$.Int32]), 
      DynamicWorld_GetRigidBody
    );

    $.Method({Static:false, Public:true }, "NumberConstraints", 
      JSIL.MethodSignature.Return($.Int32), 
      DynamicWorld_NumberConstraints
    );

    $.Method({Static:false, Public:true }, "NumberRigidBodies", 
      JSIL.MethodSignature.Return($.Int32), 
      DynamicWorld_NumberRigidBodies
    );

    $.Method({Static:false, Public:true }, "set_Gravity", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      DynamicWorld_set_Gravity
    );

    $.Method({Static:false, Public:true }, "StepSimulation", 
      new JSIL.MethodSignature($.Int32, [
          $.Single, $.Int32, 
          $.Single
        ]), 
      DynamicWorld_StepSimulation
    );

    $.Field({Static:false, Public:false}, "_dwi", $asm03.TypeRef("Fusee.Engine.Common.IDynamicWorldImp"));

    $.Property({Static:false, Public:true }, "Gravity", $asm09.TypeRef("Fusee.Math.Core.float3"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.EmptyShape */ 

(function EmptyShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.BoxShape)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function EmptyShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function EmptyShape_get_Margin () {
    return $IM00().Call(this._emtyShapeImp, null);
  }; 

  function EmptyShape_set_Margin (value) {
    var o = $T03().$Cast($IM01().Call(this._emtyShapeImp, null));
    $IM02().Call(o._boxShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.EmptyShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      EmptyShape__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      EmptyShape_get_Margin
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      EmptyShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_emtyShapeImp", $asm03.TypeRef("Fusee.Engine.Common.IEmptyShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Engine.Core.GlyphOnMap */ 

(function GlyphOnMap$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.ValueType"), 
      Name: "Fusee.Engine.Core.GlyphOnMap", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "BitmapW", $.Single);

    $.Field({Static:false, Public:true }, "BitmapH", $.Single);

    $.Field({Static:false, Public:true }, "BitmapL", $.Single);

    $.Field({Static:false, Public:true }, "BitmapT", $.Single);

    $.Field({Static:false, Public:true }, "TexOffX", $.Single);

    $.Field({Static:false, Public:true }, "TexOffY", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.FontMap */ 

(function FontMap$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm01.Fusee.Base.Core.Font)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.ArgumentNullException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.ArgumentOutOfRangeException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.UInt32, $asm04.Fusee.Engine.Core.GlyphOnMap))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm00.Fusee.Base.Common.ImageData)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.Char)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm00.Fusee.Base.Common.GlyphInfo)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.Math)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm00.Fusee.Base.Common.ImagePixelFormat)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.Byte)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm04.Fusee.Engine.Core.GlyphOnMap)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0E.System.Text.StringBuilder)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentNullException, [$asm0E.System.String]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentOutOfRangeException, [$asm0E.System.String]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.UInt32, $asm04.Fusee.Engine.Core.GlyphOnMap), null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Text.StringBuilder, [$asm0E.System.Int32]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Text.StringBuilder, [$asm0E.System.Char]))) ();
  };


  function FontMap__ctor (font, pixelHeight, alphabet) {
    if (font === null) {
      throw $S00().Construct("font");
    }
    if ((pixelHeight >>> 0) <= 0) {
      throw $S01().Construct("pixelHeight");
    }
    this._font = font;
    this._pixelHeight = (pixelHeight >>> 0);
    this._glyphOnMapCache = $S02().Construct();
    this.set_Alphabet(alphabet);
  }; 

  function FontMap_FixTextKerning (vertices, text, scaleX) {
    var $temp00, $temp01, $temp02, $temp03;
    var flag = !(this.get_Font()).get_UseKerning();
    if (flag) {
      var result = vertices;
    } else {
      var fixX = 0;
      var fixVert = 4;

      for (var c = 0; c < (((text.length | 0) - 1) | 0); c = ((c + 1) | 0)) {
        fixX += +((((this.get_Font()).GetKerning(
              (text[c]).charCodeAt(0), 
              (text[((c + 1) | 0)]).charCodeAt(0)
            )) | 0)) * +scaleX;
        var expr_51 = (($temp00 = fixVert, 
          fixVert = ((fixVert + 1) | 0), 
          $temp00) | 0);
        vertices[expr_51].x = +vertices[expr_51].x + fixX;
        var expr_66 = (($temp01 = fixVert, 
          fixVert = ((fixVert + 1) | 0), 
          $temp01) | 0);
        vertices[expr_66].x = +vertices[expr_66].x + fixX;
        var expr_7B = (($temp02 = fixVert, 
          fixVert = ((fixVert + 1) | 0), 
          $temp02) | 0);
        vertices[expr_7B].x = +vertices[expr_7B].x + fixX;
        var expr_90 = (($temp03 = fixVert, 
          fixVert = ((fixVert + 1) | 0), 
          $temp03) | 0);
        vertices[expr_90].x = +vertices[expr_90].x + fixX;
      }
      result = vertices;
    }
    return result;
  }; 

  function FontMap_get_Alphabet () {
    return this._alphabet;
  }; 

  function FontMap_get_Font () {
    return this._font;
  }; 

  function FontMap_get_Image () {
    var bitmapLeft = new JSIL.BoxedVariable(0);
    var bitmapTop = new JSIL.BoxedVariable(0);
    var texMapHeight = 0;
    var uptodate = this._uptodate;
    if (uptodate) {
      var image = this._image.MemberwiseClone();
    } else {
      (this._font).set_PixelHeight(this._pixelHeight);
      var rowW = 0;
      var rowH = 0;
      var h = 0;
      var alphabet = this._alphabet;

      for (var j = 0; j < (alphabet.length | 0); j = ((j + 1) | 0)) {
        var c = (alphabet[j]);
        var i = (c.charCodeAt(0) | 0);
        var gi = (this._font).GetGlyphInfo(i).MemberwiseClone();
        var flag = ((((rowW + ((gi.AdvanceX) | 0)) | 0) + 1) | 0) >= 512;
        if (flag) {
          h = ((h + rowH) | 0);
          rowW = 0;
          rowH = 0;
        }
        rowW = ((rowW + ((((gi.AdvanceX) | 0) + 1) | 0)) | 0);
        rowH = ($T0D().Max(((gi.Height) | 0), rowH) | 0);
      }
      var potH = ((((h + rowH) | 0) - 1) | 0);
      potH = potH | (potH >> 1);
      potH = potH | (potH >> 2);
      potH = potH | (potH >> 4);
      potH = potH | (potH >> 8);
      potH = potH | (potH >> 16);
      potH = texMapHeight = ((potH + 1) | 0);
      var image2 = new ($T0A())();
      image2.Width = 512;
      image2.Height = texMapHeight;
      image2.Stride = 512;
      image2.PixelFormat = $T0E().Intensity;
      image2.PixelData = JSIL.Array.New($T0F(), Math.imul(512, texMapHeight));
      this._image = image2.MemberwiseClone();
      var offX = 0;
      var offY = 0;
      rowH = 0;
      var alphabet2 = this._alphabet;

      for (var k = 0; k < (alphabet2.length | 0); k = ((k + 1) | 0)) {
        var c2 = (alphabet2[k]);
        var glyphImg = (this._font).RenderGlyph(c2.charCodeAt(0), /* ref */ bitmapLeft, /* ref */ bitmapTop).MemberwiseClone();
        var flag2 = ((((offX + (glyphImg.Width | 0)) | 0) + 1) | 0) >= 512;
        if (flag2) {
          offY = ((offY + rowH) | 0);
          rowH = 0;
          offX = 0;
        }
        var flag3 = !glyphImg.get_IsEmpty();
        if (flag3) {
          $T0A().Blt(
            this._image.MemberwiseClone(), 
            offX, 
            offY, 
            glyphImg.MemberwiseClone(), 
            0, 
            0, 
            0, 
            0
          );
        }
        var glyphOnMap2 = new ($T10())();
        glyphOnMap2.BitmapW = +(glyphImg.Width);
        glyphOnMap2.BitmapH = +(glyphImg.Height);
        glyphOnMap2.BitmapL = +(bitmapLeft.get());
        glyphOnMap2.BitmapT = +(bitmapTop.get());
        glyphOnMap2.TexOffX = +((+offX / 512));
        glyphOnMap2.TexOffY = +((+offY / +potH));
        var glyphOnMap = glyphOnMap2;
        (this._glyphOnMapCache).set_Item(c2.charCodeAt(0), glyphOnMap.MemberwiseClone());
        rowH = ($T0D().Max(rowH, glyphImg.Height) | 0);
        offX = ((offX + (((glyphImg.Width | 0) + 1) | 0)) | 0);
      }
      this._uptodate = true;
      image = this._image.MemberwiseClone();
    }
    return image;
  }; 

  function FontMap_get_PixelHeight () {
    return this._pixelHeight;
  }; 

  function FontMap_get_Uptodate () {
    return this._uptodate;
  }; 

  function FontMap_GetGlyphOnMap (c) {
    return (this._glyphOnMapCache).get_Item(c);
  }; 

  function FontMap_Invalidate () {
    (this._glyphOnMapCache).Clear();
    this._uptodate = false;
  }; 

  function FontMap_set_Alphabet (value) {
    if (value === null) {
      var sb = $S03().Construct(224);

      for (var i = 32; i < 256; i = ((i + 1) | 0)) {
        $S04().CallVirtual("Append", null, sb, String.fromCharCode(i));
      }
      this._alphabet = sb.toString();
    } else {
      this._alphabet = value;
    }
    this.Invalidate();
  }; 

  function FontMap_set_Font (value) {
    this._font = value;
    this.Invalidate();
  }; 

  function FontMap_set_PixelHeight (value) {
    this._pixelHeight = (value >>> 0);
    this.Invalidate();
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.FontMap", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm01.TypeRef("Fusee.Base.Core.Font"), $.UInt32, 
          $.String
        ]), 
      FontMap__ctor
    );

    $.Method({Static:false, Public:true }, "FixTextKerning", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]), [
          $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]), $.String, 
          $.Single
        ]), 
      FontMap_FixTextKerning
    );

    $.Method({Static:false, Public:true }, "get_Alphabet", 
      JSIL.MethodSignature.Return($.String), 
      FontMap_get_Alphabet
    );

    $.Method({Static:false, Public:true }, "get_Font", 
      JSIL.MethodSignature.Return($asm01.TypeRef("Fusee.Base.Core.Font")), 
      FontMap_get_Font
    );

    $.Method({Static:false, Public:true }, "get_Image", 
      JSIL.MethodSignature.Return($asm00.TypeRef("Fusee.Base.Common.ImageData")), 
      FontMap_get_Image
    );

    $.Method({Static:false, Public:true }, "get_PixelHeight", 
      JSIL.MethodSignature.Return($.UInt32), 
      FontMap_get_PixelHeight
    );

    $.Method({Static:false, Public:true }, "get_Uptodate", 
      JSIL.MethodSignature.Return($.Boolean), 
      FontMap_get_Uptodate
    );

    $.Method({Static:false, Public:true }, "GetGlyphOnMap", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.GlyphOnMap"), [$.UInt32]), 
      FontMap_GetGlyphOnMap
    );

    $.Method({Static:false, Public:false}, "Invalidate", 
      JSIL.MethodSignature.Void, 
      FontMap_Invalidate
    );

    $.Method({Static:false, Public:true }, "set_Alphabet", 
      JSIL.MethodSignature.Action($.String), 
      FontMap_set_Alphabet
    );

    $.Method({Static:false, Public:true }, "set_Font", 
      JSIL.MethodSignature.Action($asm01.TypeRef("Fusee.Base.Core.Font")), 
      FontMap_set_Font
    );

    $.Method({Static:false, Public:true }, "set_PixelHeight", 
      JSIL.MethodSignature.Action($.UInt32), 
      FontMap_set_PixelHeight
    );

    $.Field({Static:false, Public:false}, "_font", $asm01.TypeRef("Fusee.Base.Core.Font"));

    $.Field({Static:false, Public:false}, "_image", $asm00.TypeRef("Fusee.Base.Common.ImageData"));

    $.Field({Static:false, Public:false}, "_pixelHeight", $.UInt32);

    $.Field({Static:false, Public:false}, "_alphabet", $.String);

    $.Field({Static:false, Public:false}, "_uptodate", $.Boolean);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_glyphOnMapCache", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.UInt32, $asm04.TypeRef("Fusee.Engine.Core.GlyphOnMap")]));

    $.Property({Static:false, Public:true }, "Image", $asm00.TypeRef("Fusee.Base.Common.ImageData"));

    $.Property({Static:false, Public:true }, "Font", $asm01.TypeRef("Fusee.Base.Core.Font"));

    $.Property({Static:false, Public:true }, "PixelHeight", $.UInt32);

    $.Property({Static:false, Public:true }, "Alphabet", $.String);

    $.Property({Static:false, Public:true }, "Uptodate", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.NamespaceDoc */ 

(function NamespaceDoc$Members () {
  var $, $thisType;

  JSIL.MakeStaticClass("Fusee.Engine.Core.NamespaceDoc", false, [], function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Engine.Core.MeshProbs */ 

(function MeshProbs$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.ValueType"), 
      Name: "Fusee.Engine.Core.MeshProbs", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "HasVertices", $.Boolean);

    $.Field({Static:false, Public:true }, "HasNormals", $.Boolean);

    $.Field({Static:false, Public:true }, "HasUVs", $.Boolean);

    $.Field({Static:false, Public:true }, "HasColors", $.Boolean);

    $.Field({Static:false, Public:true }, "HasWeightMap", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Engine.Core.MaterialProbs */ 

(function MaterialProbs$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.ValueType"), 
      Name: "Fusee.Engine.Core.MaterialProbs", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "HasDiffuse", $.Boolean);

    $.Field({Static:false, Public:true }, "HasDiffuseTexture", $.Boolean);

    $.Field({Static:false, Public:true }, "HasSpecular", $.Boolean);

    $.Field({Static:false, Public:true }, "HasSpecularTexture", $.Boolean);

    $.Field({Static:false, Public:true }, "HasEmissive", $.Boolean);

    $.Field({Static:false, Public:true }, "HasEmissiveTexture", $.Boolean);

    $.Field({Static:false, Public:true }, "HasBump", $.Boolean);

    $.Field({Static:false, Public:true }, "HasApplyLightString", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum Fusee.Engine.Core.MaterialType */ 

JSIL.MakeEnum(
  {
    FullName: "Fusee.Engine.Core.MaterialType", 
    BaseType: $asm0E.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Material: 0, 
    MaterialLightComponent: 1, 
    MaterialPbrComponent: 2, 
  }
);

/* enum Fusee.Engine.Core.Type */ 

JSIL.MakeEnum(
  {
    FullName: "Fusee.Engine.Core.Type", 
    BaseType: $asm0E.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Mat3: 0, 
    Mat4: 1, 
    Vec2: 2, 
    Vec3: 3, 
    Vec4: 4, 
    Boolean: 5, 
    Float: 6, 
    Int: 7, 
    Sampler2D: 8, 
    Void: 9, 
  }
);

/* class Fusee.Engine.Core.GLSL */ 

(function GLSL$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize(System.Array.Of($asm0E.System.String))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Collections.Generic.IList$b1.Of($asm0E.System.String))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Func$b2.Of($asm0E.System.String, $asm0E.System.String))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0E.System.String))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm04.Fusee.Engine.Core.GLSL_$l$gc)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm14.System.Linq.Enumerable)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.String))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.ArgumentOutOfRangeException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.String, [$asm0E.System.String]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!1"]), [$asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"]), $asm0E.TypeRef("System.Func`2", ["!!0", "!!1"])], ["TSource", "TResult"]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.String), null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentOutOfRangeException, [
        $asm0E.System.String, $asm0E.System.Object, 
        $asm0E.System.String
      ]))) ();
  };


  function GLSL__ctor () {
  }; 

  function GLSL_CreateAttribute (type, varName) {
    return $T01().Format("attribute {0} {1};", JSIL.Array.New($T02(), [$thisType.DecodeType(type), varName]));
  }; 

  function GLSL_CreateMethod (returnType, methodName, methodParams, method) {
    var arg_21_1 = null;
    var arg_21_0 = method;
    if ((arg_21_1 = $T07().$l$g9__4_0) === null) {
      arg_21_1 = $T07().$l$g9__4_0 = $T05().New($T07().$l$g9, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.GLSL_$l$gc, "$lCreateMethod$gb__4_0", $S00(), false, false));
    }
    method = $T08().ToList$b1($T01())($S01().CallStatic($T08(), "Select$b2", [$asm0E.System.String, $asm0E.System.String], arg_21_0, arg_21_1));
    var list = $S02().Construct();
    $S03().CallVirtual("Add", null, list, $T01().Format("{0} {1}({2})", JSIL.Array.New($T02(), [$thisType.DecodeType(returnType), methodName, JSIL.JoinStrings(", ", methodParams)])));
    $S03().CallVirtual("Add", null, list, "{");
    var tmpList = list;
    $T09().prototype.AddRange.call(tmpList, method);
    $S03().CallVirtual("Add", null, tmpList, "}");
    return JSIL.JoinEnumerable("\n", tmpList);
  }; 

  function GLSL_CreateUniform (type, varName) {
    return $T01().Format("uniform {0} {1};", JSIL.Array.New($T02(), [$thisType.DecodeType(type), varName]));
  }; 

  function GLSL_CreateVar (type, varName) {
    return $T01().Format("{0} {1}", JSIL.Array.New($T02(), [$thisType.DecodeType(type), varName]));
  }; 

  function GLSL_CreateVarying (type, varName) {
    return $T01().Format("varying {0} {1};", JSIL.Array.New($T02(), [$thisType.DecodeType(type), varName]));
  }; 

  function GLSL_DecodeType (type) {
    switch (type.valueOf()) {
      case 0: 
        var result = "mat3";
        break;

      case 1: 
        result = "mat4";
        break;

      case 2: 
        result = "vec2";
        break;

      case 3: 
        result = "vec3";
        break;

      case 4: 
        result = "vec4";
        break;

      case 5: 
        result = "bool";
        break;

      case 6: 
        result = "float";
        break;

      case 7: 
        result = "int";
        break;

      case 8: 
        result = "sampler2D";
        break;

      case 9: 
        result = "void";
        break;

      default: 
        throw $S04().Construct("type", type, null);

    }
    return result;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.GLSL", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      GLSL__ctor
    );

    $.Method({Static:true , Public:true }, "CreateAttribute", 
      new JSIL.MethodSignature($.String, [$asm04.TypeRef("Fusee.Engine.Core.Type"), $.String]), 
      GLSL_CreateAttribute
    );

    $.Method({Static:true , Public:true }, "CreateMethod", 
      new JSIL.MethodSignature($.String, [
          $asm04.TypeRef("Fusee.Engine.Core.Type"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.String]), $asm0E.TypeRef("System.Collections.Generic.IList`1", [$.String])
        ]), 
      GLSL_CreateMethod
    );

    $.Method({Static:true , Public:true }, "CreateUniform", 
      new JSIL.MethodSignature($.String, [$asm04.TypeRef("Fusee.Engine.Core.Type"), $.String]), 
      GLSL_CreateUniform
    );

    $.Method({Static:true , Public:true }, "CreateVar", 
      new JSIL.MethodSignature($.String, [$asm04.TypeRef("Fusee.Engine.Core.Type"), $.String]), 
      GLSL_CreateVar
    );

    $.Method({Static:true , Public:true }, "CreateVarying", 
      new JSIL.MethodSignature($.String, [$asm04.TypeRef("Fusee.Engine.Core.Type"), $.String]), 
      GLSL_CreateVarying
    );

    $.Method({Static:true , Public:false}, "DecodeType", 
      new JSIL.MethodSignature($.String, [$asm04.TypeRef("Fusee.Engine.Core.Type")]), 
      GLSL_DecodeType
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GLSL+<>c */ 

(function $l$gc$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.String)) ();
  };


  function $l$gc__ctor () {
  }; 

  function $l$gc_$lCreateMethod$gb__4_0 (x) {
    return JSIL.ConcatString("   ", x);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.GLSL+<>c", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__ctor
    );

    $.Method({Static:false, Public:false}, "$lCreateMethod$gb__4_0", 
      new JSIL.MethodSignature($.String, [$.String]), 
      $l$gc_$lCreateMethod$gb__4_0
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "$l$g9", $.Type);

    $.Field({Static:true , Public:true }, "$l$g9__4_0", $asm0E.TypeRef("System.Func`2", [$.String, $.String]));


    function $l$gc__cctor () {
      $thisType.$l$g9 = new $thisType();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__cctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ShaderCodeBuilder */ 

(function ShaderCodeBuilder$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.Fusee.Serialization.MaterialComponent)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.Fusee.Serialization.MeshComponent)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.Fusee.Serialization.WeightComponent)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.LightingCalculationMethod)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.MaterialType)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.String))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm04.Fusee.Engine.Core.GLSL)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Engine.Core.Type)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0A.Fusee.Serialization.MaterialLightComponent)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.Fusee.Serialization.MaterialPBRComponent)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.Globalization.NumberFormatInfo)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.Double)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult))) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm04.Fusee.Engine.Core.SceneRenderer)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0A.Fusee.Serialization.SceneNodeContainer))) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm04.Fusee.Engine.Core.MeshProbs)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm04.Fusee.Engine.Core.MaterialProbs)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0E.System.ArgumentOutOfRangeException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.String), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.String")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Globalization.NumberFormatInfo, null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentOutOfRangeException, [$asm0E.System.String]))) ();
  };


  function ShaderCodeBuilder__ctor$00 (mc, mesh, wc, renderWithShadows) {
    $thisType.prototype._ctor.call(this, 
      mc, 
      mesh, 
      $T04().SIMPLE, 
      wc, 
      renderWithShadows
    );
  }; 

  function ShaderCodeBuilder__ctor$01 (mc, mesh, lightingCalculation, wc, renderWithShadows) {
    this._materialType = $T05().Material;
    this._lightingCalculationMethod = lightingCalculation;
    this._renderWithShadows = renderWithShadows;
    this._vertexShader = $S00().Construct();
    this._pixelShader = $S00().Construct();
    this.AnalyzeMaterialType(mc);
    this.AnalyzeMesh(mesh, wc);
    this.AnalzyeMaterialParams(mc);
    this.CreateVertexShader(wc);
    this.ShaderCodeBuilder$VS$value = (JSIL.JoinEnumerable("\n", this._vertexShader));
    this.CreatePixelShader_new(mc);
    this.ShaderCodeBuilder$PS$value = (JSIL.JoinEnumerable("\n", this._pixelShader));
  }; 

  function ShaderCodeBuilder_AddAmbientLightMethod () {
    var list = $S00().Construct();
    $S01().CallVirtual("Add", null, list, (
        this._materialProbs.HasEmissive
           ? $T07().Format("return ({0} * ambientCoefficient);", JSIL.Array.New($T09(), [$thisType.ShaderCodeBuilder$EmissiveColorName$value]))
           : "return vec3(ambientCoefficient);")
    );
    var methodBody = list;
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateMethod($T0B().Vec3, "ambientLighting", JSIL.Array.New($T07(), [$T0A().CreateVar($T0B().Float, "ambientCoefficient")]), methodBody));
  }; 

  function ShaderCodeBuilder_AddApplyLightMethod (mc) {
    if (this._materialProbs.HasApplyLightString) {
      var arg_2A_0 = this._pixelShader;
      var expr_1E = $T0C().$As(mc);
      $S01().CallVirtual("Add", null, arg_2A_0, (
          (expr_1E !== null)
             ? expr_1E.ApplyLightString
             : null)
      );
    }
    var expr_35 = $S00().Construct();
    $S01().CallVirtual("Add", null, expr_35, "vec3 N = normalize(vMVNormal);");
    $S01().CallVirtual("Add", null, expr_35, "vec3 L = normalize(position - viewPos.xyz);");
    $S01().CallVirtual("Add", null, expr_35, "vec3 V = normalize(-viewPos.xyz);");
    $S01().CallVirtual("Add", null, expr_35, "if(lightType == 3) {");
    $S01().CallVirtual("Add", null, expr_35, "   L = normalize(vec3(0.0,0.0,-1.0));");
    $S01().CallVirtual("Add", null, expr_35, "   V = vec3(0);");
    $S01().CallVirtual("Add", null, expr_35, "}");
    $S01().CallVirtual("Add", null, expr_35, "vec2 o_texcoords = vUV;");
    $S01().CallVirtual("Add", null, expr_35, "");
    $S01().CallVirtual("Add", null, expr_35, (
        this._renderWithShadows
           ? "float shadowFactor = CalcShadowFactor(shadowLight);"
           : "")
    );
    $S01().CallVirtual("Add", null, expr_35, "");
    $S01().CallVirtual("Add", null, expr_35, "vec3 Idif = vec3(0);");
    $S01().CallVirtual("Add", null, expr_35, "vec3 Ispe = vec3(0);");
    $S01().CallVirtual("Add", null, expr_35, "");
    var applyLightParams = expr_35;
    if (this._materialProbs.HasDiffuse) {
      $S01().CallVirtual("Add", null, applyLightParams, "Idif = diffuseLighting(N, L, intensities);");
    }
    if (this._materialProbs.HasSpecular) {
      $S01().CallVirtual("Add", null, applyLightParams, "Ispe = specularLighting(N, L, V, intensities);");
    }
    $S01().CallVirtual("Add", null, applyLightParams, "vec3 Iamb = ambientLighting(ambientCoefficient);");
    var expr_138 = $S00().Construct();
    $S01().CallVirtual("Add", null, expr_138, "float distanceToLight = distance(position, viewPos.xyz) / 1000.0;");
    $S01().CallVirtual("Add", null, expr_138, "float distance = pow(distanceToLight/attenuation,4.0);");
    $S01().CallVirtual("Add", null, expr_138, "float att = (clamp(1.0 - pow(distance,2.0), 0.0, 1.0)) / (pow(distance,2.0) + 1.0);");
    var attenuation = expr_138;
    var expr_162 = $S00().Construct();
    $S01().CallVirtual("Add", null, expr_162, (
        this._renderWithShadows
           ? "result = Iamb + (1.0-shadowFactor) * (Idif + Ispe) * att;"
           : "result = Iamb + (Idif + Ispe) * att;")
    );
    var pointLight = expr_162;
    var expr_183 = $S00().Construct();
    $S01().CallVirtual("Add", null, expr_183, (
        this._renderWithShadows
           ? "result = Iamb + (1.0-shadowFactor) * (Idif + Ispe);"
           : "result =  Iamb + (Idif + Ispe);")
    );
    var parallelLight = expr_183;
    var expr_1A4 = $S00().Construct();
    $S01().CallVirtual("Add", null, expr_1A4, "float lightToSurfaceAngle = dot(-L, coneDirection);");
    $S01().CallVirtual("Add", null, expr_1A4, "if (lightToSurfaceAngle > coneAngle)");
    $S01().CallVirtual("Add", null, expr_1A4, "{");
    $S01().CallVirtual("Add", null, expr_1A4, "   att *= (1.0 - (1.0 - lightToSurfaceAngle) * 1.0/(1.0 - coneAngle));");
    $S01().CallVirtual("Add", null, expr_1A4, "}");
    $S01().CallVirtual("Add", null, expr_1A4, "else");
    $S01().CallVirtual("Add", null, expr_1A4, "{");
    $S01().CallVirtual("Add", null, expr_1A4, "   att = 0.0;");
    $S01().CallVirtual("Add", null, expr_1A4, "}");
    $S01().CallVirtual("Add", null, expr_1A4, "");
    $S01().CallVirtual("Add", null, expr_1A4, (
        this._renderWithShadows
           ? "result = Iamb + (1.0-shadowFactor) * (Idif + Ispe) * att;"
           : "result = Iamb + (Idif + Ispe) * att;")
    );
    var spotLight = expr_1A4;
    var methodBody = $S00().Construct();
    $T06().prototype.AddRange.call(methodBody, applyLightParams);
    $S01().CallVirtual("Add", null, methodBody, "vec3 result = vec3(0);");
    $S01().CallVirtual("Add", null, methodBody, "");
    $T06().prototype.AddRange.call(methodBody, attenuation);
    $S01().CallVirtual("Add", null, methodBody, "if(lightType == 0) // PointLight");
    $S01().CallVirtual("Add", null, methodBody, "{");
    $T06().prototype.AddRange.call(methodBody, pointLight);
    $S01().CallVirtual("Add", null, methodBody, "}");
    $S01().CallVirtual("Add", null, methodBody, "else if(lightType == 1 || lightType == 3) // ParallelLight or LegacyLight");
    $S01().CallVirtual("Add", null, methodBody, "{");
    $T06().prototype.AddRange.call(methodBody, parallelLight);
    $S01().CallVirtual("Add", null, methodBody, "}");
    $S01().CallVirtual("Add", null, methodBody, "else if(lightType == 2) // SpotLight");
    $S01().CallVirtual("Add", null, methodBody, "{");
    $T06().prototype.AddRange.call(methodBody, spotLight);
    $S01().CallVirtual("Add", null, methodBody, "}");
    $S01().CallVirtual("Add", null, methodBody, "");
    $S01().CallVirtual("Add", null, methodBody, "");
    $S01().CallVirtual("Add", null, methodBody, "return result;");
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateMethod($T0B().Vec3, "ApplyLight", JSIL.Array.New($T07(), [$T0A().CreateVar($T0B().Vec3, "position"), $T0A().CreateVar($T0B().Vec3, "intensities"), $T0A().CreateVar($T0B().Vec3, "coneDirection"), $T0A().CreateVar($T0B().Float, "attenuation"), $T0A().CreateVar($T0B().Float, "ambientCoefficient"), $T0A().CreateVar($T0B().Float, "coneAngle"), $T0A().CreateVar($T0B().Int, "lightType")]), methodBody));
  }; 

  function ShaderCodeBuilder_AddDiffuseLightMethod () {
    var expr_06 = $S00().Construct();
    $S01().CallVirtual("Add", null, expr_06, "float diffuseTerm = dot(N, L);");
    var methodBody = expr_06;
    if (this._materialProbs.HasDiffuseTexture) {
      $S01().CallVirtual("Add", null, methodBody, $T07().Format("return texture2D({0}, vUV).rgb * {1} *  max(diffuseTerm, 0.0) * intensities;", JSIL.Array.New($T09(), [$thisType.ShaderCodeBuilder$DiffuseTextureName$value, $thisType.ShaderCodeBuilder$DiffuseMixName$value])));
    } else {
      $S01().CallVirtual("Add", null, methodBody, $T07().Format("return ({0} * intensities * diffuseTerm);", JSIL.Array.New($T09(), [$thisType.ShaderCodeBuilder$DiffuseColorName$value])));
    }
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateMethod($T0B().Vec3, "diffuseLighting", JSIL.Array.New($T07(), [$T0A().CreateVar($T0B().Vec3, "N"), $T0A().CreateVar($T0B().Vec3, "L"), $T0A().CreateVar($T0B().Vec3, "intensities")]), methodBody));
  }; 

  function ShaderCodeBuilder_AddPbrSpecularLightMethod (mc) {
    var expr_06 = $S02().Construct();
    expr_06.set_NumberDecimalSeparator(".");
    var nfi = expr_06;
    var roughness = mc.RoughnessValue + 1E-07;
    var fresnel = mc.FresnelReflectance + 1E-07;
    var i = mc.DiffuseFraction + 1E-07;
    var list = $S00().Construct();
    $S01().CallVirtual("Add", null, list, $T07().Format("float roughnessValue = {0}; // 0 : smooth, 1: rough", JSIL.Array.New($T09(), [$T0F().__Type__.__PublicInterface__.$ToString(roughness, null, nfi)])));
    $S01().CallVirtual("Add", null, list, $T07().Format("float F0 = {0}; // fresnel reflectance at normal incidence", JSIL.Array.New($T09(), [$T0F().__Type__.__PublicInterface__.$ToString(fresnel, null, nfi)])));
    $S01().CallVirtual("Add", null, list, $T07().Format("float k = 1.0-{0}; // metaliness", JSIL.Array.New($T09(), [$T0F().__Type__.__PublicInterface__.$ToString(i, null, nfi)])));
    $S01().CallVirtual("Add", null, list, "float NdotL = max(dot(N, L), 0.0);");
    $S01().CallVirtual("Add", null, list, "float specular = 0.0;");
    $S01().CallVirtual("Add", null, list, "float BlinnSpecular = 0.0;");
    $S01().CallVirtual("Add", null, list, "");
    $S01().CallVirtual("Add", null, list, "if(dot(N, L) > 0.0)");
    $S01().CallVirtual("Add", null, list, "{");
    $S01().CallVirtual("Add", null, list, "     // calculate intermediary values");
    $S01().CallVirtual("Add", null, list, "     vec3 H = normalize(L + V);");
    $S01().CallVirtual("Add", null, list, "     float NdotH = max(dot(N, H), 0.0); ");
    $S01().CallVirtual("Add", null, list, "     float NdotV = max(dot(N, L), 0.0); // note: this is NdotL, which is the same value");
    $S01().CallVirtual("Add", null, list, "     float VdotH = max(dot(V, H), 0.0);");
    $S01().CallVirtual("Add", null, list, "     float mSquared = roughnessValue * roughnessValue;");
    $S01().CallVirtual("Add", null, list, "");
    $S01().CallVirtual("Add", null, list, "");
    $S01().CallVirtual("Add", null, list, "");
    $S01().CallVirtual("Add", null, list, "");
    $S01().CallVirtual("Add", null, list, "     // -- geometric attenuation");
    $S01().CallVirtual("Add", null, list, "     //[Schlick's approximation of Smith's shadow equation]");
    $S01().CallVirtual("Add", null, list, "     float k= roughnessValue * sqrt(2.0/3.14159265);");
    $S01().CallVirtual("Add", null, list, "     float one_minus_k= 1.0 - k;");
    $S01().CallVirtual("Add", null, list, "     float geoAtt = ( NdotL / (NdotL * one_minus_k + k) ) * ( NdotV / (NdotV * one_minus_k + k) );");
    $S01().CallVirtual("Add", null, list, "");
    $S01().CallVirtual("Add", null, list, "     // -- roughness (or: microfacet distribution function)");
    $S01().CallVirtual("Add", null, list, "     // Trowbridge-Reitz or GGX, GTR2");
    $S01().CallVirtual("Add", null, list, "     float a2 = mSquared * mSquared;");
    $S01().CallVirtual("Add", null, list, "     float d = (NdotH * a2 - NdotH) * NdotH + 1.0;");
    $S01().CallVirtual("Add", null, list, "     float roughness = a2 / (3.14 * d * d);");
    $S01().CallVirtual("Add", null, list, "");
    $S01().CallVirtual("Add", null, list, "     // -- fresnel");
    $S01().CallVirtual("Add", null, list, "     // [Schlick 1994, An Inexpensive BRDF Model for Physically-Based Rendering]");
    $S01().CallVirtual("Add", null, list, "     float fresnel = pow(1.0 - VdotH, 5.0);");
    $S01().CallVirtual("Add", null, list, $T07().Format("    fresnel = clamp((50.0 * {0}.y), 0.0, 1.0) * fresnel + (1.0 - fresnel);", JSIL.Array.New($T09(), [$thisType.ShaderCodeBuilder$SpecularColorName$value])));
    $S01().CallVirtual("Add", null, list, "");
    $S01().CallVirtual("Add", null, list, "     specular = (fresnel * geoAtt * roughness) / (NdotV * NdotL * 3.14);");
    $S01().CallVirtual("Add", null, list, "     ");
    $S01().CallVirtual("Add", null, list, "}");
    $S01().CallVirtual("Add", null, list, "");
    $S01().CallVirtual("Add", null, list, $T07().Format("return intensities * {0} * (k + specular * (1.0-k));", JSIL.Array.New($T09(), [$thisType.ShaderCodeBuilder$SpecularColorName$value])));
    var methodBody = list;
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateMethod($T0B().Vec3, "specularLighting", JSIL.Array.New($T07(), [$T0A().CreateVar($T0B().Vec3, "N"), $T0A().CreateVar($T0B().Vec3, "L"), $T0A().CreateVar($T0B().Vec3, "V"), $T0A().CreateVar($T0B().Vec3, "intensities")]), methodBody));
  }; 

  function ShaderCodeBuilder_AddPixelAttributes () {
    $S01().CallVirtual("Add", null, this._pixelShader, $thisType.EsPrecision());
    var numberOfLights = ((
      (($T12().AllLightResults.get_Count() | 0) > 0)
         ? $T12().AllLightResults.get_Count()
         : 1)
     | 0);
    $S01().CallVirtual("Add", null, this._pixelShader, $T07().Format("#define MAX_LIGHTS {0}", JSIL.Array.New($T09(), [$T10().$Box(numberOfLights)])));
    $S01().CallVirtual("Add", null, this._pixelShader, $thisType.LightStructDeclaration());
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateVarying($T0B().Vec3, "vViewDir"));
    if (this._meshProbs.HasNormals) {
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateVarying($T0B().Vec3, "vMVNormal"));
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateVarying($T0B().Vec3, "vNormal"));
    }
    if (this._meshProbs.HasUVs) {
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateVarying($T0B().Vec2, "vUV"));
    }
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateVarying($T0B().Vec3, "viewPos"));
    if (this._renderWithShadows) {
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateVarying($T0B().Vec4, "shadowLight"));
    }
  }; 

  function ShaderCodeBuilder_AddPixelBody () {
    var expr_06 = $S00().Construct();
    $S01().CallVirtual("Add", null, expr_06, "vec3 result = vec3(0.0);");
    $S01().CallVirtual("Add", null, expr_06, "for(int i = 0; i < MAX_LIGHTS;i++)");
    $S01().CallVirtual("Add", null, expr_06, "{");
    $S01().CallVirtual("Add", null, expr_06, "vec3 currentPosition = allLights[i].position;");
    $S01().CallVirtual("Add", null, expr_06, "vec3 currentIntensities = allLights[i].intensities;");
    $S01().CallVirtual("Add", null, expr_06, "vec3 currentConeDirection = allLights[i].coneDirection;");
    $S01().CallVirtual("Add", null, expr_06, "float currentAttenuation = allLights[i].attenuation;");
    $S01().CallVirtual("Add", null, expr_06, "float currentAmbientCoefficient = allLights[i].ambientCoefficient;");
    $S01().CallVirtual("Add", null, expr_06, "float currentConeAngle = allLights[i].coneAngle;");
    $S01().CallVirtual("Add", null, expr_06, "int currentLightType = allLights[i].lightType; ");
    $S01().CallVirtual("Add", null, expr_06, "result += ApplyLight(currentPosition, currentIntensities, currentConeDirection, ");
    $S01().CallVirtual("Add", null, expr_06, "currentAttenuation, currentAmbientCoefficient, currentConeAngle, currentLightType);");
    $S01().CallVirtual("Add", null, expr_06, "}");
    $S01().CallVirtual("Add", null, expr_06, "gl_FragColor = vec4(result, 1.0);");
    var methodBody = expr_06;
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateMethod($T0B().Void, "main", JSIL.Array.New($T07(), [""]), methodBody));
  }; 

  function ShaderCodeBuilder_AddPixelUniforms () {
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Mat4, "FUSEE_MV"));
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Mat4, "FUSEE_IMV"));
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Mat4, "FUSEE_IV"));
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Sampler2D, "firstPassTex"));
  }; 

  function ShaderCodeBuilder_AddShadowMethod () {
    var expr_06 = $S00().Construct();
    $S01().CallVirtual("Add", null, expr_06, "// perform perspective divide for ortographic!");
    $S01().CallVirtual("Add", null, expr_06, "vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;");
    $S01().CallVirtual("Add", null, expr_06, "projCoords = projCoords * 0.5 + 0.5; // map to [0,1]");
    $S01().CallVirtual("Add", null, expr_06, "float currentDepth = projCoords.z;");
    $S01().CallVirtual("Add", null, expr_06, "float pcfDepth = texture2D(firstPassTex, projCoords.xy).r;");
    $S01().CallVirtual("Add", null, expr_06, "float shadow = 0.0;");
    $S01().CallVirtual("Add", null, expr_06, "shadow = currentDepth - 0.01 > pcfDepth ? 1.0 : 0.0;");
    $S01().CallVirtual("Add", null, expr_06, "if (projCoords.z > 1.0)");
    $S01().CallVirtual("Add", null, expr_06, "   shadow = 0.0;");
    $S01().CallVirtual("Add", null, expr_06, "");
    $S01().CallVirtual("Add", null, expr_06, "return shadow;");
    var methodBody = expr_06;
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateMethod($T0B().Float, "CalcShadowFactor", JSIL.Array.New($T07(), [$T0A().CreateVar($T0B().Vec4, "fragPosLightSpace")]), methodBody));
  }; 

  function ShaderCodeBuilder_AddSpecularLightMethod () {
    var list = $S00().Construct();
    $S01().CallVirtual("Add", null, list, "float specularTerm = 0.0;");
    $S01().CallVirtual("Add", null, list, "if(dot(N, L) > 0.0)");
    $S01().CallVirtual("Add", null, list, "{");
    $S01().CallVirtual("Add", null, list, "   // half vector");
    $S01().CallVirtual("Add", null, list, "   vec3 H = normalize(V + L);");
    $S01().CallVirtual("Add", null, list, $T07().Format("  specularTerm = pow(max(0.0, dot(H, N)), {0});", JSIL.Array.New($T09(), [$thisType.ShaderCodeBuilder$SpecularShininessName$value])));
    $S01().CallVirtual("Add", null, list, "}");
    $S01().CallVirtual("Add", null, list, $T07().Format("return ({0} * {1} * intensities) * specularTerm;", JSIL.Array.New($T09(), [$thisType.ShaderCodeBuilder$SpecularColorName$value, $thisType.ShaderCodeBuilder$SpecularIntensityName$value])));
    var methodBody = list;
    $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateMethod($T0B().Vec3, "specularLighting", JSIL.Array.New($T07(), [$T0A().CreateVar($T0B().Vec3, "N"), $T0A().CreateVar($T0B().Vec3, "L"), $T0A().CreateVar($T0B().Vec3, "V"), $T0A().CreateVar($T0B().Vec3, "intensities")]), methodBody));
  }; 

  function ShaderCodeBuilder_AddTabsToMethods (/* ref */ list) {
    var indent = false;

  $loop0: 
    for (var i = 0; i < ((list.get()).get_Count() | 0); i = ((i + 1) | 0)) {
      var s = (list.get()).get_Item(i);
      var flag = (((list.get()).get_Item(i).indexOf("}") != -1));
      if (flag) {
        break $loop0;
      }
      var flag2 = indent;
      if (flag2) {
        (list.get()).set_Item(i, JSIL.ConcatString("   ", s));
      }
      var flag3 = (((list.get()).get_Item(i).indexOf("{") != -1));
      if (flag3) {
        indent = true;
      }
    }
  }; 

  function ShaderCodeBuilder_AddTextureChannels () {
    if (this._materialProbs.HasSpecular) {
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Float, $thisType.ShaderCodeBuilder$SpecularShininessName$value));
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Float, $thisType.ShaderCodeBuilder$SpecularIntensityName$value));
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Vec3, $thisType.ShaderCodeBuilder$SpecularColorName$value));
    }
    if (this._materialProbs.HasBump) {
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Sampler2D, $thisType.ShaderCodeBuilder$BumpTextureName$value));
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Float, $thisType.ShaderCodeBuilder$BumpIntensityName$value));
    }
    if (this._materialProbs.HasDiffuse) {
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Vec3, $thisType.ShaderCodeBuilder$DiffuseColorName$value));
    }
    if (this._materialProbs.HasDiffuseTexture) {
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Sampler2D, $thisType.ShaderCodeBuilder$DiffuseTextureName$value));
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Float, $thisType.ShaderCodeBuilder$DiffuseMixName$value));
    }
    if (this._materialProbs.HasEmissive) {
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Float, $thisType.ShaderCodeBuilder$EmissiveColorName$value));
    }
    if (this._materialProbs.HasEmissiveTexture) {
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Sampler2D, $thisType.ShaderCodeBuilder$EmissiveTextureName$value));
      $S01().CallVirtual("Add", null, this._pixelShader, $T0A().CreateUniform($T0B().Float, $thisType.ShaderCodeBuilder$EmissiveMixName$value));
    }
  }; 

  function ShaderCodeBuilder_AddVertexAttributes () {
    if (this._meshProbs.HasVertices) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateAttribute($T0B().Vec3, "fuVertex"));
    }
    if (this._materialProbs.HasSpecular) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateVarying($T0B().Vec3, "vViewDir"));
    }
    if (this._meshProbs.HasWeightMap) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateAttribute($T0B().Vec4, "fuBoneIndex"));
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateAttribute($T0B().Vec4, "fuBoneWeight"));
    }
    if (this._meshProbs.HasNormals) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateAttribute($T0B().Vec3, "fuNormal"));
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateVarying($T0B().Vec3, "vNormal"));
    }
    if (this._meshProbs.HasUVs) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateAttribute($T0B().Vec2, "fuUV"));
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateVarying($T0B().Vec2, "vUV"));
    }
    if (this._meshProbs.HasColors) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateAttribute($T0B().Vec4, "fuColor"));
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateVarying($T0B().Vec4, "vColors"));
    }
    $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateVarying($T0B().Vec3, "viewPos"));
    $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateVarying($T0B().Vec3, "vMVNormal"));
    if (this._renderWithShadows) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateVarying($T0B().Vec4, "shadowLight"));
    }
  }; 

  function ShaderCodeBuilder_AddVertexMain () {
    $S01().CallVirtual("Add", null, this._vertexShader, "void main() {");
    if (this._meshProbs.HasNormals && this._meshProbs.HasWeightMap) {
      $S01().CallVirtual("Add", null, this._vertexShader, "vec4 newVertex;");
      $S01().CallVirtual("Add", null, this._vertexShader, "vec4 newNormal;");
      $S01().CallVirtual("Add", null, this._vertexShader, "newVertex = (FUSEE_BONES[int(fuBoneIndex.x)] * vec4(fuVertex, 1.0) ) * fuBoneWeight.x ;");
      $S01().CallVirtual("Add", null, this._vertexShader, "newNormal = (FUSEE_BONES[int(fuBoneIndex.x)] * vec4(fuNormal, 0.0)) * fuBoneWeight.x;");
      $S01().CallVirtual("Add", null, this._vertexShader, "newVertex = (FUSEE_BONES[int(fuBoneIndex.y)] * vec4(fuVertex, 1.0)) * fuBoneWeight.y + newVertex;");
      $S01().CallVirtual("Add", null, this._vertexShader, "newNormal = (FUSEE_BONES[int(fuBoneIndex.y)] * vec4(fuNormal, 0.0)) * fuBoneWeight.y + newNormal;");
      $S01().CallVirtual("Add", null, this._vertexShader, "newVertex = (FUSEE_BONES[int(fuBoneIndex.z)] * vec4(fuVertex, 1.0)) * fuBoneWeight.z + newVertex;");
      $S01().CallVirtual("Add", null, this._vertexShader, "newNormal = (FUSEE_BONES[int(fuBoneIndex.z)] * vec4(fuNormal, 0.0)) * fuBoneWeight.z + newNormal;");
      $S01().CallVirtual("Add", null, this._vertexShader, "newVertex = (FUSEE_BONES[int(fuBoneIndex.w)] * vec4(fuVertex, 1.0)) * fuBoneWeight.w + newVertex;");
      $S01().CallVirtual("Add", null, this._vertexShader, "newNormal = (FUSEE_BONES[int(fuBoneIndex.w)] * vec4(fuNormal, 0.0)) * fuBoneWeight.w + newNormal;");
      $S01().CallVirtual("Add", null, this._vertexShader, "vNormal = mat3(FUSEE_IMV) * newNormal.xyz;");
    }
    if (this._materialProbs.HasSpecular) {
      $S01().CallVirtual("Add", null, this._vertexShader, "vec3 viewPos = FUSEE_IMV[3].xyz;");
      $S01().CallVirtual("Add", null, this._vertexShader, (
          this._meshProbs.HasWeightMap
             ? "vViewDir = normalize(viewPos - vec3(newVertex));"
             : "vViewDir = normalize(viewPos - fuVertex);")
      );
    }
    if (this._meshProbs.HasUVs) {
      $S01().CallVirtual("Add", null, this._vertexShader, "vUV = fuUV;");
    }
    $S01().CallVirtual("Add", null, this._vertexShader, "vMVNormal = normalize(mat3(FUSEE_ITMV) * fuNormal);");
    $S01().CallVirtual("Add", null, this._vertexShader, "viewPos = (FUSEE_MV * vec4(fuVertex, 1.0)).xyz;");
    if (this._renderWithShadows) {
      $S01().CallVirtual("Add", null, this._vertexShader, "shadowLight = shadowMVP * viewPos;");
    }
    $S01().CallVirtual("Add", null, this._vertexShader, (
        this._meshProbs.HasWeightMap
           ? "gl_Position = FUSEE_P * FUSEE_V * vec4(vec3(newVertex), 1.0);"
           : "gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);")
    );
    $S01().CallVirtual("Add", null, this._vertexShader, "}");
  }; 

  function ShaderCodeBuilder_AddVertexUniforms (wc) {
    $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateUniform($T0B().Mat4, "FUSEE_MVP"));
    if (this._meshProbs.HasNormals) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateUniform($T0B().Mat4, "FUSEE_ITMV"));
    }
    if (this._materialProbs.HasSpecular) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateUniform($T0B().Mat4, "FUSEE_IMV"));
    }
    if (this._meshProbs.HasWeightMap) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateUniform($T0B().Mat4, "FUSEE_P"));
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateUniform($T0B().Mat4, "FUSEE_IMV"));
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateUniform($T0B().Mat4, $T07().Format("FUSEE_BONES[{0}]", JSIL.Array.New($T09(), [$T10().$Box((wc.Joints).get_Count())]))));
    }
    $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateUniform($T0B().Mat4, "FUSEE_MV"));
    if (this._renderWithShadows) {
      $S01().CallVirtual("Add", null, this._vertexShader, $T0A().CreateUniform($T0B().Mat4, "shadowMVP"));
    }
  }; 

  function ShaderCodeBuilder_AnalyzeMaterialType (mc) {
    if (JSIL.GetType(mc) === $T0D().__Type__) {
      this._materialType = $T05().MaterialPbrComponent;
    }
    if (JSIL.GetType(mc) === $T0C().__Type__) {
      this._materialType = $T05().MaterialLightComponent;
    }
  }; 

  function ShaderCodeBuilder_AnalyzeMesh (mesh, wc) {
    var meshProbs = new ($T14())();
    meshProbs.HasVertices = (mesh === null) || 
    ((mesh.Vertices !== null) && 
      ((mesh.Vertices.length >>> 0) > (0 >>> 0)));
    meshProbs.HasNormals = (mesh === null) || 
    ((mesh.Normals !== null) && 
      ((mesh.Normals.length >>> 0) > (0 >>> 0)));
    meshProbs.HasUVs = (mesh === null) || 
    ((mesh.UVs !== null) && 
      ((mesh.UVs.length >>> 0) > (0 >>> 0)));
    meshProbs.HasColors = false;
    meshProbs.HasWeightMap = wc !== null;
    this._meshProbs = meshProbs.MemberwiseClone();
  }; 

  function ShaderCodeBuilder_AnalzyeMaterialParams (mc) {
    var materialProbs = new ($T18())();
    materialProbs.HasDiffuse = mc.get_HasDiffuse();
    materialProbs.HasDiffuseTexture = mc.Diffuse.Texture !== null;
    materialProbs.HasSpecular = mc.get_HasSpecular();
    materialProbs.HasSpecularTexture = mc.get_HasSpecular() && 
    (mc.Specular.Texture !== null);
    materialProbs.HasEmissive = mc.get_HasEmissive();
    materialProbs.HasEmissiveTexture = mc.get_HasEmissive() && 
    (mc.Emissive.Texture !== null);
    materialProbs.HasBump = mc.get_HasBump();
    if (this._materialType === $T05().MaterialLightComponent) {
      var expr_A4 = $T0C().$As(mc);
      var arg_B8_1 = $T07().IsNullOrEmpty((
          (expr_A4 !== null)
             ? expr_A4.ApplyLightString
             : null)
      );
    } else {
      arg_B8_1 = false;
    }
    materialProbs.HasApplyLightString = arg_B8_1;
    this._materialProbs = materialProbs.MemberwiseClone();
  }; 

  function ShaderCodeBuilder_CreatePixelShader_new (mc) {
    $S01().CallVirtual("Add", null, this._pixelShader, $thisType.Version());
    this.AddPixelAttributes();
    this.AddPixelUniforms();
    this.AddTextureChannels();
    var materialType = this._materialType;
    if (materialType > $T05().MaterialLightComponent) {
      if (materialType !== $T05().MaterialPbrComponent) {
        throw $S03().Construct($T07().Format("Material Type unknown or incorrect: {0}", JSIL.Array.New($T09(), [this._materialType])));
      }
      if (this._lightingCalculationMethod !== $T04().ADVANCED) {
        this.AddAmbientLightMethod();
        if (this._materialProbs.HasDiffuse) {
          this.AddDiffuseLightMethod();
        }
        if (this._materialProbs.HasSpecular) {
          this.AddSpecularLightMethod();
        }
      } else {
        this.AddAmbientLightMethod();
        if (this._materialProbs.HasDiffuse) {
          this.AddDiffuseLightMethod();
        }
        if (this._materialProbs.HasSpecular) {
          this.AddPbrSpecularLightMethod($T0D().$As(mc));
        }
      }
    } else {
      this.AddAmbientLightMethod();
      if (this._materialProbs.HasDiffuse) {
        this.AddDiffuseLightMethod();
      }
      if (this._materialProbs.HasSpecular) {
        this.AddSpecularLightMethod();
      }
    }
    if (this._renderWithShadows) {
      this.AddShadowMethod();
    }
    this.AddApplyLightMethod(mc);
    this.AddPixelBody();
    $thisType.AddTabsToMethods(/* ref */ new JSIL.MemberReference(this, "_pixelShader"));
  }; 

  function ShaderCodeBuilder_CreateVertexShader (wc) {
    $S01().CallVirtual("Add", null, this._vertexShader, $thisType.Version());
    this.AddVertexAttributes();
    this.AddVertexUniforms(wc);
    this.AddVertexMain();
    $thisType.AddTabsToMethods(/* ref */ new JSIL.MemberReference(this, "_vertexShader"));
  }; 

  function ShaderCodeBuilder_EsPrecision () {
    return "#ifdef GL_ES\n    precision highp float;\n#endif\n\n";
  }; 

  function ShaderCodeBuilder_get_BumpIntensityName () {
    return $thisType.ShaderCodeBuilder$BumpIntensityName$value;
  }; 

  function ShaderCodeBuilder_get_BumpTextureName () {
    return $thisType.ShaderCodeBuilder$BumpTextureName$value;
  }; 

  function ShaderCodeBuilder_get_DiffuseColorName () {
    return $thisType.ShaderCodeBuilder$DiffuseColorName$value;
  }; 

  function ShaderCodeBuilder_get_DiffuseMixName () {
    return $thisType.ShaderCodeBuilder$DiffuseMixName$value;
  }; 

  function ShaderCodeBuilder_get_DiffuseTextureName () {
    return $thisType.ShaderCodeBuilder$DiffuseTextureName$value;
  }; 

  function ShaderCodeBuilder_get_EmissiveColorName () {
    return $thisType.ShaderCodeBuilder$EmissiveColorName$value;
  }; 

  function ShaderCodeBuilder_get_EmissiveMixName () {
    return $thisType.ShaderCodeBuilder$EmissiveMixName$value;
  }; 

  function ShaderCodeBuilder_get_EmissiveTextureName () {
    return $thisType.ShaderCodeBuilder$EmissiveTextureName$value;
  }; 

  function ShaderCodeBuilder_get_LightColorName () {
    return $thisType.ShaderCodeBuilder$LightColorName$value;
  }; 

  function ShaderCodeBuilder_get_LightDirectionName () {
    return $thisType.ShaderCodeBuilder$LightDirectionName$value;
  }; 

  function ShaderCodeBuilder_get_LightIntensityName () {
    return $thisType.ShaderCodeBuilder$LightIntensityName$value;
  }; 

  function ShaderCodeBuilder_get_PS () {
    return this.ShaderCodeBuilder$PS$value;
  }; 

  function ShaderCodeBuilder_get_SpecularColorName () {
    return $thisType.ShaderCodeBuilder$SpecularColorName$value;
  }; 

  function ShaderCodeBuilder_get_SpecularIntensityName () {
    return $thisType.ShaderCodeBuilder$SpecularIntensityName$value;
  }; 

  function ShaderCodeBuilder_get_SpecularMixName () {
    return $thisType.ShaderCodeBuilder$SpecularMixName$value;
  }; 

  function ShaderCodeBuilder_get_SpecularShininessName () {
    return $thisType.ShaderCodeBuilder$SpecularShininessName$value;
  }; 

  function ShaderCodeBuilder_get_SpecularTextureName () {
    return $thisType.ShaderCodeBuilder$SpecularTextureName$value;
  }; 

  function ShaderCodeBuilder_get_VS () {
    return this.ShaderCodeBuilder$VS$value;
  }; 

  function ShaderCodeBuilder_LightStructDeclaration () {
    return "\r\n            struct Light \r\n            {\r\n                vec3 position;\r\n                vec3 intensities;\r\n                vec3 coneDirection;\r\n                float attenuation;\r\n                float ambientCoefficient;\r\n                float coneAngle;\r\n                int lightType;\r\n            };\r\n            uniform Light allLights[MAX_LIGHTS];\r\n            ";
  }; 

  function ShaderCodeBuilder_Version () {
    return "#version 100\n";
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.ShaderCodeBuilder", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 5, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("Fusee.Serialization.MaterialComponent"), $asm0A.TypeRef("Fusee.Serialization.MeshComponent"), 
          $asm0A.TypeRef("Fusee.Serialization.WeightComponent"), $.Boolean
        ]), 
      ShaderCodeBuilder__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("Fusee.Serialization.MaterialComponent"), $asm0A.TypeRef("Fusee.Serialization.MeshComponent"), 
          $asm04.TypeRef("Fusee.Engine.Core.LightingCalculationMethod"), $asm0A.TypeRef("Fusee.Serialization.WeightComponent"), 
          $.Boolean
        ]), 
      ShaderCodeBuilder__ctor$01
    );

    $.Method({Static:false, Public:false}, "AddAmbientLightMethod", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddAmbientLightMethod
    );

    $.Method({Static:false, Public:false}, "AddApplyLightMethod", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialComponent")), 
      ShaderCodeBuilder_AddApplyLightMethod
    );

    $.Method({Static:false, Public:false}, "AddDiffuseLightMethod", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddDiffuseLightMethod
    );

    $.Method({Static:false, Public:false}, "AddPbrSpecularLightMethod", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialPBRComponent")), 
      ShaderCodeBuilder_AddPbrSpecularLightMethod
    );

    $.Method({Static:false, Public:false}, "AddPixelAttributes", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddPixelAttributes
    );

    $.Method({Static:false, Public:false}, "AddPixelBody", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddPixelBody
    );

    $.Method({Static:false, Public:false}, "AddPixelUniforms", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddPixelUniforms
    );

    $.Method({Static:false, Public:false}, "AddShadowMethod", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddShadowMethod
    );

    $.Method({Static:false, Public:false}, "AddSpecularLightMethod", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddSpecularLightMethod
    );

    $.Method({Static:true , Public:false}, "AddTabsToMethods", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$asm0E.TypeRef("System.Collections.Generic.List`1", [$.String])])), 
      ShaderCodeBuilder_AddTabsToMethods
    );

    $.Method({Static:false, Public:false}, "AddTextureChannels", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddTextureChannels
    );

    $.Method({Static:false, Public:false}, "AddVertexAttributes", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddVertexAttributes
    );

    $.Method({Static:false, Public:false}, "AddVertexMain", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder_AddVertexMain
    );

    $.Method({Static:false, Public:false}, "AddVertexUniforms", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.WeightComponent")), 
      ShaderCodeBuilder_AddVertexUniforms
    );

    $.Method({Static:false, Public:false}, "AnalyzeMaterialType", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialComponent")), 
      ShaderCodeBuilder_AnalyzeMaterialType
    );

    $.Method({Static:false, Public:false}, "AnalyzeMesh", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("Fusee.Serialization.MeshComponent"), $asm0A.TypeRef("Fusee.Serialization.WeightComponent")]), 
      ShaderCodeBuilder_AnalyzeMesh
    );

    $.Method({Static:false, Public:false}, "AnalzyeMaterialParams", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialComponent")), 
      ShaderCodeBuilder_AnalzyeMaterialParams
    );

    $.Method({Static:false, Public:false}, "CreatePixelShader_new", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialComponent")), 
      ShaderCodeBuilder_CreatePixelShader_new
    );

    $.Method({Static:false, Public:false}, "CreateVertexShader", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.WeightComponent")), 
      ShaderCodeBuilder_CreateVertexShader
    );

    $.Method({Static:true , Public:false}, "EsPrecision", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_EsPrecision
    );

    $.Method({Static:true , Public:true }, "get_BumpIntensityName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_BumpIntensityName
    );

    $.Method({Static:true , Public:true }, "get_BumpTextureName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_BumpTextureName
    );

    $.Method({Static:true , Public:true }, "get_DiffuseColorName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_DiffuseColorName
    );

    $.Method({Static:true , Public:true }, "get_DiffuseMixName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_DiffuseMixName
    );

    $.Method({Static:true , Public:true }, "get_DiffuseTextureName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_DiffuseTextureName
    );

    $.Method({Static:true , Public:true }, "get_EmissiveColorName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_EmissiveColorName
    );

    $.Method({Static:true , Public:true }, "get_EmissiveMixName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_EmissiveMixName
    );

    $.Method({Static:true , Public:true }, "get_EmissiveTextureName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_EmissiveTextureName
    );

    $.Method({Static:true , Public:true }, "get_LightColorName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_LightColorName
    );

    $.Method({Static:true , Public:true }, "get_LightDirectionName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_LightDirectionName
    );

    $.Method({Static:true , Public:true }, "get_LightIntensityName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_LightIntensityName
    );

    $.Method({Static:false, Public:true }, "get_PS", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_PS
    );

    $.Method({Static:true , Public:true }, "get_SpecularColorName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_SpecularColorName
    );

    $.Method({Static:true , Public:true }, "get_SpecularIntensityName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_SpecularIntensityName
    );

    $.Method({Static:true , Public:true }, "get_SpecularMixName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_SpecularMixName
    );

    $.Method({Static:true , Public:true }, "get_SpecularShininessName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_SpecularShininessName
    );

    $.Method({Static:true , Public:true }, "get_SpecularTextureName", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_SpecularTextureName
    );

    $.Method({Static:false, Public:true }, "get_VS", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_get_VS
    );

    $.Method({Static:true , Public:false}, "LightStructDeclaration", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_LightStructDeclaration
    );

    $.Method({Static:true , Public:false}, "Version", 
      JSIL.MethodSignature.Return($.String), 
      ShaderCodeBuilder_Version
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_lightingCalculationMethod", $asm04.TypeRef("Fusee.Engine.Core.LightingCalculationMethod"));

    $.Field({Static:false, Public:false}, "_materialProbs", $asm04.TypeRef("Fusee.Engine.Core.MaterialProbs"));

    $.Field({Static:false, Public:false}, "_meshProbs", $asm04.TypeRef("Fusee.Engine.Core.MeshProbs"));

    $.Field({Static:false, Public:false}, "_materialType", $asm04.TypeRef("Fusee.Engine.Core.MaterialType"));

    $.Field({Static:false, Public:false}, "_vertexShader", $asm0E.TypeRef("System.Collections.Generic.List`1", [$.String]));

    $.Field({Static:false, Public:false}, "_pixelShader", $asm0E.TypeRef("System.Collections.Generic.List`1", [$.String]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_renderWithShadows", $.Boolean);

    $.Field({Static:false, Public:false, ReadOnly:true }, "ShaderCodeBuilder$VS$value", $.String);

    $.Field({Static:false, Public:false, ReadOnly:true }, "ShaderCodeBuilder$PS$value", $.String);

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$DiffuseColorName$value", $.String, "DiffuseColor");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$SpecularColorName$value", $.String, "SpecularColor");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$EmissiveColorName$value", $.String, "EmissiveColor");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$DiffuseTextureName$value", $.String, "DiffuseTexture");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$SpecularTextureName$value", $.String, "SpecularTexture");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$EmissiveTextureName$value", $.String, "EmissiveTexture");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$BumpTextureName$value", $.String, "BumpTexture");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$DiffuseMixName$value", $.String, "DiffuseMix");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$SpecularMixName$value", $.String, "SpecularMix");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$EmissiveMixName$value", $.String, "EmissiveMix");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$SpecularShininessName$value", $.String, "SpecularShininess");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$SpecularIntensityName$value", $.String, "SpecularIntensity");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$BumpIntensityName$value", $.String, "BumpIntensity");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$LightDirectionName$value", $.String, "LightDirection");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$LightColorName$value", $.String, "LightColor");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ShaderCodeBuilder$LightIntensityName$value", $.String, "LightIntensity");


    function ShaderCodeBuilder__cctor () {
      $thisType.ShaderCodeBuilder$DiffuseColorName$value = "DiffuseColor";
      $thisType.ShaderCodeBuilder$SpecularColorName$value = "SpecularColor";
      $thisType.ShaderCodeBuilder$EmissiveColorName$value = "EmissiveColor";
      $thisType.ShaderCodeBuilder$DiffuseTextureName$value = "DiffuseTexture";
      $thisType.ShaderCodeBuilder$SpecularTextureName$value = "SpecularTexture";
      $thisType.ShaderCodeBuilder$EmissiveTextureName$value = "EmissiveTexture";
      $thisType.ShaderCodeBuilder$BumpTextureName$value = "BumpTexture";
      $thisType.ShaderCodeBuilder$DiffuseMixName$value = "DiffuseMix";
      $thisType.ShaderCodeBuilder$SpecularMixName$value = "SpecularMix";
      $thisType.ShaderCodeBuilder$EmissiveMixName$value = "EmissiveMix";
      $thisType.ShaderCodeBuilder$SpecularShininessName$value = "SpecularShininess";
      $thisType.ShaderCodeBuilder$SpecularIntensityName$value = "SpecularIntensity";
      $thisType.ShaderCodeBuilder$BumpIntensityName$value = "BumpIntensity";
      $thisType.ShaderCodeBuilder$LightDirectionName$value = "LightDirection";
      $thisType.ShaderCodeBuilder$LightColorName$value = "LightColor";
      $thisType.ShaderCodeBuilder$LightIntensityName$value = "LightIntensity";
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      ShaderCodeBuilder__cctor
    );

    $.Property({Static:false, Public:true }, "VS", $.String);

    $.Property({Static:false, Public:true }, "PS", $.String);

    $.Property({Static:true , Public:true }, "DiffuseColorName", $.String);

    $.Property({Static:true , Public:true }, "SpecularColorName", $.String);

    $.Property({Static:true , Public:true }, "EmissiveColorName", $.String);

    $.Property({Static:true , Public:true }, "DiffuseTextureName", $.String);

    $.Property({Static:true , Public:true }, "SpecularTextureName", $.String);

    $.Property({Static:true , Public:true }, "EmissiveTextureName", $.String);

    $.Property({Static:true , Public:true }, "BumpTextureName", $.String);

    $.Property({Static:true , Public:true }, "DiffuseMixName", $.String);

    $.Property({Static:true , Public:true }, "SpecularMixName", $.String);

    $.Property({Static:true , Public:true }, "EmissiveMixName", $.String);

    $.Property({Static:true , Public:true }, "SpecularShininessName", $.String);

    $.Property({Static:true , Public:true }, "SpecularIntensityName", $.String);

    $.Property({Static:true , Public:true }, "BumpIntensityName", $.String);

    $.Property({Static:true , Public:true }, "LightDirectionName", $.String);

    $.Property({Static:true , Public:true }, "LightColorName", $.String);

    $.Property({Static:true , Public:true }, "LightIntensityName", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GearConstraint */ 

(function GearConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.RigidBody)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_UserObject)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyA)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyB)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.GetUid)) ();
  };


  function GearConstraint__ctor () {
  }; 

  function GearConstraint_get_RigidBodyA () {
    var retval = $IM00().Call($IM01().Call(this._iGearConstraintImp, null), null);
    return $T03().$Cast(retval);
  }; 

  function GearConstraint_get_RigidBodyB () {
    var retval = $IM00().Call($IM02().Call(this._iGearConstraintImp, null), null);
    return $T03().$Cast(retval);
  }; 

  function GearConstraint_GetUid () {
    return $IM03().Call(this._iGearConstraintImp, null);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.GearConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      GearConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyA", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      GearConstraint_get_RigidBodyA
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyB", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      GearConstraint_get_RigidBodyB
    );

    $.Method({Static:false, Public:true }, "GetUid", 
      JSIL.MethodSignature.Return($.Int32), 
      GearConstraint_GetUid
    );

    $.Field({Static:false, Public:false}, "_iGearConstraintImp", $asm03.TypeRef("Fusee.Engine.Common.IGearConstraintImp"));

    $.Property({Static:false, Public:true }, "RigidBodyA", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));

    $.Property({Static:false, Public:true }, "RigidBodyB", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Generic6DofConstraint */ 

(function Generic6DofConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.RigidBody)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Void)) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.CalcAnchorPos)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.CalculateTransforms)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.get_AngularLowerLimit)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.get_AngularUpperLimit)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.get_CalculatedTransformA)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.get_CalculatedTransformB)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.get_FrameOffsetA)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.get_FrameOffsetB)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.get_LinearLowerLimit)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.get_LinearUpperLimit)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_UserObject)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyA)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyB)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.get_UseFrameOffset)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.GetAngle)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.GetAxis)) ();
  };
  var $IM10 = function () {
    return ($IM10 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.GetRelativePivotPosition)) ();
  };
  var $IM11 = function () {
    return ($IM11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.GetUid)) ();
  };
  var $IM12 = function () {
    return ($IM12 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.IsLimited)) ();
  };
  var $IM13 = function () {
    return ($IM13 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_UserObject)) ();
  };
  var $IM14 = function () {
    return ($IM14 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.set_UseFrameOffset)) ();
  };
  var $IM15 = function () {
    return ($IM15 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.SetAxis)) ();
  };
  var $IM16 = function () {
    return ($IM16 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.SetFrames)) ();
  };
  var $IM17 = function () {
    return ($IM17 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.SetLimit)) ();
  };
  var $IM18 = function () {
    return ($IM18 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.TestAngularLimitMotor)) ();
  };
  var $IM19 = function () {
    return ($IM19 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGeneric6DofConstraintImp.UpdateRhs)) ();
  };


  function Generic6DofConstraint__ctor () {
  }; 

  function Generic6DofConstraint_CalcAnchorPos () {
    $IM00().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_CalculateTransforms$00 () {
    $S00().CallVirtual($IM01(), null, this._IG6DofConstraintImp);
  }; 

  function Generic6DofConstraint_CalculateTransforms$01 (transA, transB) {
    $S01().CallVirtual($IM01(), null, this._IG6DofConstraintImp, transA.MemberwiseClone(), transB.MemberwiseClone());
  }; 

  function Generic6DofConstraint_get_AngularLowerLimit () {
    return $IM02().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_get_AngularUpperLimit () {
    return $IM03().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_get_CalculatedTransformA () {
    return $IM04().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_get_CalculatedTransformB () {
    return $IM05().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_get_FrameOffsetA () {
    return $IM06().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_get_FrameOffsetB () {
    return $IM07().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_get_LinearLowerLimit () {
    return $IM08().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_get_LinearUpperLimit () {
    return $IM09().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_get_RigidBodyA () {
    var retval = $IM0A().Call($IM0B().Call(this._IG6DofConstraintImp, null), null);
    return $T05().$Cast(retval);
  }; 

  function Generic6DofConstraint_get_RigidBodyB () {
    var retval = $IM0A().Call($IM0C().Call(this._IG6DofConstraintImp, null), null);
    return $T05().$Cast(retval);
  }; 

  function Generic6DofConstraint_get_UseFrameOffset () {
    return $IM0D().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_GetAngle (axisIndex) {
    return $IM0E().Call(this._IG6DofConstraintImp, null, axisIndex);
  }; 

  function Generic6DofConstraint_GetAxis (axisIndex) {
    return $IM0F().Call(this._IG6DofConstraintImp, null, axisIndex);
  }; 

  function Generic6DofConstraint_GetRelativePivotPosition (axisIndex) {
    return $IM10().Call(this._IG6DofConstraintImp, null, axisIndex);
  }; 

  function Generic6DofConstraint_GetUid () {
    return $IM11().Call(this._IG6DofConstraintImp, null);
  }; 

  function Generic6DofConstraint_IsLimited (limitIndex) {
    return $IM12().Call(this._IG6DofConstraintImp, null, limitIndex);
  }; 

  function Generic6DofConstraint_set_AngularLowerLimit (value) {
    var o = $thisType.$Cast($IM13().Call(this._IG6DofConstraintImp, null));
    (o._IG6DofConstraintImp.AngularLowerLimit = value.MemberwiseClone());
  }; 

  function Generic6DofConstraint_set_AngularUpperLimit (value) {
    var o = $thisType.$Cast($IM13().Call(this._IG6DofConstraintImp, null));
    (o._IG6DofConstraintImp.AngularUpperLimit = value.MemberwiseClone());
  }; 

  function Generic6DofConstraint_set_FrameOffsetA (value) {
    var o = $thisType.$Cast($IM13().Call(this._IG6DofConstraintImp, null));
    (o._IG6DofConstraintImp.FrameOffsetA = value.MemberwiseClone());
  }; 

  function Generic6DofConstraint_set_FrameOffsetB (value) {
    var o = $thisType.$Cast($IM13().Call(this._IG6DofConstraintImp, null));
    (o._IG6DofConstraintImp.FrameOffsetB = value.MemberwiseClone());
  }; 

  function Generic6DofConstraint_set_LinearLowerLimit (value) {
    var o = $thisType.$Cast($IM13().Call(this._IG6DofConstraintImp, null));
    (o._IG6DofConstraintImp.LinearLowerLimit = value.MemberwiseClone());
  }; 

  function Generic6DofConstraint_set_LinearUpperLimit (value) {
    var o = $thisType.$Cast($IM13().Call(this._IG6DofConstraintImp, null));
    (o._IG6DofConstraintImp.LinearUpperLimit = value.MemberwiseClone());
  }; 

  function Generic6DofConstraint_set_UseFrameOffset (value) {
    var o = $thisType.$Cast($IM13().Call(this._IG6DofConstraintImp, null));
    $IM14().Call(o._IG6DofConstraintImp, null, value);
  }; 

  function Generic6DofConstraint_SetAxis (axis1, axis2) {
    $IM15().Call(this._IG6DofConstraintImp, null, axis1.MemberwiseClone(), axis2.MemberwiseClone());
  }; 

  function Generic6DofConstraint_SetFrames (frameA, frameB) {
    $IM16().Call(this._IG6DofConstraintImp, null, frameA.MemberwiseClone(), frameB.MemberwiseClone());
  }; 

  function Generic6DofConstraint_SetLimit (axis, lo, hi) {
    $IM17().Call(this._IG6DofConstraintImp, null, axis, lo, hi);
  }; 

  function Generic6DofConstraint_TestAngularLimitMotor (axisIndex) {
    return $IM18().Call(this._IG6DofConstraintImp, null, axisIndex);
  }; 

  function Generic6DofConstraint_UpdateRhs (timeStep) {
    $IM19().Call(this._IG6DofConstraintImp, null, timeStep);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Generic6DofConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Generic6DofConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "CalcAnchorPos", 
      JSIL.MethodSignature.Void, 
      Generic6DofConstraint_CalcAnchorPos
    );

    $.Method({Static:false, Public:true }, "CalculateTransforms", 
      JSIL.MethodSignature.Void, 
      Generic6DofConstraint_CalculateTransforms$00
    );

    $.Method({Static:false, Public:true }, "CalculateTransforms", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4")]), 
      Generic6DofConstraint_CalculateTransforms$01
    );

    $.Method({Static:false, Public:true }, "get_AngularLowerLimit", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Generic6DofConstraint_get_AngularLowerLimit
    );

    $.Method({Static:false, Public:true }, "get_AngularUpperLimit", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Generic6DofConstraint_get_AngularUpperLimit
    );

    $.Method({Static:false, Public:true }, "get_CalculatedTransformA", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      Generic6DofConstraint_get_CalculatedTransformA
    );

    $.Method({Static:false, Public:true }, "get_CalculatedTransformB", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      Generic6DofConstraint_get_CalculatedTransformB
    );

    $.Method({Static:false, Public:true }, "get_FrameOffsetA", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      Generic6DofConstraint_get_FrameOffsetA
    );

    $.Method({Static:false, Public:true }, "get_FrameOffsetB", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      Generic6DofConstraint_get_FrameOffsetB
    );

    $.Method({Static:false, Public:true }, "get_LinearLowerLimit", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Generic6DofConstraint_get_LinearLowerLimit
    );

    $.Method({Static:false, Public:true }, "get_LinearUpperLimit", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Generic6DofConstraint_get_LinearUpperLimit
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyA", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      Generic6DofConstraint_get_RigidBodyA
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyB", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      Generic6DofConstraint_get_RigidBodyB
    );

    $.Method({Static:false, Public:true }, "get_UseFrameOffset", 
      JSIL.MethodSignature.Return($.Boolean), 
      Generic6DofConstraint_get_UseFrameOffset
    );

    $.Method({Static:false, Public:true }, "GetAngle", 
      new JSIL.MethodSignature($.Single, [$.Int32]), 
      Generic6DofConstraint_GetAngle
    );

    $.Method({Static:false, Public:true }, "GetAxis", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.float3"), [$.Int32]), 
      Generic6DofConstraint_GetAxis
    );

    $.Method({Static:false, Public:true }, "GetRelativePivotPosition", 
      new JSIL.MethodSignature($.Single, [$.Int32]), 
      Generic6DofConstraint_GetRelativePivotPosition
    );

    $.Method({Static:false, Public:true }, "GetUid", 
      JSIL.MethodSignature.Return($.Int32), 
      Generic6DofConstraint_GetUid
    );

    $.Method({Static:false, Public:true }, "IsLimited", 
      new JSIL.MethodSignature($.Boolean, [$.Int32]), 
      Generic6DofConstraint_IsLimited
    );

    $.Method({Static:false, Public:true }, "set_AngularLowerLimit", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Generic6DofConstraint_set_AngularLowerLimit
    );

    $.Method({Static:false, Public:true }, "set_AngularUpperLimit", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Generic6DofConstraint_set_AngularUpperLimit
    );

    $.Method({Static:false, Public:true }, "set_FrameOffsetA", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      Generic6DofConstraint_set_FrameOffsetA
    );

    $.Method({Static:false, Public:true }, "set_FrameOffsetB", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      Generic6DofConstraint_set_FrameOffsetB
    );

    $.Method({Static:false, Public:true }, "set_LinearLowerLimit", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Generic6DofConstraint_set_LinearLowerLimit
    );

    $.Method({Static:false, Public:true }, "set_LinearUpperLimit", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Generic6DofConstraint_set_LinearUpperLimit
    );

    $.Method({Static:false, Public:true }, "set_UseFrameOffset", 
      JSIL.MethodSignature.Action($.Boolean), 
      Generic6DofConstraint_set_UseFrameOffset
    );

    $.Method({Static:false, Public:true }, "SetAxis", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3")]), 
      Generic6DofConstraint_SetAxis
    );

    $.Method({Static:false, Public:true }, "SetFrames", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4")]), 
      Generic6DofConstraint_SetFrames
    );

    $.Method({Static:false, Public:true }, "SetLimit", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Single, 
          $.Single
        ]), 
      Generic6DofConstraint_SetLimit
    );

    $.Method({Static:false, Public:true }, "TestAngularLimitMotor", 
      new JSIL.MethodSignature($.Boolean, [$.Int32]), 
      Generic6DofConstraint_TestAngularLimitMotor
    );

    $.Method({Static:false, Public:true }, "UpdateRhs", 
      JSIL.MethodSignature.Action($.Single), 
      Generic6DofConstraint_UpdateRhs
    );

    $.Field({Static:false, Public:false}, "_IG6DofConstraintImp", $asm03.TypeRef("Fusee.Engine.Common.IGeneric6DofConstraintImp"));

    $.Property({Static:false, Public:true }, "AngularLowerLimit", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "AngularUpperLimit", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "CalculatedTransformA", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "CalculatedTransformB", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "FrameOffsetA", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "FrameOffsetB", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "LinearLowerLimit", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "LinearUpperLimit", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "UseFrameOffset", $.Boolean);

    $.Property({Static:false, Public:true }, "RigidBodyA", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));

    $.Property({Static:false, Public:true }, "RigidBodyB", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Face */ 

(function Face$Members () {
  var $, $thisType;

  function Face__ctor () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Face", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Face__ctor
    );

    $.Field({Static:false, Public:true }, "InxVert", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:true }, "InxNormal", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:true }, "InxTexCoord", $jsilcore.TypeRef("System.Array", [$.Int32]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Geometry */ 

(function Geometry$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.double3))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize(System.Array.Of($asm0E.System.Int32))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.Face)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.ArgumentNullException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.ArgumentException)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.double2))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.Face))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm09.Fusee.Math.Core.double3)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm09.Fusee.Math.Core.double2)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.FormatException)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.Double)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.Collections.Generic.IList$b1.Of($asm0E.System.Int32))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.Math)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm0E.System.Int32))) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0E.System.Int32))) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0E.System.Collections.IEnumerator)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.IDisposable)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0E.System.Collections.Generic.ICollection$b1.Of($asm0E.System.Int32))) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.Int32))) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0E.System.Collections.Generic.IList$b1.Of($asm04.Fusee.Engine.Core.Face))) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm0E.System.Collections.Generic.IList$b1.Of($asm09.Fusee.Math.Core.double3))) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm0E.System.Collections.Generic.IList$b1.Of($asm09.Fusee.Math.Core.double2))) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm04.Fusee.Engine.Core.Geometry_TripleInx, $asm0E.System.Int32))) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.UInt16))) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm04.Fusee.Engine.Core.Geometry_TripleInx)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0E.System.UInt16))) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt16))) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm0E.System.UInt16)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.double3), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentNullException, [$asm0E.System.String]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentException, [$asm0E.System.String, $asm0E.System.String]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.Face), null))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.Face")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.double3")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.double2), null))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.double2")]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.FormatException, [$asm0E.System.String]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.Int32), null))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.Int32")]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.Face), [$asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm04.TypeRef("Fusee.Engine.Core.Face")])]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.double3), [$asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm09.TypeRef("Fusee.Math.Core.double3")])]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.double2), [$asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm09.TypeRef("Fusee.Math.Core.double2")])]))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm04.Fusee.Engine.Core.Geometry_TripleInx, $asm0E.System.Int32), null))) ();
  };
  var $S0F = function () {
    return ($S0F = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.UInt16), null))) ();
  };
  var $S10 = function () {
    return ($S10 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.float3), null))) ();
  };
  var $S11 = function () {
    return ($S11 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.float2), null))) ();
  };
  var $S12 = function () {
    return ($S12 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S13 = function () {
    return ($S13 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float3, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S14 = function () {
    return ($S14 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float2")]))) ();
  };
  var $S15 = function () {
    return ($S15 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0E.System.Int32).GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0E.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm0E.System.Int32).get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0E.System.IDisposable.Dispose)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm0E.System.Collections.Generic.ICollection$b1.Of($asm0E.System.Int32).get_Count)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm0E.System.Collections.Generic.IList$b1.Of($asm0E.System.Int32).get_Item)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm0E.System.Collections.Generic.ICollection$b1.Of($asm0E.System.Int32).Add)) ();
  };


  function Geometry__ctor () {
    this._vertices = $S00().Construct();
  }; 

  function Geometry_AddFace (vertInx, texCoordInx, normalInx) {
    var f = new ($T02())();
    if (vertInx === null) {
      throw $S01().Construct("vertInx");
    }
    f.InxVert = JSIL.Array.New($T04(), vertInx.length);

    for (var i = 0; i < (vertInx.length | 0); i = ((i + 1) | 0)) {
      var vInx = (vertInx[i] | 0);
      var flag2 = (0 > vInx) || 
      (vInx >= ((this._vertices).get_Count() | 0));
      if (flag2) {
        throw $S02().Construct(JSIL.ConcatString("Vertex index out of range: ", $T04().$Box(vInx)), JSIL.ConcatString("vertInx[", $T04().$Box(i), "]"));
      }
      f.InxVert[i] = vInx;
    }
    if (texCoordInx !== null) {
      var flag4 = (texCoordInx.length | 0) !== (vertInx.length | 0);
      if (flag4) {
        throw $S02().Construct("Number of texture coordinate indices must match number of vertex indices", "texCoordInx");
      }
      f.InxTexCoord = JSIL.Array.New($T04(), texCoordInx.length);

      for (i = 0; i < (texCoordInx.length | 0); i = ((i + 1) | 0)) {
        var tInx = (texCoordInx[i] | 0);
        var flag5 = (0 > tInx) || 
        (tInx >= ((this._texCoords).get_Count() | 0));
        if (flag5) {
          throw $S02().Construct(JSIL.ConcatString("Texture coordinate index out of range: ", $T04().$Box(tInx)), JSIL.ConcatString("texCoordInx[", $T04().$Box(i), "]"));
        }
        f.InxTexCoord[i] = tInx;
      }
    }
    if (normalInx !== null) {
      var flag7 = (normalInx.length | 0) !== (vertInx.length | 0);
      if (flag7) {
        throw $S02().Construct("Number of normal indices must match number of vertex indices", "normalInx");
      }
      f.InxNormal = JSIL.Array.New($T04(), normalInx.length);

      for (i = 0; i < (normalInx.length | 0); i = ((i + 1) | 0)) {
        var nInx = (normalInx[i] | 0);
        var flag8 = (0 > nInx) || 
        (nInx >= ((this._normals).get_Count() | 0));
        if (flag8) {
          throw $S02().Construct(JSIL.ConcatString("Normal index out of range: ", $T04().$Box(nInx)), JSIL.ConcatString("normalInx[", $T04().$Box(i), "]"));
        }
        f.InxNormal[i] = nInx;
      }
    }
    if (this._faces === null) {
      this._faces = $S03().Construct();
    }
    $S04().CallVirtual("Add", null, this._faces, f);
    return ((((this._faces).get_Count() | 0) - 1) | 0);
  }; 

  function Geometry_AddNormal (normal) {
    if (this._normals === null) {
      this._normals = $S00().Construct();
    }
    $S05().CallVirtual("Add", null, this._normals, normal.MemberwiseClone());
    return ((((this._normals).get_Count() | 0) - 1) | 0);
  }; 

  function Geometry_AddTexCoord (uv) {
    if (this._texCoords === null) {
      this._texCoords = $S06().Construct();
    }
    $S07().CallVirtual("Add", null, this._texCoords, uv.MemberwiseClone());
    return ((((this._texCoords).get_Count() | 0) - 1) | 0);
  }; 

  function Geometry_AddVertex (v) {
    $S05().CallVirtual("Add", null, this._vertices, v.MemberwiseClone());
    return ((((this._vertices).get_Count() | 0) - 1) | 0);
  }; 

  function Geometry_CalcFaceNormal (f) {
    var flag = (f.InxVert.length | 0) < 3;
    if (flag) {
      throw $S08().Construct(JSIL.ConcatString("Cannot calculate normal of degenerate face with only ", $T04().$Box(f.InxVert.length), " vertices."));
    }
    var vertex0 = (f.InxVert[0] | 0);
    var v = $T0A().op_Subtraction(
      (this._vertices).get_Item(vertex0).MemberwiseClone(), 
      (this._vertices).get_Item(f.InxVert[2])
    );
    var v2 = $T0A().op_Subtraction(
      (this._vertices).get_Item(vertex0).MemberwiseClone(), 
      (this._vertices).get_Item(f.InxVert[1])
    );
    return $T0A().Normalize($T0A().Cross(v.MemberwiseClone(), v2.MemberwiseClone()).MemberwiseClone());
  }; 

  function Geometry_CreateNormals (smoothingAngle) {
    var $temp00;
    var vertInFace = new JSIL.BoxedVariable(null);
    var cSmoothingAngle = (Math.cos(smoothingAngle));
    this._normals = $S00().Construct();

    for (var iV = 0; iV < ((this._vertices).get_Count() | 0); iV = ((iV + 1) | 0)) {
      var facesWithIV = this.GetAllFacesContainingVertex(iV, /* ref */ vertInFace);
      var normals = $S00().Construct();
      var enumerator = $IM00().Call(facesWithIV, null);
      try {

        while ($IM01().Call(enumerator, null)) {
          var i = ($IM02().Call(enumerator, null) | 0);
          $S05().CallVirtual("Add", null, normals, this.CalcFaceNormal((this._faces).get_Item(i)).MemberwiseClone());
        }
      } finally {
        if (enumerator !== null) {
          $IM03().Call(enumerator, null);
        }
      }
      var smoothit = true;

    $loop2: 
      for (var j = 0; j < (normals.get_Count() | 0); j = ((j + 1) | 0)) {

      $loop3: 
        for (var k = ((j + 1) | 0); k < (normals.get_Count() | 0); k = ((k + 1) | 0)) {
          var flag = +$T0A().Dot(
            normals.get_Item(j), 
            normals.get_Item(k)
          ) < cSmoothingAngle;
          if (flag) {
            smoothit = false;
            break $loop3;
          }
        }
        var flag2 = !smoothit;
        if (flag2) {
          break $loop2;
        }
      }
      var flag3 = smoothit;
      if (flag3) {
        var double = new ($T0A())();
        double.x = 0;
        double.y = 0;
        double.z = 0;
        var daNormal = double;

        for (var a$0 = normals._items, i$0 = 0, l$0 = (normals._size | 0); i$0 < l$0; ($temp00 = i$0, 
            i$0 = ((i$0 + 1) | 0), 
            $temp00)) {
          var l = a$0[i$0];
          daNormal = $T0A().op_Addition(daNormal.MemberwiseClone(), l);
        }
        daNormal = $T0A().op_Division(daNormal.MemberwiseClone(), +(normals.get_Count()));
        var iN = (this.AddNormal(daNormal.MemberwiseClone()) | 0);

        for (var m = 0; m < ($IM04().Call(facesWithIV, null) | 0); m = ((m + 1) | 0)) {
          var flag4 = (this._faces).get_Item($IM05().Call(facesWithIV, null, m)).InxNormal === null;
          if (flag4) {
            (this._faces).get_Item($IM05().Call(facesWithIV, null, m)).InxNormal = JSIL.Array.New($T04(), (this._faces).get_Item($IM05().Call(facesWithIV, null, m)).InxVert.length);
          }
          (this._faces).get_Item($IM05().Call(facesWithIV, null, m)).InxNormal[$IM05().Call(vertInFace.get(), null, m)] = iN;
        }
      } else {

        for (var n = 0; n < (normals.get_Count() | 0); n = ((n + 1) | 0)) {
          var iN2 = (this.AddNormal(normals.get_Item(n).MemberwiseClone()) | 0);
          var flag5 = (this._faces).get_Item($IM05().Call(facesWithIV, null, n)).InxNormal === null;
          if (flag5) {
            (this._faces).get_Item($IM05().Call(facesWithIV, null, n)).InxNormal = JSIL.Array.New($T04(), (this._faces).get_Item($IM05().Call(facesWithIV, null, n)).InxVert.length);
          }
          (this._faces).get_Item($IM05().Call(facesWithIV, null, n)).InxNormal[$IM05().Call(vertInFace.get(), null, n)] = iN2;
        }
      }
    }
  }; 

  function Geometry_get_Faces () {
    return this._faces;
  }; 

  function Geometry_get_HasNormals () {
    return (this._normals !== null);
  }; 

  function Geometry_get_HasTexCoords () {
    return (this._texCoords !== null);
  }; 

  function Geometry_get_Normals () {
    return this._normals;
  }; 

  function Geometry_get_TexCoords () {
    return this._texCoords;
  }; 

  function Geometry_get_Vertices () {
    return this._vertices;
  }; 

  function Geometry_GetAllFacesContainingVertex (iV, /* ref */ vertInFace) {
    var ret = $S09().Construct();
    vertInFace.set($S09().Construct());

    for (var iF = 0; iF < ((this._faces).get_Count() | 0); iF = ((iF + 1) | 0)) {
      var inxVert = (this._faces).get_Item(iF).InxVert;

    $loop1: 
      for (var iFV = 0; iFV < (inxVert.length | 0); iFV = ((iFV + 1) | 0)) {
        var flag = (iV | 0) === (inxVert[iFV] | 0);
        if (flag) {
          $S0A().CallVirtual("Add", null, ret, iF);
          $IM06().Call(vertInFace.get(), null, iFV);
          break $loop1;
        }
      }
    }
    return ret;
  }; 

  function Geometry_set_Faces (value) {
    this._faces = $S0B().Construct(value);
  }; 

  function Geometry_set_Normals (value) {
    this._normals = $S0C().Construct(value);
  }; 

  function Geometry_set_TexCoords (value) {
    this._texCoords = $S0D().Construct(value);
  }; 

  function Geometry_set_Vertices (value) {
    this._vertices = $S0C().Construct(value);
  }; 

  function Geometry_ToMesh () {
    var $temp00;
    var inx = new JSIL.BoxedVariable(0);
    var _vDict = $S0E().Construct();
    var mTris = $S0F().Construct();
    var mVerts = $S10().Construct();
    var mTexCoords = (
      this.get_HasTexCoords()
         ? $S11().Construct()
         : null)
    ;
    var mNormals = (
      this.get_HasNormals()
         ? $S10().Construct()
         : null)
    ;

    for (var a$0 = this._faces._items, i$0 = 0, l$0 = (this._faces._size | 0); i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var f = a$0[i$0];
      var mFace = JSIL.Array.New($T04(), f.InxVert.length);

      for (var i = 0; i < (f.InxVert.length | 0); i = ((i + 1) | 0)) {
        var tripleInx = new ($T1D())();
        tripleInx.iV = (f.InxVert[i] | 0);
        tripleInx.iT = ((
          this.get_HasTexCoords()
             ? f.InxTexCoord[i]
             : 0)
         | 0);
        tripleInx.iN = ((
          this.get_HasNormals()
             ? f.InxNormal[i]
             : 0)
         | 0);
        var ti = tripleInx;
        var flag = !_vDict.TryGetValue(ti.MemberwiseClone(), /* ref */ inx);
        if (flag) {
          var vInx = (f.InxVert[i] | 0);
          $S12().CallVirtual("Add", null, mVerts, $S13().Construct(Math.fround((this._vertices).get_Item(vInx).x), Math.fround((this._vertices).get_Item(vInx).y), Math.fround((this._vertices).get_Item(vInx).z)));
          var hasTexCoords = this.get_HasTexCoords();
          if (hasTexCoords) {
            var tInx = (f.InxTexCoord[i] | 0);
            $S14().CallVirtual("Add", null, mTexCoords, $S15().Construct(Math.fround((this._texCoords).get_Item(tInx).x), Math.fround((this._texCoords).get_Item(tInx).y)));
          }
          var hasNormals = this.get_HasNormals();
          if (hasNormals) {
            var nInx = (f.InxNormal[i] | 0);
            $S12().CallVirtual("Add", null, mNormals, $S13().Construct(Math.fround((this._normals).get_Item(nInx).x), Math.fround((this._normals).get_Item(nInx).y), Math.fround((this._normals).get_Item(nInx).z)));
          }
          inx.set((((mVerts.get_Count() | 0) - 1) | 0));
          _vDict.Add(ti.MemberwiseClone(), inx.get());
        }
        mFace[i] = (inx.get() | 0);
      }
      $T1A().prototype.AddRange.call(mTris, this.Triangulate(f, mFace));
    }
    var j = new ($T20())();
    j.set_Vertices($T1B().prototype.ToArray.call(mVerts));
    var hasNormals2 = this.get_HasNormals();
    if (hasNormals2) {
      j.set_Normals($T1B().prototype.ToArray.call(mNormals));
    }
    var hasTexCoords2 = this.get_HasTexCoords();
    if (hasTexCoords2) {
      j.set_UVs($T1C().prototype.ToArray.call(mTexCoords));
    }
    j.set_Triangles($T1A().prototype.ToArray.call(mTris));
    return j;
  }; 

  function Geometry_Triangulate (f, indices) {
    var flag = (f.InxVert.length | 0) < 3;
    if (flag) {
      var result = null;
    } else {
      var flag2 = indices === null;
      if (flag2) {
        indices = f.InxVert;
      }
      var ret = JSIL.Array.New($T23(), Math.imul(3, (((f.InxVert.length | 0) - 2) | 0)));

      for (var i = 2; i < (f.InxVert.length | 0); i = ((i + 1) | 0)) {
        ret[Math.imul(((i - 2) | 0), 3)] = (indices[0] & 0xFFFF);
        ret[((Math.imul(((i - 2) | 0), 3) + 1) | 0)] = (indices[((i - 1) | 0)] & 0xFFFF);
        ret[((Math.imul(((i - 2) | 0), 3) + 2) | 0)] = (indices[i] & 0xFFFF);
      }
      result = $T21().$Cast(ret);
    }
    return result;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Geometry", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Geometry__ctor
    );

    $.Method({Static:false, Public:true }, "AddFace", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Int32]), $jsilcore.TypeRef("System.Array", [$.Int32]), 
          $jsilcore.TypeRef("System.Array", [$.Int32])
        ]), 
      Geometry_AddFace
    );

    $.Method({Static:false, Public:true }, "AddNormal", 
      new JSIL.MethodSignature($.Int32, [$asm09.TypeRef("Fusee.Math.Core.double3")]), 
      Geometry_AddNormal
    );

    $.Method({Static:false, Public:true }, "AddTexCoord", 
      new JSIL.MethodSignature($.Int32, [$asm09.TypeRef("Fusee.Math.Core.double2")]), 
      Geometry_AddTexCoord
    );

    $.Method({Static:false, Public:true }, "AddVertex", 
      new JSIL.MethodSignature($.Int32, [$asm09.TypeRef("Fusee.Math.Core.double3")]), 
      Geometry_AddVertex
    );

    $.Method({Static:false, Public:true }, "CalcFaceNormal", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.double3"), [$asm04.TypeRef("Fusee.Engine.Core.Face")]), 
      Geometry_CalcFaceNormal
    );

    $.Method({Static:false, Public:true }, "CreateNormals", 
      JSIL.MethodSignature.Action($.Double), 
      Geometry_CreateNormals
    );

    $.Method({Static:false, Public:true }, "get_Faces", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm04.TypeRef("Fusee.Engine.Core.Face")])), 
      Geometry_get_Faces
    );

    $.Method({Static:false, Public:true }, "get_HasNormals", 
      JSIL.MethodSignature.Return($.Boolean), 
      Geometry_get_HasNormals
    );

    $.Method({Static:false, Public:true }, "get_HasTexCoords", 
      JSIL.MethodSignature.Return($.Boolean), 
      Geometry_get_HasTexCoords
    );

    $.Method({Static:false, Public:true }, "get_Normals", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm09.TypeRef("Fusee.Math.Core.double3")])), 
      Geometry_get_Normals
    );

    $.Method({Static:false, Public:true }, "get_TexCoords", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm09.TypeRef("Fusee.Math.Core.double2")])), 
      Geometry_get_TexCoords
    );

    $.Method({Static:false, Public:true }, "get_Vertices", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm09.TypeRef("Fusee.Math.Core.double3")])), 
      Geometry_get_Vertices
    );

    $.Method({Static:false, Public:true }, "GetAllFacesContainingVertex", 
      new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IList`1", [$.Int32]), [$.Int32, $jsilcore.TypeRef("JSIL.Reference", [$asm0E.TypeRef("System.Collections.Generic.IList`1", [$.Int32])])]), 
      Geometry_GetAllFacesContainingVertex
    );

    $.Method({Static:false, Public:true }, "set_Faces", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm04.TypeRef("Fusee.Engine.Core.Face")])), 
      Geometry_set_Faces
    );

    $.Method({Static:false, Public:true }, "set_Normals", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm09.TypeRef("Fusee.Math.Core.double3")])), 
      Geometry_set_Normals
    );

    $.Method({Static:false, Public:true }, "set_TexCoords", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm09.TypeRef("Fusee.Math.Core.double2")])), 
      Geometry_set_TexCoords
    );

    $.Method({Static:false, Public:true }, "set_Vertices", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm09.TypeRef("Fusee.Math.Core.double3")])), 
      Geometry_set_Vertices
    );

    $.Method({Static:false, Public:true }, "ToMesh", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      Geometry_ToMesh
    );

    $.Method({Static:false, Public:false}, "Triangulate", 
      new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$.UInt16]), [$asm04.TypeRef("Fusee.Engine.Core.Face"), $jsilcore.TypeRef("System.Array", [$.Int32])]), 
      Geometry_Triangulate
    );

    $.Field({Static:false, Public:false}, "_vertices", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm09.TypeRef("Fusee.Math.Core.double3")]));

    $.Field({Static:false, Public:false}, "_normals", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm09.TypeRef("Fusee.Math.Core.double3")]));

    $.Field({Static:false, Public:false}, "_texCoords", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm09.TypeRef("Fusee.Math.Core.double2")]));

    $.Field({Static:false, Public:false}, "_faces", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm04.TypeRef("Fusee.Engine.Core.Face")]));

    $.Property({Static:false, Public:true }, "Vertices", $asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm09.TypeRef("Fusee.Math.Core.double3")]));

    $.Property({Static:false, Public:true }, "Normals", $asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm09.TypeRef("Fusee.Math.Core.double3")]));

    $.Property({Static:false, Public:true }, "TexCoords", $asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm09.TypeRef("Fusee.Math.Core.double2")]));

    $.Property({Static:false, Public:true }, "Faces", $asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm04.TypeRef("Fusee.Engine.Core.Face")]));

    $.Property({Static:false, Public:true }, "HasNormals", $.Boolean);

    $.Property({Static:false, Public:true }, "HasTexCoords", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Engine.Core.Geometry+TripleInx */ 

(function TripleInx$Members () {
  var $, $thisType;

  function TripleInx_GetHashCode () {
    return (((this.iV | 0) ^ (this.iT | 0)) ^ (this.iN | 0));
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.ValueType"), 
      Name: "Fusee.Engine.Core.Geometry+TripleInx", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      TripleInx_GetHashCode
    );

    $.Field({Static:false, Public:true }, "iV", $.Int32);

    $.Field({Static:false, Public:true }, "iT", $.Int32);

    $.Field({Static:false, Public:true }, "iN", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GImpactMeshShape */ 

(function GImpactMeshShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function GImpactMeshShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function GImpactMeshShape_get_Margin () {
    return $IM00().Call(this._gImpactMeshShapeImp, null);
  }; 

  function GImpactMeshShape_set_Margin (value) {
    var o = $thisType.$Cast($IM01().Call(this._gImpactMeshShapeImp, null));
    $IM02().Call(o._gImpactMeshShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.GImpactMeshShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      GImpactMeshShape__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      GImpactMeshShape_get_Margin
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      GImpactMeshShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_gImpactMeshShapeImp", $asm03.TypeRef("Fusee.Engine.Common.IGImpactMeshShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.HingeConstraint */ 

(function HingeConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm04.Fusee.Engine.Core.RigidBody)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm09.Fusee.Math.Core.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Return($asm0E.TypeRef("System.Single")))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Single, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.Fusee.Math.Core.Quaternion, $asm0E.System.Single]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_UserObject)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.EnableAngularMotor)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.get_FrameA)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.get_AngularOnly)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.get_FrameB)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.get_EnableMotor)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.get_LowerLimit)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.get_MaxMotorImpulse)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.get_MotorTargetVelocity)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_UserObject)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyA)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyB)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.get_SolverLimit)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.GetHingeAngle)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.GetUid)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.set_AngularOnly)) ();
  };
  var $IM10 = function () {
    return ($IM10 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.set_EnableMotor)) ();
  };
  var $IM11 = function () {
    return ($IM11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.set_MaxMotorImpulse)) ();
  };
  var $IM12 = function () {
    return ($IM12 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.SetAxis)) ();
  };
  var $IM13 = function () {
    return ($IM13 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.SetLimit)) ();
  };
  var $IM14 = function () {
    return ($IM14 = JSIL.Memoize($asm03.Fusee.Engine.Common.IHingeConstraintImp.SetMotorTarget)) ();
  };


  function HingeConstraint__ctor () {
  }; 

  function HingeConstraint_EnableAngularMotor (enableMotor, targetVelocity, maxMotorImpulse) {
    var o = $thisType.$Cast($IM00().Call(this._iHConstraintImp, null));
    $IM01().Call(o._iHConstraintImp, null, enableMotor, targetVelocity, maxMotorImpulse);
  }; 

  function HingeConstraint_get_AFrame () {
    return $IM02().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_get_AngularOnly () {
    return $IM03().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_get_BFrame () {
    return $IM04().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_get_EnableMotor () {
    return $IM05().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_get_GetLowerLimit () {
    return $IM06().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_get_GetUpperLimit () {
    return $IM06().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_get_MaxMotorImpulse () {
    return $IM07().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_get_MotorTargetVelocity () {
    return $IM08().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_get_RigidBodyA () {
    var retval = $IM09().Call($IM0A().Call(this._iHConstraintImp, null), null);
    return $T06().$Cast(retval);
  }; 

  function HingeConstraint_get_RigidBodyB () {
    var retval = $IM09().Call($IM0B().Call(this._iHConstraintImp, null), null);
    return $T06().$Cast(retval);
  }; 

  function HingeConstraint_get_SolverLimit () {
    return $IM0C().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_GetHingeAngle$00 () {
    return $S00().CallVirtual($IM0D(), null, this._iHConstraintImp);
  }; 

  function HingeConstraint_GetHingeAngle$01 (transA, transB) {
    return $S01().CallVirtual($IM0D(), null, this._iHConstraintImp, transA.MemberwiseClone(), transB.MemberwiseClone());
  }; 

  function HingeConstraint_GetUid () {
    return $IM0E().Call(this._iHConstraintImp, null);
  }; 

  function HingeConstraint_set_AngularOnly (value) {
    var o = $thisType.$Cast($IM00().Call(this._iHConstraintImp, null));
    $IM0F().Call(o._iHConstraintImp, null, value);
  }; 

  function HingeConstraint_set_EnableMotor (value) {
    var o = $thisType.$Cast($IM00().Call(this._iHConstraintImp, null));
    $IM10().Call(o._iHConstraintImp, null, value);
  }; 

  function HingeConstraint_set_MaxMotorImpulse (value) {
    var o = $thisType.$Cast($IM00().Call(this._iHConstraintImp, null));
    $IM11().Call(o._iHConstraintImp, null, value);
  }; 

  function HingeConstraint_SetAxis (axisInA) {
    var o = $thisType.$Cast($IM00().Call(this._iHConstraintImp, null));
    $IM12().Call(this._iHConstraintImp, null, axisInA.MemberwiseClone());
  }; 

  function HingeConstraint_SetLimit (low, high, softness, biasFactor, relaxationFactor) {
    $IM13().Call(this._iHConstraintImp, null, 
      low, 
      high, 
      softness, 
      biasFactor, 
      relaxationFactor
    );
  }; 

  function HingeConstraint_SetMotorTarget$02 (qAinB, dt) {
    var o = $thisType.$Cast($IM00().Call(this._iHConstraintImp, null));
    $S02().CallVirtual($IM14(), null, o._iHConstraintImp, qAinB.MemberwiseClone(), dt);
  }; 

  function HingeConstraint_SetMotorTarget$03 (targetAngle, dt) {
    var o = $thisType.$Cast($IM00().Call(this._iHConstraintImp, null));
    $S03().CallVirtual($IM14(), null, o._iHConstraintImp, targetAngle, dt);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.HingeConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      HingeConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "EnableAngularMotor", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.Single, 
          $.Single
        ]), 
      HingeConstraint_EnableAngularMotor
    );

    $.Method({Static:false, Public:true }, "get_AFrame", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      HingeConstraint_get_AFrame
    );

    $.Method({Static:false, Public:true }, "get_AngularOnly", 
      JSIL.MethodSignature.Return($.Boolean), 
      HingeConstraint_get_AngularOnly
    );

    $.Method({Static:false, Public:true }, "get_BFrame", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      HingeConstraint_get_BFrame
    );

    $.Method({Static:false, Public:true }, "get_EnableMotor", 
      JSIL.MethodSignature.Return($.Boolean), 
      HingeConstraint_get_EnableMotor
    );

    $.Method({Static:false, Public:true }, "get_GetLowerLimit", 
      JSIL.MethodSignature.Return($.Single), 
      HingeConstraint_get_GetLowerLimit
    );

    $.Method({Static:false, Public:true }, "get_GetUpperLimit", 
      JSIL.MethodSignature.Return($.Single), 
      HingeConstraint_get_GetUpperLimit
    );

    $.Method({Static:false, Public:true }, "get_MaxMotorImpulse", 
      JSIL.MethodSignature.Return($.Single), 
      HingeConstraint_get_MaxMotorImpulse
    );

    $.Method({Static:false, Public:true }, "get_MotorTargetVelocity", 
      JSIL.MethodSignature.Return($.Single), 
      HingeConstraint_get_MotorTargetVelocity
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyA", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      HingeConstraint_get_RigidBodyA
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyB", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      HingeConstraint_get_RigidBodyB
    );

    $.Method({Static:false, Public:true }, "get_SolverLimit", 
      JSIL.MethodSignature.Return($.Int32), 
      HingeConstraint_get_SolverLimit
    );

    $.Method({Static:false, Public:true }, "GetHingeAngle", 
      JSIL.MethodSignature.Return($.Single), 
      HingeConstraint_GetHingeAngle$00
    );

    $.Method({Static:false, Public:true }, "GetHingeAngle", 
      new JSIL.MethodSignature($.Single, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4")]), 
      HingeConstraint_GetHingeAngle$01
    );

    $.Method({Static:false, Public:true }, "GetUid", 
      JSIL.MethodSignature.Return($.Int32), 
      HingeConstraint_GetUid
    );

    $.Method({Static:false, Public:true }, "set_AngularOnly", 
      JSIL.MethodSignature.Action($.Boolean), 
      HingeConstraint_set_AngularOnly
    );

    $.Method({Static:false, Public:true }, "set_EnableMotor", 
      JSIL.MethodSignature.Action($.Boolean), 
      HingeConstraint_set_EnableMotor
    );

    $.Method({Static:false, Public:true }, "set_MaxMotorImpulse", 
      JSIL.MethodSignature.Action($.Single), 
      HingeConstraint_set_MaxMotorImpulse
    );

    $.Method({Static:false, Public:true }, "SetAxis", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      HingeConstraint_SetAxis
    );

    $.Method({Static:false, Public:true }, "SetLimit", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ]), 
      HingeConstraint_SetLimit
    );

    $.Method({Static:false, Public:true }, "SetMotorTarget", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.Quaternion"), $.Single]), 
      HingeConstraint_SetMotorTarget$02
    );

    $.Method({Static:false, Public:true }, "SetMotorTarget", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      HingeConstraint_SetMotorTarget$03
    );

    $.Field({Static:false, Public:false}, "_iHConstraintImp", $asm03.TypeRef("Fusee.Engine.Common.IHingeConstraintImp"));

    $.Property({Static:false, Public:true }, "AngularOnly", $.Boolean);

    $.Property({Static:false, Public:true }, "EnableMotor", $.Boolean);

    $.Property({Static:false, Public:true }, "MaxMotorImpulse", $.Single);

    $.Property({Static:false, Public:true }, "MotorTargetVelocity", $.Single);

    $.Property({Static:false, Public:true }, "AFrame", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "BFrame", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "SolverLimit", $.Int32);

    $.Property({Static:false, Public:true }, "GetLowerLimit", $.Single);

    $.Property({Static:false, Public:true }, "GetUpperLimit", $.Single);

    $.Property({Static:false, Public:true }, "RigidBodyA", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));

    $.Property({Static:false, Public:true }, "RigidBodyB", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.DeviceConnectionArgs */ 

(function DeviceConnectionArgs$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.EventArgs)) ();
  };


  function DeviceConnectionArgs__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.EventArgs"), 
      Name: "Fusee.Engine.Core.DeviceConnectionArgs", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      DeviceConnectionArgs__ctor
    );

    $.Field({Static:false, Public:true }, "InputDevice", $asm04.TypeRef("Fusee.Engine.Core.InputDevice"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate Fusee.Engine.Core.MatchFunc */ 

JSIL.MakeDelegate("Fusee.Engine.Core.MatchFunc", true, [], 
  new JSIL.MethodSignature($asm0E.TypeRef("System.Boolean"), [$asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")]));

/* delegate Fusee.Engine.Core.CreatorFunc */ 

JSIL.MakeDelegate("Fusee.Engine.Core.CreatorFunc", true, [], 
  new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.InputDevice"), [$asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")]));

/* class Fusee.Engine.Core.SpecialDeviceCreator */ 

(function SpecialDeviceCreator$Members () {
  var $, $thisType;

  function SpecialDeviceCreator__ctor () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.SpecialDeviceCreator", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      SpecialDeviceCreator__ctor
    );

    $.Field({Static:false, Public:true }, "Match", $asm04.TypeRef("Fusee.Engine.Core.MatchFunc"));

    $.Field({Static:false, Public:true }, "Creator", $asm04.TypeRef("Fusee.Engine.Core.CreatorFunc"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Input */ 

(function Input$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.MatchFunc)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.CreatorFunc)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm03.Fusee.Engine.Common.IInputDriverImp))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm04.Fusee.Engine.Core.InputDevice))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.SpecialDeviceCreator))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.Input_$l$gc)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm04.Fusee.Engine.Core.DeviceConnectionArgs))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Threading.Monitor)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Delegate)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.Threading.Interlocked)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDriverImp)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.ArgumentNullException)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.IInputDeviceImp))) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.IInputDeviceImp))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.Collections.IEnumerator)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0E.System.IDisposable)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.DeviceImpDisconnectedArgs))) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.NewDeviceImpConnectedArgs))) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm04.Fusee.Engine.Core.SpecialDeviceCreator)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2_ValueCollection_Enumerator.Of($asm0E.System.String, $asm04.Fusee.Engine.Core.InputDevice))) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2_ValueCollection.Of($asm0E.System.String, $asm04.Fusee.Engine.Core.InputDevice))) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm04.Fusee.Engine.Core.DeviceConnectionArgs)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2_ValueCollection_Enumerator.Of($asm0E.System.String, $asm03.Fusee.Engine.Common.IInputDriverImp))) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2_ValueCollection.Of($asm0E.System.String, $asm03.Fusee.Engine.Common.IInputDriverImp))) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm04.Fusee.Engine.Core.KeyboardDevice)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm04.Fusee.Engine.Core.MouseDevice)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm04.Fusee.Engine.Core.TouchDevice)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm0E.System.Type)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm14.System.Linq.Enumerable)) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm03.Fusee.Engine.Common.DeviceImpDisconnectedArgs)) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm0E.System.InvalidOperationException)) ();
  };
  var $T25 = function () {
    return ($T25 = JSIL.Memoize($asm03.Fusee.Engine.Common.NewDeviceImpConnectedArgs)) ();
  };
  var $T26 = function () {
    return ($T26 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm04.Fusee.Engine.Core.InputDevice))) ();
  };
  var $T27 = function () {
    return ($T27 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm04.Fusee.Engine.Core.InputDevice))) ();
  };
  var $T28 = function () {
    return ($T28 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.String))) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm03.Fusee.Engine.Common.IInputDriverImp), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm04.Fusee.Engine.Core.InputDevice), null))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.SpecialDeviceCreator), null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Boolean, [$asm03.Fusee.Engine.Common.IInputDeviceImp]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm04.Fusee.Engine.Core.InputDevice, [$asm03.Fusee.Engine.Common.IInputDeviceImp]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Boolean, [$asm03.Fusee.Engine.Common.IInputDeviceImp]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm04.Fusee.Engine.Core.InputDevice, [$asm03.Fusee.Engine.Common.IInputDeviceImp]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Boolean, [$asm03.Fusee.Engine.Common.IInputDeviceImp]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm04.Fusee.Engine.Core.InputDevice, [$asm03.Fusee.Engine.Common.IInputDeviceImp]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentNullException, [$asm0E.System.String]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.DeviceImpDisconnectedArgs]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.NewDeviceImpConnectedArgs]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature("!!0", [$asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"])], ["TSource"]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.InvalidOperationException, [$asm0E.System.String]))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentNullException, [$asm0E.System.String, $asm0E.System.String]))) ();
  };
  var $S0F = function () {
    return ($S0F = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.SpecialDeviceCreator")]))) ();
  };
  var $S10 = function () {
    return ($S10 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.String), null))) ();
  };
  var $S11 = function () {
    return ($S11 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.String")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.IInputDeviceImp).GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDriverImp.get_Devices)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0E.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.IInputDeviceImp).get_Current)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDriverImp.get_DriverId)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.get_Id)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm0E.System.IDisposable.Dispose)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDriverImp.add_DeviceDisconnected)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDriverImp.add_NewDeviceConnected)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm04.Fusee.Engine.Core.InputDevice).GetEnumerator)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm04.Fusee.Engine.Core.InputDevice).get_Current)) ();
  };


  function Input__ctor () {
    var arg_68_1 = null, arg_68_2 = null, arg_AD_1 = null, arg_AD_2 = null, arg_F2_1 = null, arg_F2_2 = null;
    this._inputDrivers = $S00().Construct();
    this._inputDevices = $S01().Construct();
    this._specialDeviceCreators = $S02().Construct();
    if ((arg_68_1 = $T05().$l$g9__39_0) === null) {
      arg_68_1 = $T05().$l$g9__39_0 = $T00().New($T05().$l$g9, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.Input_$l$gc, "$l_ctor$gb__39_0", $S03(), false, false));
    }
    if ((arg_68_2 = $T05().$l$g9__39_1) === null) {
      arg_68_2 = $T05().$l$g9__39_1 = $T01().New($T05().$l$g9, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.Input_$l$gc, "$l_ctor$gb__39_1", $S04(), false, false));
    }
    this.RegisterInputDeviceType(arg_68_1, arg_68_2);
    if ((arg_AD_1 = $T05().$l$g9__39_2) === null) {
      arg_AD_1 = $T05().$l$g9__39_2 = $T00().New($T05().$l$g9, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.Input_$l$gc, "$l_ctor$gb__39_2", $S05(), false, false));
    }
    if ((arg_AD_2 = $T05().$l$g9__39_3) === null) {
      arg_AD_2 = $T05().$l$g9__39_3 = $T01().New($T05().$l$g9, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.Input_$l$gc, "$l_ctor$gb__39_3", $S06(), false, false));
    }
    this.RegisterInputDeviceType(arg_AD_1, arg_AD_2);
    if ((arg_F2_1 = $T05().$l$g9__39_4) === null) {
      arg_F2_1 = $T05().$l$g9__39_4 = $T00().New($T05().$l$g9, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.Input_$l$gc, "$l_ctor$gb__39_4", $S07(), false, false));
    }
    if ((arg_F2_2 = $T05().$l$g9__39_5) === null) {
      arg_F2_2 = $T05().$l$g9__39_5 = $T01().New($T05().$l$g9, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.Input_$l$gc, "$l_ctor$gb__39_5", $S08(), false, false));
    }
    this.RegisterInputDeviceType(arg_F2_1, arg_F2_2);
  }; 

  function Input_add_DeviceConnected (value) {
    var inputDeviceConnected = $thisType.get_Instance().InputDeviceConnected;
    var flag = new JSIL.BoxedVariable(false);
    try {
      $T08().Enter(inputDeviceConnected, /* ref */ flag);
      $thisType.get_Instance().add_InputDeviceConnected(value);
    } finally {
      if (flag.get()) {
        $T08().Exit(inputDeviceConnected);
      }
    }
  }; 

  function Input_add_DeviceDisconnected (value) {
    var inputDeviceDisconnected = $thisType.get_Instance().InputDeviceDisconnected;
    var flag = new JSIL.BoxedVariable(false);
    try {
      $T08().Enter(inputDeviceDisconnected, /* ref */ flag);
      $thisType.get_Instance().add_InputDeviceDisconnected(value);
    } finally {
      if (flag.get()) {
        $T08().Exit(inputDeviceDisconnected);
      }
    }
  }; 

  function Input_add_InputDeviceConnected (value) {
    var eventHandler = this.InputDeviceConnected;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T09().Combine(eventHandler2, value);
      eventHandler = $T0A().CompareExchange$b1($T06())(/* ref */ new JSIL.MemberReference(this, "InputDeviceConnected"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  function Input_add_InputDeviceDisconnected (value) {
    var eventHandler = this.InputDeviceDisconnected;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T09().Combine(eventHandler2, value);
      eventHandler = $T0A().CompareExchange$b1($T06())(/* ref */ new JSIL.MemberReference(this, "InputDeviceDisconnected"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  function Input_AddDriverImp (inputDriver) {
    $thisType.get_Instance().AddInputDriverImp(inputDriver);
  }; 

  function Input_AddInputDriverImp (inputDriver) {
    var flag = inputDriver === null;
    if (flag) {
      throw $S09().Construct("inputDriver");
    }
    var enumerator = $IM00().Call($IM01().Call(inputDriver, null), null);
    try {

      while ($IM02().Call(enumerator, null)) {
        var deviceImp = $IM03().Call(enumerator, null);
        (this._inputDevices).set_Item(
          ($IM04().Call(inputDriver, null) + "_" + $IM05().Call(deviceImp, null)), 
          this.CreateInputDevice(deviceImp)
        );
      }
    } finally {
      if (enumerator !== null) {
        $IM06().Call(enumerator, null);
      }
    }
    $IM07().Call(inputDriver, null, $T13().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnDeviceImpDisconnected", $S0A(), false, false)));
    $IM08().Call(inputDriver, null, $T14().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnNewDeviceImpConnected", $S0B(), false, false)));
    (this._inputDrivers).set_Item($IM04().Call(inputDriver, null), inputDriver);
  }; 

  function Input_CreateInputDevice (imp) {
    var $temp00;

    for (var a$0 = this._specialDeviceCreators._items, i$0 = 0, l$0 = (this._specialDeviceCreators._size | 0); i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var sdc = a$0[i$0];
      var flag = sdc.Match(imp);
      if (flag) {
        var ret = sdc.Creator(imp);
        if (ret !== null) {
          var result = ret;
          return result;
        }
      }
    }
    result = new ($T17())(imp);
    return result;
  }; 

  function Input_Dispose () {
    var enumerator = ((this._inputDevices).get_Values()).GetEnumerator();

    while ($T18().prototype.MoveNext.call(enumerator)) {
      var device = $T18().prototype.get_Current.call(enumerator);
      var expr_24 = this.InputDeviceDisconnected;
      if (expr_24 !== null) {
        var expr_30 = new ($T1A())();
        expr_30.InputDevice = device;
        expr_24(this, expr_30);
      }
      device.Disconnect();
    }
    (this._inputDevices).Clear();
    var enumerator2 = ((this._inputDrivers).get_Values()).GetEnumerator();

    while ($T1B().prototype.MoveNext.call(enumerator2)) {
      var driver = $T1B().prototype.get_Current.call(enumerator2);
      $IM06().Call(driver, null);
    }
    (this._inputDrivers).Clear();
  }; 

  function Input_get_Devices () {
    return $thisType.get_Instance()._inputDevices.get_Values();
  }; 

  function Input_get_Drivers () {
    return $thisType.get_Instance()._inputDrivers.get_Values();
  }; 

  function Input_get_InputDevices () {
    return (this._inputDevices).get_Values();
  }; 

  function Input_get_InputDrivers () {
    return (this._inputDrivers).get_Values();
  }; 

  function Input_get_Instance () {
    var arg_14_0 = null;
    if ((arg_14_0 = $thisType._instance) === null) {
      arg_14_0 = $thisType._instance = new $thisType();
    }
    return arg_14_0;
  }; 

  function Input_get_Keyboard () {
    return $thisType.get_Instance().get_KeyboardInput();
  }; 

  function Input_get_KeyboardInput () {
    return this.GetInputDevice$b1($T1D())();
  }; 

  function Input_get_Mouse () {
    return $thisType.get_Instance().get_MouseInput();
  }; 

  function Input_get_MouseInput () {
    return this.GetInputDevice$b1($T1E())();
  }; 

  function Input_get_Touch () {
    return $thisType.get_Instance().get_TouchInput();
  }; 

  function Input_get_TouchInput () {
    return this.GetInputDevice$b1($T1F())();
  }; 

  function Input_GetDevice$b1 (TDevice) {
    return $thisType.get_Instance().GetInputDevice$b1(TDevice)();
  }; 

  function Input_GetDevices$b1 (TDevice) {
    return $thisType.get_Instance().GetInputDevices$b1(TDevice)();
  }; 

  function Input_GetInputDevice$b1 (TDevice) {
    return $S0C().CallStatic($T21(), "FirstOrDefault$b1", [TDevice], $T21().OfType$b1(TDevice)((this._inputDevices).get_Values()));
  }; 

  function Input_GetInputDevices$b1 (TDevice) {
    return $T21().OfType$b1(TDevice)((this._inputDevices).get_Values());
  }; 

  function Input_OnDeviceImpDisconnected (sender, args) {
    var existingDevice = new JSIL.BoxedVariable(null);
    if (sender === null) {
      throw $S09().Construct("sender");
    }
    var driver = $T0B().$As(sender);
    var flag2 = driver === null;
    if (flag2) {
      throw $S0D().Construct(JSIL.ConcatString("Device disconnecting from unknown driver ", sender.toString()));
    }
    var deviceKey = (($IM04().Call(driver, null) + "_" + args.Id));
    var flag3 = (this._inputDevices).TryGetValue(deviceKey, /* ref */ existingDevice);
    if (flag3) {
      (existingDevice.get()).Disconnect();
      var expr_99 = this.InputDeviceDisconnected;
      if (expr_99 !== null) {
        var expr_A5 = new ($T1A())();
        expr_A5.InputDevice = existingDevice.get();
        expr_99(this, expr_A5);
      }
      return;
    }
    throw $S0D().Construct(("Driver " + $IM04().Call(driver, null) + " trying to disconnect unknown device " + args.Id));
  }; 

  function Input_OnNewDeviceImpConnected (sender, args) {
    var existingDevice = new JSIL.BoxedVariable(null);
    if (sender === null) {
      throw $S09().Construct("sender");
    }
    var driver = $T0B().$As(sender);
    if (driver === null) {
      throw $S0D().Construct(JSIL.ConcatString("Device connecting from unknown driver ", sender.toString()));
    }
    var flag3 = (args === null) || 
    (args.InputDeviceImp === null);
    if (flag3) {
      throw $S0E().Construct("args", "Device or InputDeviceImp must not be null");
    }
    var deviceKey = (($IM04().Call(driver, null) + "_" + $IM05().Call(args.InputDeviceImp, null)));
    var flag4 = (this._inputDevices).TryGetValue(deviceKey, /* ref */ existingDevice);
    if (flag4) {
      (existingDevice.get()).Reconnect(args.InputDeviceImp);
    } else {
      existingDevice.set(this.CreateInputDevice(args.InputDeviceImp));
      (this._inputDevices).set_Item(deviceKey, existingDevice.get());
    }
    var expr_C4 = this.InputDeviceConnected;
    if (expr_C4 !== null) {
      var expr_D0 = new ($T1A())();
      expr_D0.InputDevice = existingDevice.get();
      expr_C4(this, expr_D0);
    }
  }; 

  function Input_PostRender () {
    var enumerator = $IM09().Call(this.get_InputDevices(), null);
    try {

      while ($IM02().Call(enumerator, null)) {
        var inputDevice = $IM0A().Call(enumerator, null);
        inputDevice.PostRender();
      }
    } finally {
      if (enumerator !== null) {
        $IM06().Call(enumerator, null);
      }
    }
  }; 

  function Input_PreRender () {
    var enumerator = $IM09().Call(this.get_InputDevices(), null);
    try {

      while ($IM02().Call(enumerator, null)) {
        var inputDevice = $IM0A().Call(enumerator, null);
        inputDevice.PreRender();
      }
    } finally {
      if (enumerator !== null) {
        $IM06().Call(enumerator, null);
      }
    }
  }; 

  function Input_RegisterInputDeviceType (match, creator) {
    var $temp00;
    var flag = match === null;
    if (flag) {
      throw $S09().Construct("match");
    }
    var flag2 = creator === null;
    if (flag2) {
      throw $S09().Construct("creator");
    }
    var expr_32 = new ($T16())();
    expr_32.Match = match;
    expr_32.Creator = creator;
    $S0F().CallVirtual("Add", null, this._specialDeviceCreators, expr_32);
    var matchingDevices = $S10().Construct();
    var enumerator = ((this._inputDevices).get_Values()).GetEnumerator();

    while ($T18().prototype.MoveNext.call(enumerator)) {
      var device = $T18().prototype.get_Current.call(enumerator);
      var flag3 = (device.get_DeviceImp() !== null) && 
      match(device.get_DeviceImp());
      if (flag3) {
        $S11().CallVirtual("Add", null, matchingDevices, device.get_Id());
      }
    }

    for (var a$0 = matchingDevices._items, i$0 = 0, l$0 = (matchingDevices._size | 0); i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var devId = a$0[i$0];
      var dev = (this._inputDevices).get_Item(devId);
      dev.Disconnect();
      var expr_E7 = this.InputDeviceDisconnected;
      if (expr_E7 !== null) {
        var expr_F3 = new ($T1A())();
        expr_F3.InputDevice = dev;
        expr_E7(this, expr_F3);
      }
      var inputDeviceImp = dev.get_DeviceImp();
      (this._inputDevices).Remove(devId);
      dev = creator(inputDeviceImp);
      (this._inputDevices).set_Item(devId, dev);
      var expr_138 = this.InputDeviceConnected;
      if (expr_138 !== null) {
        var expr_144 = new ($T1A())();
        expr_144.InputDevice = dev;
        expr_138(this, expr_144);
      }
    }
  }; 

  function Input_remove_DeviceConnected (value) {
    var inputDeviceConnected = $thisType.get_Instance().InputDeviceConnected;
    var flag = new JSIL.BoxedVariable(false);
    try {
      $T08().Enter(inputDeviceConnected, /* ref */ flag);
      $thisType.get_Instance().remove_InputDeviceConnected(value);
    } finally {
      if (flag.get()) {
        $T08().Exit(inputDeviceConnected);
      }
    }
  }; 

  function Input_remove_DeviceDisconnected (value) {
    var inputDeviceDisconnected = $thisType.get_Instance().InputDeviceDisconnected;
    var flag = new JSIL.BoxedVariable(false);
    try {
      $T08().Enter(inputDeviceDisconnected, /* ref */ flag);
      $thisType.get_Instance().remove_InputDeviceDisconnected(value);
    } finally {
      if (flag.get()) {
        $T08().Exit(inputDeviceDisconnected);
      }
    }
  }; 

  function Input_remove_InputDeviceConnected (value) {
    var eventHandler = this.InputDeviceConnected;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T09().Remove(eventHandler2, value);
      eventHandler = $T0A().CompareExchange$b1($T06())(/* ref */ new JSIL.MemberReference(this, "InputDeviceConnected"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  function Input_remove_InputDeviceDisconnected (value) {
    var eventHandler = this.InputDeviceDisconnected;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T09().Remove(eventHandler2, value);
      eventHandler = $T0A().CompareExchange$b1($T06())(/* ref */ new JSIL.MemberReference(this, "InputDeviceDisconnected"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Input", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      Input__ctor
    );

    $.Method({Static:true , Public:true }, "add_DeviceConnected", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")])), 
      Input_add_DeviceConnected
    );

    $.Method({Static:true , Public:true }, "add_DeviceDisconnected", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")])), 
      Input_add_DeviceDisconnected
    );

    $.Method({Static:false, Public:true }, "add_InputDeviceConnected", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")])), 
      Input_add_InputDeviceConnected
    );

    $.Method({Static:false, Public:true }, "add_InputDeviceDisconnected", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")])), 
      Input_add_InputDeviceDisconnected
    );

    $.Method({Static:true , Public:true }, "AddDriverImp", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp")), 
      Input_AddDriverImp
    );

    $.Method({Static:false, Public:true }, "AddInputDriverImp", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp")), 
      Input_AddInputDriverImp
    );

    $.Method({Static:false, Public:false}, "CreateInputDevice", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.InputDevice"), [$asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")]), 
      Input_CreateInputDevice
    );

    $.Method({Static:false, Public:true }, "Dispose", 
      JSIL.MethodSignature.Void, 
      Input_Dispose
    );

    $.Method({Static:true , Public:true }, "get_Devices", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm04.TypeRef("Fusee.Engine.Core.InputDevice")])), 
      Input_get_Devices
    );

    $.Method({Static:true , Public:true }, "get_Drivers", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp")])), 
      Input_get_Drivers
    );

    $.Method({Static:false, Public:true }, "get_InputDevices", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm04.TypeRef("Fusee.Engine.Core.InputDevice")])), 
      Input_get_InputDevices
    );

    $.Method({Static:false, Public:true }, "get_InputDrivers", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp")])), 
      Input_get_InputDrivers
    );

    $.Method({Static:true , Public:true }, "get_Instance", 
      JSIL.MethodSignature.Return($.Type), 
      Input_get_Instance
    );

    $.Method({Static:true , Public:true }, "get_Keyboard", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.KeyboardDevice")), 
      Input_get_Keyboard
    );

    $.Method({Static:false, Public:true }, "get_KeyboardInput", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.KeyboardDevice")), 
      Input_get_KeyboardInput
    );

    $.Method({Static:true , Public:true }, "get_Mouse", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.MouseDevice")), 
      Input_get_Mouse
    );

    $.Method({Static:false, Public:true }, "get_MouseInput", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.MouseDevice")), 
      Input_get_MouseInput
    );

    $.Method({Static:true , Public:true }, "get_Touch", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.TouchDevice")), 
      Input_get_Touch
    );

    $.Method({Static:false, Public:true }, "get_TouchInput", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.TouchDevice")), 
      Input_get_TouchInput
    );

    $.Method({Static:true , Public:true }, "GetDevice", 
      new JSIL.MethodSignature("!!0", null, ["TDevice"]), 
      Input_GetDevice$b1
    );

    $.Method({Static:true , Public:true }, "GetDevices", 
      new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"]), null, ["TDevice"]), 
      Input_GetDevices$b1
    );

    $.Method({Static:false, Public:true }, "GetInputDevice", 
      new JSIL.MethodSignature("!!0", null, ["TDevice"]), 
      Input_GetInputDevice$b1
    );

    $.Method({Static:false, Public:true }, "GetInputDevices", 
      new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"]), null, ["TDevice"]), 
      Input_GetInputDevices$b1
    );

    $.Method({Static:false, Public:false}, "OnDeviceImpDisconnected", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.DeviceImpDisconnectedArgs")]), 
      Input_OnDeviceImpDisconnected
    );

    $.Method({Static:false, Public:false}, "OnNewDeviceImpConnected", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.NewDeviceImpConnectedArgs")]), 
      Input_OnNewDeviceImpConnected
    );

    $.Method({Static:false, Public:true }, "PostRender", 
      JSIL.MethodSignature.Void, 
      Input_PostRender
    );

    $.Method({Static:false, Public:true }, "PreRender", 
      JSIL.MethodSignature.Void, 
      Input_PreRender
    );

    $.Method({Static:false, Public:true }, "RegisterInputDeviceType", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.MatchFunc"), $asm04.TypeRef("Fusee.Engine.Core.CreatorFunc")]), 
      Input_RegisterInputDeviceType
    );

    $.Method({Static:true , Public:true }, "remove_DeviceConnected", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")])), 
      Input_remove_DeviceConnected
    );

    $.Method({Static:true , Public:true }, "remove_DeviceDisconnected", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")])), 
      Input_remove_DeviceDisconnected
    );

    $.Method({Static:false, Public:true }, "remove_InputDeviceConnected", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")])), 
      Input_remove_InputDeviceConnected
    );

    $.Method({Static:false, Public:true }, "remove_InputDeviceDisconnected", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")])), 
      Input_remove_InputDeviceDisconnected
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_inputDrivers", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp")]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_inputDevices", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $asm04.TypeRef("Fusee.Engine.Core.InputDevice")]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_specialDeviceCreators", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm04.TypeRef("Fusee.Engine.Core.SpecialDeviceCreator")]));

    $.Field({Static:false, Public:false}, "InputDeviceConnected", $asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")]));

    $.Field({Static:false, Public:false}, "InputDeviceDisconnected", $asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")]));

    $.Field({Static:true , Public:false}, "_instance", $.Type);

    $.Property({Static:false, Public:true }, "InputDrivers", $asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp")]));

    $.Property({Static:true , Public:true }, "Drivers", $asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp")]));

    $.Property({Static:false, Public:true }, "InputDevices", $asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm04.TypeRef("Fusee.Engine.Core.InputDevice")]));

    $.Property({Static:true , Public:true }, "Devices", $asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm04.TypeRef("Fusee.Engine.Core.InputDevice")]));

    $.Property({Static:false, Public:true }, "MouseInput", $asm04.TypeRef("Fusee.Engine.Core.MouseDevice"));

    $.Property({Static:true , Public:true }, "Mouse", $asm04.TypeRef("Fusee.Engine.Core.MouseDevice"));

    $.Property({Static:false, Public:true }, "KeyboardInput", $asm04.TypeRef("Fusee.Engine.Core.KeyboardDevice"));

    $.Property({Static:true , Public:true }, "Keyboard", $asm04.TypeRef("Fusee.Engine.Core.KeyboardDevice"));

    $.Property({Static:false, Public:true }, "TouchInput", $asm04.TypeRef("Fusee.Engine.Core.TouchDevice"));

    $.Property({Static:true , Public:true }, "Touch", $asm04.TypeRef("Fusee.Engine.Core.TouchDevice"));

    $.Property({Static:true , Public:true }, "Instance", $.Type);

    $.Event({Static:false, Public:true }, "InputDeviceConnected", $asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")]));

    $.Event({Static:true , Public:true }, "DeviceConnected", $asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")]));

    $.Event({Static:false, Public:true }, "InputDeviceDisconnected", $asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")]));

    $.Event({Static:true , Public:true }, "DeviceDisconnected", $asm0E.TypeRef("System.EventHandler`1", [$asm04.TypeRef("Fusee.Engine.Core.DeviceConnectionArgs")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Input+<>c */ 

(function $l$gc$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.DeviceCategory)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.MouseDevice)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.KeyboardDevice)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.TouchDevice)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.get_Category)) ();
  };


  function $l$gc__ctor () {
  }; 

  function $l$gc_$l_ctor$gb__39_0 (imp) {
    return ($IM00().Call(imp, null) === $T01().Mouse);
  }; 

  function $l$gc_$l_ctor$gb__39_1 (imp) {
    return new ($T02())(imp);
  }; 

  function $l$gc_$l_ctor$gb__39_2 (imp) {
    return ($IM00().Call(imp, null) === $T01().Keyboard);
  }; 

  function $l$gc_$l_ctor$gb__39_3 (imp) {
    return new ($T03())(imp);
  }; 

  function $l$gc_$l_ctor$gb__39_4 (imp) {
    return ($IM00().Call(imp, null) === $T01().Touch);
  }; 

  function $l$gc_$l_ctor$gb__39_5 (imp) {
    return new ($T04())(imp);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Input+<>c", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__ctor
    );

    $.Method({Static:false, Public:false}, "$l.ctor$gb__39_0", 
      new JSIL.MethodSignature($.Boolean, [$asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")]), 
      $l$gc_$l_ctor$gb__39_0
    );

    $.Method({Static:false, Public:false}, "$l.ctor$gb__39_1", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.InputDevice"), [$asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")]), 
      $l$gc_$l_ctor$gb__39_1
    );

    $.Method({Static:false, Public:false}, "$l.ctor$gb__39_2", 
      new JSIL.MethodSignature($.Boolean, [$asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")]), 
      $l$gc_$l_ctor$gb__39_2
    );

    $.Method({Static:false, Public:false}, "$l.ctor$gb__39_3", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.InputDevice"), [$asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")]), 
      $l$gc_$l_ctor$gb__39_3
    );

    $.Method({Static:false, Public:false}, "$l.ctor$gb__39_4", 
      new JSIL.MethodSignature($.Boolean, [$asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")]), 
      $l$gc_$l_ctor$gb__39_4
    );

    $.Method({Static:false, Public:false}, "$l.ctor$gb__39_5", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.InputDevice"), [$asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")]), 
      $l$gc_$l_ctor$gb__39_5
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "$l$g9", $.Type);

    $.Field({Static:true , Public:true }, "$l$g9__39_0", $asm04.TypeRef("Fusee.Engine.Core.MatchFunc"));

    $.Field({Static:true , Public:true }, "$l$g9__39_1", $asm04.TypeRef("Fusee.Engine.Core.CreatorFunc"));

    $.Field({Static:true , Public:true }, "$l$g9__39_2", $asm04.TypeRef("Fusee.Engine.Core.MatchFunc"));

    $.Field({Static:true , Public:true }, "$l$g9__39_3", $asm04.TypeRef("Fusee.Engine.Core.CreatorFunc"));

    $.Field({Static:true , Public:true }, "$l$g9__39_4", $asm04.TypeRef("Fusee.Engine.Core.MatchFunc"));

    $.Field({Static:true , Public:true }, "$l$g9__39_5", $asm04.TypeRef("Fusee.Engine.Core.CreatorFunc"));


    function $l$gc__cctor () {
      $thisType.$l$g9 = new $thisType();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__cctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.InputDevice */ 

(function InputDevice$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.ArgumentNullException)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm03.Fusee.Engine.Common.AxisDescription))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm0E.System.Single))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm04.Fusee.Engine.Core.InputDevice_CalculatedAxisDescription))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.AxisImpDescription))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.AxisImpDescription))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Collections.IEnumerator)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisImpDescription)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.IDisposable)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.AxisValueChangedArgs))) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm03.Fusee.Engine.Common.ButtonDescription))) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm0E.System.Boolean))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm14.System.Collections.Generic.HashSet$b1.Of($asm0E.System.Int32))) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.ButtonImpDescription))) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.ButtonImpDescription))) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm03.Fusee.Engine.Common.ButtonImpDescription)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.ButtonValueChangedArgs))) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0E.System.Delegate)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0E.System.Threading.Interlocked)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize(System.Array.Of($asm0E.System.Int32))) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm14.System.Linq.Enumerable)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisValueChangedArgs)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm03.Fusee.Engine.Common.ButtonValueChangedArgs)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0E.System.InvalidOperationException)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisDescription)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm03.Fusee.Engine.Common.ButtonDescription)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm04.Fusee.Engine.Core.Time)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2_Enumerator.Of($asm0E.System.Int32, $asm04.Fusee.Engine.Core.InputDevice_CalculatedAxisDescription))) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0E.System.Int32, $asm04.Fusee.Engine.Core.InputDevice_CalculatedAxisDescription))) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2_Enumerator.Of($asm0E.System.Int32, $asm0E.System.Boolean))) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0E.System.Int32, $asm0E.System.Boolean))) ();
  };
  var $T25 = function () {
    return ($T25 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice_AxisValueCalculator)) ();
  };
  var $T26 = function () {
    return ($T26 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice_CalculatedAxisDescription)) ();
  };
  var $T27 = function () {
    return ($T27 = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisDirection)) ();
  };
  var $T28 = function () {
    return ($T28 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice_$l$gc__DisplayClass55_0)) ();
  };
  var $T29 = function () {
    return ($T29 = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisBoundedType)) ();
  };
  var $T2A = function () {
    return ($T2A = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisNature)) ();
  };
  var $T2B = function () {
    return ($T2B = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice_$l$gc__DisplayClass56_0)) ();
  };
  var $T2C = function () {
    return ($T2C = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice_$l$gc__DisplayClass54_0)) ();
  };
  var $T2D = function () {
    return ($T2D = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T2E = function () {
    return ($T2E = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice_$l$gc__DisplayClass54_1)) ();
  };
  var $T2F = function () {
    return ($T2F = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice_$l$gc__DisplayClass54_2)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentNullException, [$asm0E.System.String]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm03.Fusee.Engine.Common.AxisDescription), null))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm0E.System.Single), null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm04.Fusee.Engine.Core.InputDevice_CalculatedAxisDescription), null))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.AxisValueChangedArgs]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm03.Fusee.Engine.Common.ButtonDescription), null))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.Int32, $asm0E.System.Boolean), null))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm14.System.Collections.Generic.HashSet$b1.Of($asm0E.System.Int32), null))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.ButtonValueChangedArgs]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.InvalidOperationException, [$asm0E.System.String]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Single, [$asm0E.System.Single]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Single, [$asm0E.System.Single]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Single, [$asm0E.System.Single]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Single, [$asm0E.System.Single]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.AxisImpDescription).GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.get_AxisImpDesc)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0E.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.AxisImpDescription).get_Current)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.GetAxis)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm0E.System.IDisposable.Dispose)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.add_AxisValueChanged)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.ButtonImpDescription).GetEnumerator)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.get_ButtonImpDesc)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.ButtonImpDescription).get_Current)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.GetButton)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.add_ButtonValueChanged)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.remove_AxisValueChanged)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.remove_ButtonValueChanged)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.get_Category)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.get_Desc)) ();
  };
  var $IM10 = function () {
    return ($IM10 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp.get_Id)) ();
  };


  function InputDevice__ctor (inpDeviceImp) {
    if (inpDeviceImp === null) {
      throw $S00().Construct("inpDeviceImp");
    }
    this._inpDevImp = inpDeviceImp;
    this._isConnected = true;
    this._axes = $S01().Construct();
    this._axesToPoll = $S02().Construct();
    this._axesToListen = $S02().Construct();
    this._calculatedAxes = $S03().Construct();
    this._nextAxisId = 0;
    var enumerator = $IM00().Call($IM01().Call(this._inpDevImp, null), null);
    try {

      while ($IM02().Call(enumerator, null)) {
        var axisImpDescription = $IM03().Call(enumerator, null);
        var axisId = (axisImpDescription.AxisDesc.Id | 0);
        var flag2 = axisId > (this._nextAxisId | 0);
        if (flag2) {
          this._nextAxisId = axisId;
        }
        (this._axes).set_Item(axisId, axisImpDescription.AxisDesc.MemberwiseClone());
        var pollAxis = axisImpDescription.PollAxis;
        if (pollAxis) {
          (this._axesToPoll).set_Item(axisId, $IM04().Call(this._inpDevImp, null, axisId));
        } else {
          (this._axesToListen).set_Item(axisId, 0);
        }
      }
    } finally {
      if (enumerator !== null) {
        $IM05().Call(enumerator, null);
      }
    }
    this._nextAxisId = (((this._nextAxisId | 0) + 1) | 0);
    var flag3 = ((this._axesToListen).get_Count() | 0) > 0;
    if (flag3) {
      $IM06().Call(this._inpDevImp, null, $T0C().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnImpAxisValueChanged", $S04(), false, false)));
    }
    this._buttons = $S05().Construct();
    this._buttonsToPoll = $S06().Construct();
    this._buttonsToListen = $S06().Construct();
    this._buttonsUp = $S07().Construct();
    this._buttonsDown = $S07().Construct();
    this._buttonsToListenJustChanged = $S06().Construct();
    var enumerator2 = $IM07().Call($IM08().Call(this._inpDevImp, null), null);
    try {

      while ($IM02().Call(enumerator2, null)) {
        var buttonImpDescription = $IM09().Call(enumerator2, null);
        var buttonId = (buttonImpDescription.ButtonDesc.Id | 0);
        (this._buttons).set_Item(buttonId, buttonImpDescription.ButtonDesc.MemberwiseClone());
        var pollButton = buttonImpDescription.PollButton;
        if (pollButton) {
          (this._buttonsToPoll).set_Item(buttonId, $IM0A().Call(this._inpDevImp, null, buttonId));
        } else {
          (this._buttonsToListen).set_Item(buttonId, false);
        }
      }
    } finally {
      if (enumerator2 !== null) {
        $IM05().Call(enumerator2, null);
      }
    }
    var flag4 = ((this._buttonsToListen).get_Count() | 0) > 0;
    if (flag4) {
      $IM0B().Call(this._inpDevImp, null, $T13().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnImpButtonValueChanged", $S08(), false, false)));
    }
  }; 

  function InputDevice_add_AxisValueChanged (value) {
    var eventHandler = this.AxisValueChanged;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T14().Combine(eventHandler2, value);
      eventHandler = $T15().CompareExchange$b1($T0C())(/* ref */ new JSIL.MemberReference(this, "AxisValueChanged"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  function InputDevice_add_ButtonValueChanged (value) {
    var eventHandler = this.ButtonValueChanged;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T14().Combine(eventHandler2, value);
      eventHandler = $T15().CompareExchange$b1($T13())(/* ref */ new JSIL.MemberReference(this, "ButtonValueChanged"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  function InputDevice_Disconnect () {
    var array = $T17().ToArray$b1($T09())((this._axesToListen).get_Keys());

    for (var i = 0; i < (array.length | 0); i = ((i + 1) | 0)) {
      var axisId = (array[i] | 0);
      var flag = (this.AxisValueChanged !== null) && 
      (+(this._axesToListen).get_Item(axisId) !== 0);
      if (flag) {
        var arg_6B_0 = this.AxisValueChanged;
        var expr_4E = new ($T18())();
        expr_4E.Axis = (this._axes).get_Item(axisId).MemberwiseClone();
        expr_4E.Value = 0;
        arg_6B_0(this, expr_4E);
      }
      (this._axesToListen).set_Item(axisId, 0);
    }
    var array2 = $T17().ToArray$b1($T09())((this._axesToPoll).get_Keys());

    for (var j = 0; j < (array2.length | 0); j = ((j + 1) | 0)) {
      var axisId2 = (array2[j] | 0);
      (this._axesToPoll).set_Item(axisId2, 0);
    }
    var array3 = $T17().ToArray$b1($T09())((this._buttonsToListen).get_Keys());

    for (var k = 0; k < (array3.length | 0); k = ((k + 1) | 0)) {
      var buttonId = (array3[k] | 0);
      var flag2 = (this.ButtonValueChanged !== null) && 
      (this._buttonsToListen).get_Item(buttonId);
      if (flag2) {
        var arg_136_0 = this.ButtonValueChanged;
        var expr_11C = new ($T19())();
        expr_11C.Button = (this._buttons).get_Item(buttonId).MemberwiseClone();
        expr_11C.Pressed = false;
        arg_136_0(this, expr_11C);
      }
      (this._buttonsToListen).set_Item(buttonId, false);
    }
    var array4 = $T17().ToArray$b1($T09())((this._buttonsToPoll).get_Keys());

    for (var l = 0; l < (array4.length | 0); l = ((l + 1) | 0)) {
      var buttonId2 = (array4[l] | 0);
      (this._buttonsToPoll).set_Item(buttonId2, false);
    }
    $IM0C().Call(this._inpDevImp, null, $T0C().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnImpAxisValueChanged", $S04(), false, false)));
    $IM0D().Call(this._inpDevImp, null, $T13().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnImpButtonValueChanged", $S08(), false, false)));
    this._inpDevImp = null;
    this._isConnected = false;
  }; 

  function InputDevice_get_AxesCount () {
    return (this._axes).get_Count();
  }; 

  function InputDevice_get_AxisDesc () {
    return (this._axes).get_Values();
  }; 

  function InputDevice_get_ButtonCount () {
    return (this._buttons).get_Count();
  }; 

  function InputDevice_get_ButtonDesc () {
    return (this._buttons).get_Values();
  }; 

  function InputDevice_get_Category () {
    return $IM0E().Call(this._inpDevImp, null);
  }; 

  function InputDevice_get_Desc () {
    return $IM0F().Call(this._inpDevImp, null);
  }; 

  function InputDevice_get_DeviceImp () {
    return this._inpDevImp;
  }; 

  function InputDevice_get_Id () {
    return $IM10().Call(this._inpDevImp, null);
  }; 

  function InputDevice_get_IsConnected () {
    return this._isConnected;
  }; 

  function InputDevice_get_NewAxisID () {
    return (((this._nextAxisId | 0) + 1) | 0);
  }; 

  function InputDevice_GetAxis (axisId) {
    var value = new JSIL.BoxedVariable(0);
    if (!this._isConnected) {
      var result = 0;
    } else {
      var flag2 = this.TryGetPolledAxis(axisId, /* ref */ value);
      if (flag2) {
        result = +value.get();
      } else {
        var flag3 = (this._axesToListen).TryGetValue(axisId, /* ref */ value);
        if (!flag3) {
          throw $S09().Construct($T1C().Format("Axis Id {0} not supported by device {1}.", JSIL.Array.New($T1D(), [$T09().$Box(axisId), $IM0F().Call(this._inpDevImp, null)])));
        }
        result = +value.get();
      }
    }
    return result;
  }; 

  function InputDevice_GetAxisDescription (axisId) {
    var desc = new JSIL.BoxedVariable(new ($T1E())());
    var flag = (this._axes).TryGetValue(axisId, /* ref */ desc);
    if (flag) {
      return desc.get();
    }
    throw $S09().Construct($T1C().Format("Cannot retrieve axis information for unknon axis {0}.", JSIL.Array.New($T1D(), [$T09().$Box(axisId)])));
  }; 

  function InputDevice_GetButton (buttonId) {
    var state = new JSIL.BoxedVariable(false);
    if (!this._isConnected) {
      var result = false;
    } else {
      var flag2 = (this._buttonsToListen).TryGetValue(buttonId, /* ref */ state);
      if (flag2) {
        result = state.get();
      } else {
        var flag3 = (this._buttonsToPoll).ContainsKey(buttonId);
        if (!flag3) {
          throw $S09().Construct($T1C().Format("Button Id {0} not supported by device {1}.", JSIL.Array.New($T1D(), [$T09().$Box(buttonId), $IM0F().Call(this._inpDevImp, null)])));
        }
        var btnState = $IM0A().Call(this._inpDevImp, null, buttonId);
        (this._buttonsToPoll).set_Item(buttonId, btnState);
        result = btnState;
      }
    }
    return result;
  }; 

  function InputDevice_GetButtonDescription (buttonId) {
    var desc = new JSIL.BoxedVariable(new ($T1F())());
    var flag = (this._buttons).TryGetValue(buttonId, /* ref */ desc);
    if (flag) {
      return desc.get();
    }
    throw $S09().Construct($T1C().Format("Cannot retrieve button information for unknon button {0}.", JSIL.Array.New($T1D(), [$T09().$Box(buttonId)])));
  }; 

  function InputDevice_IsButtonDown (buttonId) {
    var flag = !(this._buttons).ContainsKey(buttonId);
    if (flag) {
      throw $S09().Construct($T1C().Format("IsButtonDown called for unknon button {0}.", JSIL.Array.New($T1D(), [$T09().$Box(buttonId)])));
    }
    return (this._buttonsDown).Contains(buttonId);
  }; 

  function InputDevice_IsButtonUp (buttonId) {
    var flag = !(this._buttons).ContainsKey(buttonId);
    if (flag) {
      throw $S09().Construct($T1C().Format("IsButtonDown called for unknon button {0}.", JSIL.Array.New($T1D(), [$T09().$Box(buttonId)])));
    }
    return (this._buttonsUp).Contains(buttonId);
  }; 

  function InputDevice_OnImpAxisValueChanged (sender, args) {
    var flag = !(this._axesToListen).ContainsKey(args.Axis.Id);
    if (flag) {
      throw $S09().Construct($T1C().Format("Unknown Axis {0} ({1})", JSIL.Array.New($T1D(), [args.Axis.Name, $T09().$Box(args.Axis.Id)])));
    }
    (this._axesToListen).set_Item(args.Axis.Id, args.Value);
    var expr_78 = this.AxisValueChanged;
    if (expr_78 !== null) {
      expr_78(this, args);
    }
  }; 

  function InputDevice_OnImpButtonValueChanged (sender, args) {
    var flag = !(this._buttonsToListen).ContainsKey(args.Button.Id);
    if (flag) {
      throw $S09().Construct($T1C().Format("Unknown Button {0} ({1})", JSIL.Array.New($T1D(), [args.Button.Name, $T09().$Box(args.Button.Id)])));
    }
    (this._buttonsToListenJustChanged).set_Item(args.Button.Id, args.Pressed);
  }; 

  function InputDevice_PostRender () {
    (this._buttonsDown).Clear();
    (this._buttonsUp).Clear();
  }; 

  function InputDevice_PreRender () {
    var curVal = new JSIL.BoxedVariable(0);
    var flag = +$T20().get_DeltaTime() !== 0;
    if (flag) {
      var enumerator = $T04().prototype.GetEnumerator.call(this._calculatedAxes);

      while ($T21().prototype.MoveNext.call(enumerator)) {
        var derivedAxis = $T21().prototype.get_Current.call(enumerator).MemberwiseClone();
        derivedAxis.Value.CurrentAxisValue = +derivedAxis.get_Value().Calculator($T20().get_DeltaTime());
      }
    }
    if (this.AxisValueChanged !== null) {
      var array = $T17().ToArray$b1($T09())((this._axesToPoll).get_Keys());

      for (var i = 0; i < (array.length | 0); i = ((i + 1) | 0)) {
        var axisId = (array[i] | 0);
        var flag3 = !this.TryGetPolledAxis(axisId, /* ref */ curVal);
        if (flag3) {
          throw $S09().Construct($T1C().Format("Invalid axis Id {0} - should be polled or derived.", JSIL.Array.New($T1D(), [$T09().$Box(axisId)])));
        }
        var flag4 = +(this._axesToPoll).get_Item(axisId) !== +curVal.get();
        if (flag4) {
          var arg_114_0 = this.AxisValueChanged;
          var expr_F9 = new ($T18())();
          expr_F9.Axis = (this._axes).get_Item(axisId).MemberwiseClone();
          expr_F9.Value = +curVal.get();
          arg_114_0(this, expr_F9);
          (this._axesToPoll).set_Item(axisId, curVal.get());
        }
      }
    }
    var array2 = $T17().ToArray$b1($T09())((this._buttonsToPoll).get_Keys());

    for (var j = 0; j < (array2.length | 0); j = ((j + 1) | 0)) {
      var buttonId = (array2[j] | 0);
      var curVal2 = $IM0A().Call(this._inpDevImp, null, buttonId);
      var flag5 = (this._buttonsToPoll).get_Item(buttonId) !== curVal2;
      if (flag5) {
        if (curVal2) {
          (this._buttonsDown).Add(buttonId);
        } else {
          (this._buttonsUp).Add(buttonId);
        }
        var expr_1B7 = this.ButtonValueChanged;
        if (expr_1B7 !== null) {
          var expr_1C3 = new ($T19())();
          expr_1C3.Button = (this._buttons).get_Item(buttonId).MemberwiseClone();
          expr_1C3.Pressed = curVal2;
          expr_1B7(this, expr_1C3);
        }
        (this._buttonsToPoll).set_Item(buttonId, curVal2);
      }
    }
    var enumerator2 = $T0E().prototype.GetEnumerator.call(this._buttonsToListenJustChanged);

    while ($T23().prototype.MoveNext.call(enumerator2)) {
      var b = $T23().prototype.get_Current.call(enumerator2).MemberwiseClone();
      var flag7 = b.get_Value() !== (this._buttonsToListen).get_Item(b.get_Key());
      if (flag7) {
        var value = b.get_Value();
        if (value) {
          (this._buttonsDown).Add(b.get_Key());
        } else {
          (this._buttonsUp).Add(b.get_Key());
        }
      }
      (this._buttonsToListen).set_Item(
        b.get_Key(), 
        b.get_Value()
      );
      var expr_29F = this.ButtonValueChanged;
      if (expr_29F !== null) {
        var expr_2AB = new ($T19())();
        expr_2AB.Button = (this._buttons).get_Item(b.get_Key()).MemberwiseClone();
        expr_2AB.Pressed = b.get_Value();
        expr_29F(this, expr_2AB);
      }
    }
    (this._buttonsToListenJustChanged).Clear();
  }; 

  function InputDevice_Reconnect (deviceImp) {
    var isConnected = this._isConnected;
    if (isConnected) {
      throw $S09().Construct($T1C().Format("Cannot reconnect already connected input device (connected to {0}). Disconnect first.", JSIL.Array.New($T1D(), [$IM0F().Call(this._inpDevImp, null)])));
    }
    if (deviceImp === null) {
      throw $S00().Construct("deviceImp");
    }
    this._inpDevImp = deviceImp;
    $IM06().Call(this._inpDevImp, null, $T0C().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnImpAxisValueChanged", $S04(), false, false)));
    $IM0B().Call(this._inpDevImp, null, $T13().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnImpButtonValueChanged", $S08(), false, false)));
    this._isConnected = true;
  }; 

  function InputDevice_RegisterCalculatedAxis (calculatedAxisDescription, calculator, initialValue) {
    var flag = (calculatedAxisDescription.Id | 0) < (this._nextAxisId | 0);
    if (flag) {
      throw $S09().Construct($T1C().Format("Invalid Id for calculated axis '{0}'. Id must be bigger or equal to {1}.", JSIL.Array.New($T1D(), [calculatedAxisDescription.Name, $T09().$Box(this._nextAxisId)])));
    }
    this._nextAxisId = (calculatedAxisDescription.Id | 0);
    var expr_51 = new ($T26())();
    expr_51.AxisDesc = calculatedAxisDescription.MemberwiseClone();
    expr_51.CurrentAxisValue = +initialValue;
    expr_51.Calculator = calculator;
    var calculatedAxis = expr_51;
    (this._calculatedAxes).set_Item(calculatedAxisDescription.Id, calculatedAxis);
    (this._axesToPoll).set_Item(calculatedAxisDescription.Id, calculatedAxis.CurrentAxisValue);
    (this._axes).set_Item(calculatedAxisDescription.Id, calculatedAxisDescription.MemberwiseClone());
  }; 

  function InputDevice_RegisterSingleButtonAxis (origButtonId, direction, rampUpTime, rampDownTime, buttonAxisId, name) {
    var origButtonDesc = new JSIL.BoxedVariable(new ($T1F())());
    var $closure0 = new ($T28())();
    $closure0.$l$g4__this = this;
    $closure0.origButtonId = (origButtonId | 0);
    $closure0.rampUpTime = +rampUpTime;
    $closure0.rampDownTime = +rampDownTime;
    var flag = !(this._buttons).TryGetValue($closure0.origButtonId, /* ref */ origButtonDesc);
    if (flag) {
      throw $S09().Construct($T1C().Format("Button Id {0} is not known. Cannot register button axis based on unknown button.", JSIL.Array.New($T1D(), [$T09().$Box($closure0.origButtonId)])));
    }
    var flag2 = +$closure0.rampUpTime <= -3.40282347E+38;
    if (flag2) {
      $closure0.rampUpTime = -Infinity;
    }
    var flag3 = +$closure0.rampDownTime <= -3.40282347E+38;
    if (flag3) {
      $closure0.rampDownTime = -Infinity;
    }
    $closure0.closureLastBtnState = this.GetButton($closure0.origButtonId);
    $closure0.closureLastAxisValue = 0;
    $closure0.closureAnimDirection = 0;
    var calculator = $T25().New($closure0, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.InputDevice_$l$gc__DisplayClass55_0, "$lRegisterSingleButtonAxis$gb__0", $S0A(), false, false));
    var id = (((this._nextAxisId | 0) + 1) | 0);
    var flag4 = (buttonAxisId | 0) > id;
    if (flag4) {
      id = (buttonAxisId | 0);
    }
    var axisDescription = new ($T1E())();
    axisDescription.Id = id;
    axisDescription.Name = JSIL.Coalesce(name, $T1C().Format("{0} Axis", JSIL.Array.New($T1D(), [origButtonDesc.get().Name])));
    axisDescription.Bounded = $T29().Constant;
    axisDescription.Direction = direction;
    axisDescription.Nature = $T2A().Speed;
    axisDescription.MaxValueOrAxis = 1;
    axisDescription.MinValueOrAxis = 0;
    var calculatedAxisDesc = axisDescription;
    this.RegisterCalculatedAxis(calculatedAxisDesc.MemberwiseClone(), calculator, 0);
    return calculatedAxisDesc;
  }; 

  function InputDevice_RegisterTwoButtonAxis (origButtonIdNegative, origButtonIdPositive, direction, rampUpTime, rampDownTime, buttonAxisId, name) {
    var origButtonDescPos = new JSIL.BoxedVariable(new ($T1F())());
    var origButtonDescNeg = new JSIL.BoxedVariable(new ($T1F())());
    var $closure0 = new ($T2B())();
    $closure0.$l$g4__this = this;
    $closure0.origButtonIdPositive = (origButtonIdPositive | 0);
    $closure0.origButtonIdNegative = (origButtonIdNegative | 0);
    $closure0.rampDownTime = +rampDownTime;
    $closure0.rampUpTime = +rampUpTime;
    var flag = !(this._buttons).TryGetValue($closure0.origButtonIdPositive, /* ref */ origButtonDescPos);
    if (flag) {
      throw $S09().Construct($T1C().Format("Button Id {0} is not known. Cannot register button axis based on unknown button.", JSIL.Array.New($T1D(), [$T09().$Box($closure0.origButtonIdPositive)])));
    }
    var flag2 = !(this._buttons).TryGetValue($closure0.origButtonIdNegative, /* ref */ origButtonDescNeg);
    if (flag2) {
      throw $S09().Construct($T1C().Format("Button Id {0} is not known. Cannot register button axis based on unknown button.", JSIL.Array.New($T1D(), [$T09().$Box($closure0.origButtonIdNegative)])));
    }
    var flag3 = +$closure0.rampUpTime <= -3.40282347E+38;
    if (flag3) {
      $closure0.rampUpTime = -Infinity;
    }
    var flag4 = +$closure0.rampDownTime <= -3.40282347E+38;
    if (flag4) {
      $closure0.rampDownTime = -Infinity;
    }
    $closure0.closureLastBtnStatePos = this.GetButton($closure0.origButtonIdPositive);
    $closure0.closureLastBtnStateNeg = this.GetButton($closure0.origButtonIdNegative);
    $closure0.closureLastAxisValue = 0;
    $closure0.closureAnimDirection = 0;
    var calculator = $T25().New($closure0, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.InputDevice_$l$gc__DisplayClass56_0, "$lRegisterTwoButtonAxis$gb__0", $S0B(), false, false));
    var id = (((this._nextAxisId | 0) + 1) | 0);
    var flag5 = (buttonAxisId | 0) > id;
    if (flag5) {
      id = (buttonAxisId | 0);
    }
    var axisDescription = new ($T1E())();
    axisDescription.Id = id;
    axisDescription.Name = JSIL.Coalesce(name, $T1C().Format("{0} {1} Axis", JSIL.Array.New($T1D(), [origButtonDescPos.get().Name, origButtonDescNeg.get().Name])));
    axisDescription.Bounded = $T29().Constant;
    axisDescription.Direction = direction;
    axisDescription.Nature = $T2A().Speed;
    axisDescription.MaxValueOrAxis = 1;
    axisDescription.MinValueOrAxis = -1;
    var calculatedAxisDesc = axisDescription;
    this.RegisterCalculatedAxis(calculatedAxisDesc.MemberwiseClone(), calculator, 0);
    return calculatedAxisDesc;
  }; 

  function InputDevice_RegisterVelocityAxis (origAxisId, triggerButtonId, velocityAxisId, name, direction) {
    var origAxisDesc = new JSIL.BoxedVariable(new ($T1E())());
    var triggerButtonDesc = new JSIL.BoxedVariable(new ($T1F())());
    var $closure0 = new ($T2C())();
    $closure0.$l$g4__this = this;
    $closure0.triggerButtonId = (triggerButtonId | 0);
    $closure0.origAxisId = (origAxisId | 0);
    var flag = !(this._axes).TryGetValue($closure0.origAxisId, /* ref */ origAxisDesc);
    if (flag) {
      throw $S09().Construct($T1C().Format("Axis Id {0} is not known. Cannot register derived axis based on unknown axis.", JSIL.Array.New($T1D(), [$T09().$Box($closure0.origAxisId)])));
    }
    var flag2 = ($closure0.triggerButtonId >>> 0) > (0 >>> 0);
    if (flag2) {
      var $closure1 = new ($T2E())();
      $closure1.CS$$l$g8__locals1 = $closure0;
      var flag3 = !(this._buttons).TryGetValue($closure1.CS$$l$g8__locals1.triggerButtonId, /* ref */ triggerButtonDesc);
      if (flag3) {
        throw $S09().Construct($T1C().Format("Button Id {0} is not known. Cannot register derived axis based on unknown trigger button id.", JSIL.Array.New($T1D(), [$T09().$Box($closure1.CS$$l$g8__locals1.triggerButtonId)])));
      }
      $closure1.closureLastValue = +this.GetAxis($closure1.CS$$l$g8__locals1.origAxisId);
      $closure1.closureOffLastTime = true;
      var calculator = $T25().New($closure1, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.InputDevice_$l$gc__DisplayClass54_1, "$lRegisterVelocityAxis$gb__0", $S0C(), false, false));
    } else {
      var $closure2 = new ($T2F())();
      $closure2.CS$$l$g8__locals2 = $closure0;
      $closure2.closureLastValue = +this.GetAxis($closure2.CS$$l$g8__locals2.origAxisId);
      calculator = $T25().New($closure2, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.InputDevice_$l$gc__DisplayClass54_2, "$lRegisterVelocityAxis$gb__1", $S0D(), false, false));
    }
    var id = (((this._nextAxisId | 0) + 1) | 0);
    var flag4 = (velocityAxisId | 0) > id;
    if (flag4) {
      id = (velocityAxisId | 0);
    }
    var axisDescription = new ($T1E())();
    axisDescription.Id = id;
    axisDescription.Name = JSIL.Coalesce(name, JSIL.ConcatString(origAxisDesc.get().Name, " Velocity"));
    axisDescription.Direction = (
      (direction === $T27().Unknown)
         ? origAxisDesc.get().Direction
         : direction)
    ;
    axisDescription.Nature = $T2A().Speed;
    axisDescription.Bounded = $T29().Unbound;
    axisDescription.MaxValueOrAxis = NaN;
    axisDescription.MinValueOrAxis = NaN;
    var calculatedAxisDesc = axisDescription;
    this.RegisterCalculatedAxis(calculatedAxisDesc.MemberwiseClone(), calculator, 0);
    return calculatedAxisDesc;
  }; 

  function InputDevice_remove_AxisValueChanged (value) {
    var eventHandler = this.AxisValueChanged;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T14().Remove(eventHandler2, value);
      eventHandler = $T15().CompareExchange$b1($T0C())(/* ref */ new JSIL.MemberReference(this, "AxisValueChanged"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  function InputDevice_remove_ButtonValueChanged (value) {
    var eventHandler = this.ButtonValueChanged;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T14().Remove(eventHandler2, value);
      eventHandler = $T15().CompareExchange$b1($T13())(/* ref */ new JSIL.MemberReference(this, "ButtonValueChanged"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  function InputDevice_TryGetPolledAxis (iAxisId, /* ref */ value) {
    var calculatedAxis = new JSIL.BoxedVariable(null);
    var flag = (this._calculatedAxes).TryGetValue(iAxisId, /* ref */ calculatedAxis);
    if (flag) {
      value.set(calculatedAxis.get().CurrentAxisValue);
      var result = true;
    } else {
      var flag2 = (this._axesToPoll).ContainsKey(iAxisId);
      if (flag2) {
        value.set($IM04().Call(this._inpDevImp, null, iAxisId));
        result = true;
      } else {
        value.set(0);
        result = false;
      }
    }
    return result;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.InputDevice", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")), 
      InputDevice__ctor
    );

    $.Method({Static:false, Public:true }, "add_AxisValueChanged", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm03.TypeRef("Fusee.Engine.Common.AxisValueChangedArgs")])), 
      InputDevice_add_AxisValueChanged
    );

    $.Method({Static:false, Public:true }, "add_ButtonValueChanged", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm03.TypeRef("Fusee.Engine.Common.ButtonValueChangedArgs")])), 
      InputDevice_add_ButtonValueChanged
    );

    $.Method({Static:false, Public:false}, "Disconnect", 
      JSIL.MethodSignature.Void, 
      InputDevice_Disconnect
    );

    $.Method({Static:false, Public:true }, "get_AxesCount", 
      JSIL.MethodSignature.Return($.Int32), 
      InputDevice_get_AxesCount
    );

    $.Method({Static:false, Public:true }, "get_AxisDesc", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm03.TypeRef("Fusee.Engine.Common.AxisDescription")])), 
      InputDevice_get_AxisDesc
    );

    $.Method({Static:false, Public:true }, "get_ButtonCount", 
      JSIL.MethodSignature.Return($.Int32), 
      InputDevice_get_ButtonCount
    );

    $.Method({Static:false, Public:true }, "get_ButtonDesc", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm03.TypeRef("Fusee.Engine.Common.ButtonDescription")])), 
      InputDevice_get_ButtonDesc
    );

    $.Method({Static:false, Public:true }, "get_Category", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.DeviceCategory")), 
      InputDevice_get_Category
    );

    $.Method({Static:false, Public:true }, "get_Desc", 
      JSIL.MethodSignature.Return($.String), 
      InputDevice_get_Desc
    );

    $.Method({Static:false, Public:false}, "get_DeviceImp", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")), 
      InputDevice_get_DeviceImp
    );

    $.Method({Static:false, Public:true }, "get_Id", 
      JSIL.MethodSignature.Return($.String), 
      InputDevice_get_Id
    );

    $.Method({Static:false, Public:true }, "get_IsConnected", 
      JSIL.MethodSignature.Return($.Boolean), 
      InputDevice_get_IsConnected
    );

    $.Method({Static:false, Public:true }, "get_NewAxisID", 
      JSIL.MethodSignature.Return($.Int32), 
      InputDevice_get_NewAxisID
    );

    $.Method({Static:false, Public:true }, "GetAxis", 
      new JSIL.MethodSignature($.Single, [$.Int32]), 
      InputDevice_GetAxis
    );

    $.Method({Static:false, Public:true }, "GetAxisDescription", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.AxisDescription"), [$.Int32]), 
      InputDevice_GetAxisDescription
    );

    $.Method({Static:false, Public:true }, "GetButton", 
      new JSIL.MethodSignature($.Boolean, [$.Int32]), 
      InputDevice_GetButton
    );

    $.Method({Static:false, Public:true }, "GetButtonDescription", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.ButtonDescription"), [$.Int32]), 
      InputDevice_GetButtonDescription
    );

    $.Method({Static:false, Public:true }, "IsButtonDown", 
      new JSIL.MethodSignature($.Boolean, [$.Int32]), 
      InputDevice_IsButtonDown
    );

    $.Method({Static:false, Public:true }, "IsButtonUp", 
      new JSIL.MethodSignature($.Boolean, [$.Int32]), 
      InputDevice_IsButtonUp
    );

    $.Method({Static:false, Public:false}, "OnImpAxisValueChanged", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.AxisValueChangedArgs")]), 
      InputDevice_OnImpAxisValueChanged
    );

    $.Method({Static:false, Public:false}, "OnImpButtonValueChanged", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.ButtonValueChangedArgs")]), 
      InputDevice_OnImpButtonValueChanged
    );

    $.Method({Static:false, Public:true }, "PostRender", 
      JSIL.MethodSignature.Void, 
      InputDevice_PostRender
    );

    $.Method({Static:false, Public:false}, "PreRender", 
      JSIL.MethodSignature.Void, 
      InputDevice_PreRender
    );

    $.Method({Static:false, Public:false}, "Reconnect", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")), 
      InputDevice_Reconnect
    );

    $.Method({Static:false, Public:true }, "RegisterCalculatedAxis", 
      new JSIL.MethodSignature(null, [
          $asm03.TypeRef("Fusee.Engine.Common.AxisDescription"), $asm04.TypeRef("Fusee.Engine.Core.InputDevice+AxisValueCalculator"), 
          $.Single
        ]), 
      InputDevice_RegisterCalculatedAxis
    );

    $.Method({Static:false, Public:true }, "RegisterSingleButtonAxis", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.AxisDescription"), [
          $.Int32, $asm03.TypeRef("Fusee.Engine.Common.AxisDirection"), 
          $.Single, $.Single, 
          $.Int32, $.String
        ]), 
      InputDevice_RegisterSingleButtonAxis
    );

    $.Method({Static:false, Public:true }, "RegisterTwoButtonAxis", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.AxisDescription"), [
          $.Int32, $.Int32, 
          $asm03.TypeRef("Fusee.Engine.Common.AxisDirection"), $.Single, 
          $.Single, $.Int32, 
          $.String
        ]), 
      InputDevice_RegisterTwoButtonAxis
    );

    $.Method({Static:false, Public:true }, "RegisterVelocityAxis", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.AxisDescription"), [
          $.Int32, $.Int32, 
          $.Int32, $.String, 
          $asm03.TypeRef("Fusee.Engine.Common.AxisDirection")
        ]), 
      InputDevice_RegisterVelocityAxis
    );

    $.Method({Static:false, Public:true }, "remove_AxisValueChanged", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm03.TypeRef("Fusee.Engine.Common.AxisValueChangedArgs")])), 
      InputDevice_remove_AxisValueChanged
    );

    $.Method({Static:false, Public:true }, "remove_ButtonValueChanged", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler`1", [$asm03.TypeRef("Fusee.Engine.Common.ButtonValueChangedArgs")])), 
      InputDevice_remove_ButtonValueChanged
    );

    $.Method({Static:false, Public:false}, "TryGetPolledAxis", 
      new JSIL.MethodSignature($.Boolean, [$.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Single])]), 
      InputDevice_TryGetPolledAxis
    );

    $.Field({Static:false, Public:false}, "_inpDevImp", $asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_axes", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.Int32, $asm03.TypeRef("Fusee.Engine.Common.AxisDescription")]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_axesToPoll", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.Int32, $.Single]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_axesToListen", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.Int32, $.Single]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_buttons", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.Int32, $asm03.TypeRef("Fusee.Engine.Common.ButtonDescription")]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_buttonsToPoll", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.Int32, $.Boolean]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_buttonsToListen", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.Int32, $.Boolean]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_buttonsToListenJustChanged", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.Int32, $.Boolean]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_buttonsUp", $asm14.TypeRef("System.Collections.Generic.HashSet`1", [$.Int32]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_buttonsDown", $asm14.TypeRef("System.Collections.Generic.HashSet`1", [$.Int32]));

    $.Field({Static:false, Public:false}, "_nextAxisId", $.Int32);

    $.Field({Static:false, Public:false}, "_isConnected", $.Boolean);

    $.Field({Static:false, Public:false}, "AxisValueChanged", $asm0E.TypeRef("System.EventHandler`1", [$asm03.TypeRef("Fusee.Engine.Common.AxisValueChangedArgs")]));

    $.Field({Static:false, Public:false}, "ButtonValueChanged", $asm0E.TypeRef("System.EventHandler`1", [$asm03.TypeRef("Fusee.Engine.Common.ButtonValueChangedArgs")]));

    $.Field({Static:false, Public:false}, "_calculatedAxes", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.Int32, $asm04.TypeRef("Fusee.Engine.Core.InputDevice+CalculatedAxisDescription")]));

    $.Property({Static:false, Public:false}, "DeviceImp", $asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp"));

    $.Property({Static:false, Public:true }, "NewAxisID", $.Int32);

    $.Property({Static:false, Public:true }, "IsConnected", $.Boolean);

    $.Property({Static:false, Public:true }, "Id", $.String);

    $.Property({Static:false, Public:true }, "Desc", $.String);

    $.Property({Static:false, Public:true }, "Category", $asm03.TypeRef("Fusee.Engine.Common.DeviceCategory"));

    $.Property({Static:false, Public:true }, "AxesCount", $.Int32);

    $.Property({Static:false, Public:true }, "AxisDesc", $asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm03.TypeRef("Fusee.Engine.Common.AxisDescription")]));

    $.Property({Static:false, Public:true }, "ButtonCount", $.Int32);

    $.Property({Static:false, Public:true }, "ButtonDesc", $asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm03.TypeRef("Fusee.Engine.Common.ButtonDescription")]));

    $.Event({Static:false, Public:true }, "AxisValueChanged", $asm0E.TypeRef("System.EventHandler`1", [$asm03.TypeRef("Fusee.Engine.Common.AxisValueChangedArgs")]));

    $.Event({Static:false, Public:true }, "ButtonValueChanged", $asm0E.TypeRef("System.EventHandler`1", [$asm03.TypeRef("Fusee.Engine.Common.ButtonValueChangedArgs")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate Fusee.Engine.Core.InputDevice+AxisValueCalculator */ 

JSIL.MakeDelegate("Fusee.Engine.Core.InputDevice+AxisValueCalculator", false, [], 
  new JSIL.MethodSignature($asm0E.TypeRef("System.Single"), [$asm0E.TypeRef("System.Single")]));

/* class Fusee.Engine.Core.InputDevice+CalculatedAxisDescription */ 

(function CalculatedAxisDescription$Members () {
  var $, $thisType;

  function CalculatedAxisDescription__ctor () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.InputDevice+CalculatedAxisDescription", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CalculatedAxisDescription__ctor
    );

    $.Field({Static:false, Public:true }, "AxisDesc", $asm03.TypeRef("Fusee.Engine.Common.AxisDescription"));

    $.Field({Static:false, Public:true }, "CurrentAxisValue", $.Single);

    $.Field({Static:false, Public:true }, "Calculator", $asm04.TypeRef("Fusee.Engine.Core.InputDevice+AxisValueCalculator"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.InputDevice+<>c__DisplayClass54_0 */ 

(function $l$gc__DisplayClass54_0$Members () {
  var $, $thisType;

  function $l$gc__DisplayClass54_0__ctor () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.InputDevice+<>c__DisplayClass54_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__DisplayClass54_0__ctor
    );

    $.Field({Static:false, Public:true }, "triggerButtonId", $.Int32);

    $.Field({Static:false, Public:true }, "origAxisId", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm04.TypeRef("Fusee.Engine.Core.InputDevice"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.InputDevice+<>c__DisplayClass54_1 */ 

(function $l$gc__DisplayClass54_1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };


  function $l$gc__DisplayClass54_1__ctor () {
  }; 

  function $l$gc__DisplayClass54_1_$lRegisterVelocityAxis$gb__0 (deltaTime) {
    var flag = +deltaTime <= 1.401298E-45;
    if (flag) {
      var result = 0;
    } else {
      var flag2 = !(this.CS$$l$g8__locals1.$l$g4__this).GetButton(this.CS$$l$g8__locals1.triggerButtonId);
      if (flag2) {
        this.closureOffLastTime = true;
        result = 0;
      } else {
        var flag3 = this.closureOffLastTime;
        if (flag3) {
          this.closureLastValue = +(this.CS$$l$g8__locals1.$l$g4__this).GetAxis(this.CS$$l$g8__locals1.origAxisId);
          this.closureOffLastTime = false;
        }
        var newVal = +(this.CS$$l$g8__locals1.$l$g4__this).GetAxis(this.CS$$l$g8__locals1.origAxisId);
        var ret = +(((newVal - +this.closureLastValue) / +deltaTime));
        this.closureLastValue = newVal;
        result = ret;
      }
    }
    return result;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.InputDevice+<>c__DisplayClass54_1", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__DisplayClass54_1__ctor
    );

    $.Method({Static:false, Public:false}, "$lRegisterVelocityAxis$gb__0", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      $l$gc__DisplayClass54_1_$lRegisterVelocityAxis$gb__0
    );

    $.Field({Static:false, Public:true }, "closureOffLastTime", $.Boolean);

    $.Field({Static:false, Public:true }, "closureLastValue", $.Single);

    $.Field({Static:false, Public:true }, "CS$$l$g8__locals1", $asm04.TypeRef("Fusee.Engine.Core.InputDevice+<>c__DisplayClass54_0"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.InputDevice+<>c__DisplayClass54_2 */ 

(function $l$gc__DisplayClass54_2$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };


  function $l$gc__DisplayClass54_2__ctor () {
  }; 

  function $l$gc__DisplayClass54_2_$lRegisterVelocityAxis$gb__1 (deltaTime) {
    var flag = +deltaTime <= 1.401298E-45;
    if (flag) {
      var result = 0;
    } else {
      var newVal = +(this.CS$$l$g8__locals2.$l$g4__this).GetAxis(this.CS$$l$g8__locals2.origAxisId);
      var ret = +(((newVal - +this.closureLastValue) / +deltaTime));
      this.closureLastValue = newVal;
      result = ret;
    }
    return result;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.InputDevice+<>c__DisplayClass54_2", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__DisplayClass54_2__ctor
    );

    $.Method({Static:false, Public:false}, "$lRegisterVelocityAxis$gb__1", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      $l$gc__DisplayClass54_2_$lRegisterVelocityAxis$gb__1
    );

    $.Field({Static:false, Public:true }, "closureLastValue", $.Single);

    $.Field({Static:false, Public:true }, "CS$$l$g8__locals2", $asm04.TypeRef("Fusee.Engine.Core.InputDevice+<>c__DisplayClass54_0"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.InputDevice+<>c__DisplayClass55_0 */ 

(function $l$gc__DisplayClass55_0$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };


  function $l$gc__DisplayClass55_0__ctor () {
  }; 

  function $l$gc__DisplayClass55_0_$lRegisterSingleButtonAxis$gb__0 (deltaTime) {
    var newBtnState = (this.$l$g4__this).GetButton(this.origButtonId);
    var flag = newBtnState !== this.closureLastBtnState;
    if (flag) {
      this.closureAnimDirection = +(((
          newBtnState
             ? 0
             : 1)
         | 0) - ((
          this.closureLastBtnState
             ? 0
             : 1)
         | 0));
      this.closureLastBtnState = newBtnState;
    }
    if (+this.closureAnimDirection > 0) {
      var ret = +this.closureLastAxisValue + +((+deltaTime / +this.rampUpTime));
      var flag3 = ret >= 1;
      if (flag3) {
        this.closureAnimDirection = 0;
        ret = 1;
      }
    } else {
      if (+this.closureAnimDirection < 0) {
        ret = +this.closureLastAxisValue - +((+deltaTime / +this.rampDownTime));
        var flag5 = ret < 0;
        if (flag5) {
          this.closureAnimDirection = 0;
          ret = 0;
        }
      } else {
        ret = +this.closureLastAxisValue;
      }
    }
    this.closureLastAxisValue = ret;
    return ret;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.InputDevice+<>c__DisplayClass55_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__DisplayClass55_0__ctor
    );

    $.Method({Static:false, Public:false}, "$lRegisterSingleButtonAxis$gb__0", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      $l$gc__DisplayClass55_0_$lRegisterSingleButtonAxis$gb__0
    );

    $.Field({Static:false, Public:true }, "origButtonId", $.Int32);

    $.Field({Static:false, Public:true }, "closureLastBtnState", $.Boolean);

    $.Field({Static:false, Public:true }, "closureAnimDirection", $.Single);

    $.Field({Static:false, Public:true }, "closureLastAxisValue", $.Single);

    $.Field({Static:false, Public:true }, "rampUpTime", $.Single);

    $.Field({Static:false, Public:true }, "rampDownTime", $.Single);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm04.TypeRef("Fusee.Engine.Core.InputDevice"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.InputDevice+<>c__DisplayClass56_0 */ 

(function $l$gc__DisplayClass56_0$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };


  function $l$gc__DisplayClass56_0__ctor () {
  }; 

  function $l$gc__DisplayClass56_0_$lRegisterTwoButtonAxis$gb__0 (deltaTime) {
    var newBtnStatePos = (this.$l$g4__this).GetButton(this.origButtonIdPositive);
    var flag = newBtnStatePos !== this.closureLastBtnStatePos;
    if (flag) {
      this.closureAnimDirection = +(((
          newBtnStatePos
             ? 1
             : 0)
         | 0) - ((
          this.closureLastBtnStatePos
             ? 1
             : 0)
         | 0));
      this.closureLastBtnStatePos = newBtnStatePos;
    }
    var newBtnStateNeg = (this.$l$g4__this).GetButton(this.origButtonIdNegative);
    var flag2 = newBtnStateNeg !== this.closureLastBtnStateNeg;
    if (flag2) {
      this.closureAnimDirection = +(-+(((
            newBtnStateNeg
               ? 1
               : 0)
           | 0) - ((
            this.closureLastBtnStateNeg
               ? 1
               : 0)
           | 0)));
      this.closureLastBtnStateNeg = newBtnStateNeg;
    }
    var animGoal = 0;
    var animTime = +this.rampDownTime;
    if (newBtnStatePos | newBtnStateNeg) {
      animGoal = +this.closureAnimDirection;
      animTime = +this.rampUpTime;
    }
    if (+this.closureAnimDirection > 0) {
      var ret = +this.closureLastAxisValue + +((+deltaTime / animTime));
      var flag5 = ret >= animGoal;
      if (flag5) {
        this.closureAnimDirection = 0;
        ret = animGoal;
      }
    } else {
      if (+this.closureAnimDirection < 0) {
        ret = +this.closureLastAxisValue - +((+deltaTime / animTime));
        var flag7 = ret <= animGoal;
        if (flag7) {
          this.closureAnimDirection = 0;
          ret = animGoal;
        }
      } else {
        ret = +this.closureLastAxisValue;
      }
    }
    this.closureLastAxisValue = ret;
    return ret;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.InputDevice+<>c__DisplayClass56_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__DisplayClass56_0__ctor
    );

    $.Method({Static:false, Public:false}, "$lRegisterTwoButtonAxis$gb__0", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      $l$gc__DisplayClass56_0_$lRegisterTwoButtonAxis$gb__0
    );

    $.Field({Static:false, Public:true }, "origButtonIdPositive", $.Int32);

    $.Field({Static:false, Public:true }, "closureLastBtnStatePos", $.Boolean);

    $.Field({Static:false, Public:true }, "closureAnimDirection", $.Single);

    $.Field({Static:false, Public:true }, "origButtonIdNegative", $.Int32);

    $.Field({Static:false, Public:true }, "closureLastBtnStateNeg", $.Boolean);

    $.Field({Static:false, Public:true }, "rampDownTime", $.Single);

    $.Field({Static:false, Public:true }, "rampUpTime", $.Single);

    $.Field({Static:false, Public:true }, "closureLastAxisValue", $.Single);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm04.TypeRef("Fusee.Engine.Core.InputDevice"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.JometriMesh */ 

(function JometriMesh$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm08.Fusee.Jometri.Geometry)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt16))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm08.Fusee.Jometri.Face))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm08.Fusee.Jometri.Face)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm14.System.Linq.Enumerable)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.UInt16)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm08.Fusee.Jometri.Vertex))) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm08.Fusee.Jometri.Vertex)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.ArgumentException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.float3), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentException, [$asm0E.System.String]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float3")]))) ();
  };


  function JometriMesh__ctor (geometry) {
    var vertices = new JSIL.BoxedVariable(null);
    var triangles = new JSIL.BoxedVariable(null);
    var normals = new JSIL.BoxedVariable(null);
    $T04().prototype._ctor.call(this);
    $thisType.ConvertToMesh(geometry, /* ref */ vertices, /* ref */ triangles, /* ref */ normals);
    this.set_Vertices(vertices.get());
    this.set_Triangles(triangles.get());
    this.set_Normals($T03().prototype.ToArray.call(normals.get()));
  }; 

  function JometriMesh_ConvertToMesh (geometry, /* ref */ vertices, /* ref */ triangles, /* ref */ normals) {
    var $temp00, $temp01;
    var faces = $T07().ToList$b1($T06())(geometry.GetAllFaces());
    var flag = (faces.get_Item(0).Handle | 0) === 1;
    if (flag) {
      faces.RemoveAt(0);
    }
    var triangleCount = (faces.get_Count() | 0);
    var vertCount = Math.imul(triangleCount, 3);
    var verts = $S00().Construct();
    vertices.set(JSIL.Array.New($T0A(), vertCount));
    triangles.set(JSIL.Array.New($T0B(), vertCount));
    normals.set($S00().Construct());

    for (var a$0 = faces._items, i$0 = 0, l$0 = (faces._size | 0); i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var face = a$0[i$0].MemberwiseClone();
      if ((face.Handle | 0) !== 1) {
        var faceVerts = $T07().ToList$b1($T0D())(geometry.GetFaceVertices(face.Handle));
        var flag3 = (faceVerts.get_Count() | 0) > 3;
        if (flag3) {
          throw $S01().Construct("Invalid triangle - face has more than 3 Vertices");
        }

        for (var a$1 = faceVerts._items, i$1 = 0, l$1 = (faceVerts._size | 0); i$1 < l$1; ($temp01 = i$1, 
            i$1 = ((i$1 + 1) | 0), 
            $temp01)) {
          var vertex = a$1[i$1].MemberwiseClone();
          $S02().CallVirtual("Add", null, verts, vertex.VertData.Pos.MemberwiseClone());
          var flag4 = $T0A().op_Equality(face.FaceData.FaceNormal.MemberwiseClone(), $T0A().Zero.MemberwiseClone());
          if (flag4) {
            geometry.SetFaceNormal($T07().ToList$b1($T0D())(geometry.GetFaceOuterVertices(face.Handle)), face);
          }
          $S02().CallVirtual("Add", null, normals.get(), face.FaceData.FaceNormal.MemberwiseClone());
        }
      }
    }

    for (var i = 0; i < (vertices.get().length | 0); i = ((i + 1) | 0)) {
      vertices.get()[i] = verts.get_Item(i).MemberwiseClone();
      triangles.get()[i] = (i & 0xFFFF);
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.Mesh"), 
      Name: "Fusee.Engine.Core.JometriMesh", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm08.TypeRef("Fusee.Jometri.Geometry")), 
      JometriMesh__ctor
    );

    $.Method({Static:true , Public:false}, "ConvertToMesh", 
      new JSIL.MethodSignature(null, [
          $asm08.TypeRef("Fusee.Jometri.Geometry"), $jsilcore.TypeRef("JSIL.Reference", [$jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")])]), 
          $jsilcore.TypeRef("JSIL.Reference", [$jsilcore.TypeRef("System.Array", [$.UInt16])]), $jsilcore.TypeRef("JSIL.Reference", [$asm0E.TypeRef("System.Collections.Generic.List`1", [$asm09.TypeRef("Fusee.Math.Core.float3")])])
        ]), 
      JometriMesh_ConvertToMesh
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.KeyboardDevice */ 

(function KeyboardDevice$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisDirection)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.KeyCodes)) ();
  };


  function KeyboardDevice__ctor (inpDeviceImp) {
    $T01().prototype._ctor.call(this, inpDeviceImp);
    this._leftRightAxis = (this.RegisterTwoButtonAxis(
      37, 
      39, 
      $T02().X, 
      0.15, 
      0.35, 
      0, 
      null
    ).Id | 0);
    this._upDownAxis = (this.RegisterTwoButtonAxis(
      40, 
      38, 
      $T02().Y, 
      0.15, 
      0.35, 
      0, 
      null
    ).Id | 0);
    this._adAxis = (this.RegisterTwoButtonAxis(
      65, 
      68, 
      $T02().X, 
      0.15, 
      0.35, 
      0, 
      null
    ).Id | 0);
    this._wsAxis = (this.RegisterTwoButtonAxis(
      83, 
      87, 
      $T02().Y, 
      0.15, 
      0.35, 
      0, 
      null
    ).Id | 0);
  }; 

  function KeyboardDevice_get_ADAxis () {
    return this.GetAxis(this._adAxis);
  }; 

  function KeyboardDevice_get_LeftRightAxis () {
    return this.GetAxis(this._leftRightAxis);
  }; 

  function KeyboardDevice_get_UpDownAxis () {
    return this.GetAxis(this._upDownAxis);
  }; 

  function KeyboardDevice_get_WSAxis () {
    return this.GetAxis(this._wsAxis);
  }; 

  function KeyboardDevice_GetKey (key) {
    return this.GetButton(key.valueOf());
  }; 

  function KeyboardDevice_IsKeyDown (key) {
    return this.IsButtonDown(key.valueOf());
  }; 

  function KeyboardDevice_IsKeyUp (key) {
    return this.IsButtonUp(key.valueOf());
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.InputDevice"), 
      Name: "Fusee.Engine.Core.KeyboardDevice", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")), 
      KeyboardDevice__ctor
    );

    $.Method({Static:false, Public:true }, "get_ADAxis", 
      JSIL.MethodSignature.Return($.Single), 
      KeyboardDevice_get_ADAxis
    );

    $.Method({Static:false, Public:true }, "get_LeftRightAxis", 
      JSIL.MethodSignature.Return($.Single), 
      KeyboardDevice_get_LeftRightAxis
    );

    $.Method({Static:false, Public:true }, "get_UpDownAxis", 
      JSIL.MethodSignature.Return($.Single), 
      KeyboardDevice_get_UpDownAxis
    );

    $.Method({Static:false, Public:true }, "get_WSAxis", 
      JSIL.MethodSignature.Return($.Single), 
      KeyboardDevice_get_WSAxis
    );

    $.Method({Static:false, Public:true }, "GetKey", 
      new JSIL.MethodSignature($.Boolean, [$asm03.TypeRef("Fusee.Engine.Common.KeyCodes")]), 
      KeyboardDevice_GetKey
    );

    $.Method({Static:false, Public:true }, "IsKeyDown", 
      new JSIL.MethodSignature($.Boolean, [$asm03.TypeRef("Fusee.Engine.Common.KeyCodes")]), 
      KeyboardDevice_IsKeyDown
    );

    $.Method({Static:false, Public:true }, "IsKeyUp", 
      new JSIL.MethodSignature($.Boolean, [$asm03.TypeRef("Fusee.Engine.Common.KeyCodes")]), 
      KeyboardDevice_IsKeyUp
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_leftRightAxis", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_upDownAxis", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_adAxis", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_wsAxis", $.Int32);

    $.Property({Static:false, Public:true }, "UpDownAxis", $.Single);

    $.Property({Static:false, Public:true }, "LeftRightAxis", $.Single);

    $.Property({Static:false, Public:true }, "ADAxis", $.Single);

    $.Property({Static:false, Public:true }, "WSAxis", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.MeshReader */ 

(function MeshReader$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize(System.Array.Of($asm0E.System.Char))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.String))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize(System.Array.Of($asm0E.System.String))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Char)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.IO.Stream)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.IO.StreamReader)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Engine.Core.Geometry)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.IDisposable)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.IO.TextReader)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm09.Fusee.Math.Core.double2)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm09.Fusee.Math.Core.double3)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.ArgumentOutOfRangeException)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize(System.Array.Of($asm0E.System.Object))) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize(System.Array.Of($asm0E.System.Int32))) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.FormatException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.String), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.String")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.IO.StreamReader, [$asm0E.System.IO.Stream]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.double2, [$asm0E.System.Double, $asm0E.System.Double]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.double3, [
        $asm0E.System.Double, $asm0E.System.Double, 
        $asm0E.System.Double
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentOutOfRangeException, [$asm0E.System.String]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.FormatException, [$asm0E.System.String]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0E.System.IDisposable.Dispose)) ();
  };



  function MeshReader_FilteredSplit (strIn, separator) {
    var ret = $S00().Construct();
    var array = (JSIL.SplitString(strIn, separator));

    for (var i = 0; i < (array.length | 0); i = ((i + 1) | 0)) {
      var s = array[i];
      var flag = !$T00().IsNullOrEmpty(s);
      if (flag) {
        $S01().CallVirtual("Add", null, ret, s);
      }
    }
    return $T02().prototype.ToArray.call(ret);
  }; 

  function MeshReader_LoadGeometry (stream) {
    var obj = $S02().Construct(stream);
    try {
      var result = $thisType.ReadWavefrontObj(obj);
    } finally {
      if (obj !== null) {
        $IM00().Call(obj, null);
      }
    }
    return result;
  }; 

  function MeshReader_LoadMesh (stream) {
    var obj = $S02().Construct(stream);
    try {
      var geo = $thisType.ReadWavefrontObj(obj);
      var result = geo.ToMesh();
    } finally {
      if (obj !== null) {
        $IM00().Call(obj, null);
      }
    }
    return result;
  }; 

  function MeshReader_ReadWavefrontObj (tr) {
    var g = new ($T09())();
    var nFaceRefs = 0;
    var lineNumber = 1;
    var line = tr.ReadLine();

    while (line !== null) {
      var flag = (System.String.StartsWith(line, "#"));
      if (!flag) {
        var flag2 = (System.String.StartsWith(line, "vt"));
        if (flag2) {
          var tmp = (line.substr(3));
          var values = $thisType.FilteredSplit(tmp, null);
          g.AddTexCoord($S03().Construct($thisType.Double_Parse(values[0]), $thisType.Double_Parse(values[1])));
        } else {
          var flag3 = (System.String.StartsWith(line, "vn"));
          if (flag3) {
            var tmp2 = (line.substr(3));
            var values2 = $thisType.FilteredSplit(tmp2, null);
            g.AddNormal($S04().Construct($thisType.Double_Parse(values2[0]), $thisType.Double_Parse(values2[1]), -$thisType.Double_Parse(values2[2])));
          } else {
            var flag4 = (System.String.StartsWith(line, "v"));
            if (flag4) {
              var tmp3 = (line.substr(2));
              var values3 = $thisType.FilteredSplit(tmp3, null);
              g.AddVertex($S04().Construct($thisType.Double_Parse(values3[0]), $thisType.Double_Parse(values3[1]), -$thisType.Double_Parse(values3[2])));
            } else {
              var flag5 = (System.String.StartsWith(line, "f"));
              if (flag5) {
                var tmp4 = (line.substr(2));
                var values4 = $thisType.FilteredSplit(tmp4, null);
                var flag6 = (3 > (values4.length | 0)) || 
                ((values4.length | 0) >= 256);
                if (flag6) {
                  throw $S05().Construct(JSIL.ConcatString.apply(null, JSIL.Array.New($T10(), ["Error reading obj file (", $T05().$Box(lineNumber), "). Face definition number of vertices must be within [3..", $T05().$Box(256), "]."])));
                }
                var vI = JSIL.Array.New($T05(), values4.length);
                var nI = null;
                var tI = null;
                var i = 0;
                var array = values4;

                for (var j = 0; j < (array.length | 0); j = ((j + 1) | 0)) {
                  var vRef = array[j];
                  var vDef = (JSIL.SplitString(vRef, JSIL.Array.New($T04(), ["/"])));
                  var flag7 = nFaceRefs === 0;
                  if (flag7) {
                    var flag8 = (1 > (vDef.length | 0)) || 
                    ((vDef.length | 0) > 3);
                    if (flag8) {
                      throw $S05().Construct(JSIL.ConcatString("Error reading obj file (", $T05().$Box(lineNumber), "). Face definitions must contain 1, 2 or 3 indices per vertex"));
                    }
                    nFaceRefs = (vDef.length | 0);
                  } else {
                    var flag9 = (vDef.length | 0) !== nFaceRefs;
                    if (flag9) {
                      throw $S05().Construct(JSIL.ConcatString("Error reading obj file (", $T05().$Box(lineNumber), "). Inconsistent face definitions"));
                    }
                  }
                  vI[i] = ((($T05().Parse(vDef[0]) | 0) - 1) | 0);
                  var flag10 = ((vDef.length | 0) > 1) && 
                  !$T00().IsNullOrEmpty(vDef[1]);
                  if (flag10) {
                    var flag11 = tI === null;
                    if (flag11) {
                      tI = JSIL.Array.New($T05(), values4.length);
                    }
                    tI[i] = ((($T05().Parse(vDef[1]) | 0) - 1) | 0);
                  }
                  var flag12 = (vDef.length | 0) > 2;
                  if (flag12) {
                    var flag13 = $T00().IsNullOrEmpty(vDef[1]);
                    if (flag13) {
                      throw $S06().Construct(JSIL.ConcatString("Error reading obj file (", $T05().$Box(lineNumber), "). Syntax error in face definition"));
                    }
                    var flag14 = nI === null;
                    if (flag14) {
                      nI = JSIL.Array.New($T05(), values4.length);
                    }
                    nI[i] = ((($T05().Parse(vDef[2]) | 0) - 1) | 0);
                  }
                  i = ((i + 1) | 0);
                }
                g.AddFace(vI, tI, nI);
              } else {
                var flag15 = (System.String.StartsWith(line, "mtllib"));
                if (!flag15) {
                  var flag16 = (System.String.StartsWith(line, "usemtl"));
                  if (flag16) {
                  }
                }
              }
            }
          }
        }
      }
      line = tr.ReadLine();
      lineNumber = ((lineNumber + 1) | 0);
    }
    var flag17 = !g.get_HasNormals();
    if (flag17) {
      g.CreateNormals(1.396263111111111);
    }
    return g;
  }; 

  JSIL.MakeStaticClass("Fusee.Engine.Core.MeshReader", true, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "Double_Parse", 
      new JSIL.MethodSignature($.Double, [$.String])
    );

    $.Method({Static:true , Public:true }, "FilteredSplit", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.String]), [$.String, $jsilcore.TypeRef("System.Array", [$.Char])]), 
      MeshReader_FilteredSplit
    );

    $.Method({Static:true , Public:true }, "LoadGeometry", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.Geometry"), [$asm0E.TypeRef("System.IO.Stream")]), 
      MeshReader_LoadGeometry
    );

    $.Method({Static:true , Public:true }, "LoadMesh", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.Mesh"), [$asm0E.TypeRef("System.IO.Stream")]), 
      MeshReader_LoadMesh
    );

    $.Method({Static:true , Public:true }, "ReadWavefrontObj", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.Geometry"), [$asm0E.TypeRef("System.IO.TextReader")]), 
      MeshReader_ReadWavefrontObj
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.MouseDevice */ 

(function MouseDevice$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisDirection)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm03.Fusee.Engine.Common.Point)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };


  function MouseDevice__ctor (inpDeviceImp) {
    $T01().prototype._ctor.call(this, inpDeviceImp);
    this._xVelId = (this.RegisterVelocityAxis(
      1, 
      0, 
      0, 
      null, 
      $T02().Unknown
    ).Id | 0);
    this._yVelId = (this.RegisterVelocityAxis(
      2, 
      0, 
      0, 
      null, 
      $T02().Unknown
    ).Id | 0);
    this._wheelVelId = (this.RegisterVelocityAxis(
      3, 
      0, 
      0, 
      null, 
      $T02().Unknown
    ).Id | 0);
  }; 

  function MouseDevice_get_LeftButton () {
    return this.GetButton(1);
  }; 

  function MouseDevice_get_LeftButtonDesc () {
    return this.GetButtonDescription(1);
  }; 

  function MouseDevice_get_MiddleButton () {
    return this.GetButton(4);
  }; 

  function MouseDevice_get_MiddleButtonDesc () {
    return this.GetButtonDescription(4);
  }; 

  function MouseDevice_get_Position () {
    return $S00().Construct(this.GetAxis(1), this.GetAxis(2));
  }; 

  function MouseDevice_get_PositionInt () {
    var result = new ($T04())();
    result.x = ((this.GetAxis(1)) | 0);
    result.y = ((this.GetAxis(2)) | 0);
    result.z = ((this.GetAxis(3)) | 0);
    return result;
  }; 

  function MouseDevice_get_RightButton () {
    return this.GetButton(2);
  }; 

  function MouseDevice_get_RightButtonDesc () {
    return this.GetButtonDescription(2);
  }; 

  function MouseDevice_get_Velocity () {
    return $S00().Construct(this.GetAxis(this._xVelId), this.GetAxis(this._yVelId));
  }; 

  function MouseDevice_get_VelocityInt () {
    var result = new ($T04())();
    result.x = ((this.GetAxis(this._xVelId)) | 0);
    result.y = ((this.GetAxis(this._yVelId)) | 0);
    result.z = ((this.GetAxis(this._wheelVelId)) | 0);
    return result;
  }; 

  function MouseDevice_get_Wheel () {
    return this.GetAxis(3);
  }; 

  function MouseDevice_get_WheelDesc () {
    return this.GetAxisDescription(3);
  }; 

  function MouseDevice_get_WheelVel () {
    return this.GetAxis(this._wheelVelId);
  }; 

  function MouseDevice_get_WheelVelDesc () {
    return this.GetAxisDescription(this._wheelVelId);
  }; 

  function MouseDevice_get_X () {
    return this.GetAxis(1);
  }; 

  function MouseDevice_get_XDesc () {
    return this.GetAxisDescription(1);
  }; 

  function MouseDevice_get_XVel () {
    return this.GetAxis(this._xVelId);
  }; 

  function MouseDevice_get_XVelDesc () {
    return this.GetAxisDescription(this._xVelId);
  }; 

  function MouseDevice_get_Y () {
    return this.GetAxis(2);
  }; 

  function MouseDevice_get_YDesc () {
    return this.GetAxisDescription(2);
  }; 

  function MouseDevice_get_YVel () {
    return this.GetAxis(this._yVelId);
  }; 

  function MouseDevice_get_YVelDesc () {
    return this.GetAxisDescription(this._yVelId);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.InputDevice"), 
      Name: "Fusee.Engine.Core.MouseDevice", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")), 
      MouseDevice__ctor
    );

    $.Method({Static:false, Public:true }, "get_LeftButton", 
      JSIL.MethodSignature.Return($.Boolean), 
      MouseDevice_get_LeftButton
    );

    $.Method({Static:false, Public:true }, "get_LeftButtonDesc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.ButtonDescription")), 
      MouseDevice_get_LeftButtonDesc
    );

    $.Method({Static:false, Public:true }, "get_MiddleButton", 
      JSIL.MethodSignature.Return($.Boolean), 
      MouseDevice_get_MiddleButton
    );

    $.Method({Static:false, Public:true }, "get_MiddleButtonDesc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.ButtonDescription")), 
      MouseDevice_get_MiddleButtonDesc
    );

    $.Method({Static:false, Public:true }, "get_Position", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float2")), 
      MouseDevice_get_Position
    );

    $.Method({Static:false, Public:true }, "get_PositionInt", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.Point")), 
      MouseDevice_get_PositionInt
    );

    $.Method({Static:false, Public:true }, "get_RightButton", 
      JSIL.MethodSignature.Return($.Boolean), 
      MouseDevice_get_RightButton
    );

    $.Method({Static:false, Public:true }, "get_RightButtonDesc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.ButtonDescription")), 
      MouseDevice_get_RightButtonDesc
    );

    $.Method({Static:false, Public:true }, "get_Velocity", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float2")), 
      MouseDevice_get_Velocity
    );

    $.Method({Static:false, Public:true }, "get_VelocityInt", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.Point")), 
      MouseDevice_get_VelocityInt
    );

    $.Method({Static:false, Public:true }, "get_Wheel", 
      JSIL.MethodSignature.Return($.Single), 
      MouseDevice_get_Wheel
    );

    $.Method({Static:false, Public:true }, "get_WheelDesc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.AxisDescription")), 
      MouseDevice_get_WheelDesc
    );

    $.Method({Static:false, Public:true }, "get_WheelVel", 
      JSIL.MethodSignature.Return($.Single), 
      MouseDevice_get_WheelVel
    );

    $.Method({Static:false, Public:true }, "get_WheelVelDesc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.AxisDescription")), 
      MouseDevice_get_WheelVelDesc
    );

    $.Method({Static:false, Public:true }, "get_X", 
      JSIL.MethodSignature.Return($.Single), 
      MouseDevice_get_X
    );

    $.Method({Static:false, Public:true }, "get_XDesc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.AxisDescription")), 
      MouseDevice_get_XDesc
    );

    $.Method({Static:false, Public:true }, "get_XVel", 
      JSIL.MethodSignature.Return($.Single), 
      MouseDevice_get_XVel
    );

    $.Method({Static:false, Public:true }, "get_XVelDesc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.AxisDescription")), 
      MouseDevice_get_XVelDesc
    );

    $.Method({Static:false, Public:true }, "get_Y", 
      JSIL.MethodSignature.Return($.Single), 
      MouseDevice_get_Y
    );

    $.Method({Static:false, Public:true }, "get_YDesc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.AxisDescription")), 
      MouseDevice_get_YDesc
    );

    $.Method({Static:false, Public:true }, "get_YVel", 
      JSIL.MethodSignature.Return($.Single), 
      MouseDevice_get_YVel
    );

    $.Method({Static:false, Public:true }, "get_YVelDesc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.AxisDescription")), 
      MouseDevice_get_YVelDesc
    );

    $.Field({Static:false, Public:false}, "_xVelId", $.Int32);

    $.Field({Static:false, Public:false}, "_yVelId", $.Int32);

    $.Field({Static:false, Public:false}, "_wheelVelId", $.Int32);

    $.Property({Static:false, Public:true }, "PositionInt", $asm03.TypeRef("Fusee.Engine.Common.Point"));

    $.Property({Static:false, Public:true }, "Position", $asm09.TypeRef("Fusee.Math.Core.float2"));

    $.Property({Static:false, Public:true }, "X", $.Single);

    $.Property({Static:false, Public:true }, "Y", $.Single);

    $.Property({Static:false, Public:true }, "Wheel", $.Single);

    $.Property({Static:false, Public:true }, "VelocityInt", $asm03.TypeRef("Fusee.Engine.Common.Point"));

    $.Property({Static:false, Public:true }, "Velocity", $asm09.TypeRef("Fusee.Math.Core.float2"));

    $.Property({Static:false, Public:true }, "XVel", $.Single);

    $.Property({Static:false, Public:true }, "YVel", $.Single);

    $.Property({Static:false, Public:true }, "WheelVel", $.Single);

    $.Property({Static:false, Public:true }, "XDesc", $asm03.TypeRef("Fusee.Engine.Common.AxisDescription"));

    $.Property({Static:false, Public:true }, "YDesc", $asm03.TypeRef("Fusee.Engine.Common.AxisDescription"));

    $.Property({Static:false, Public:true }, "WheelDesc", $asm03.TypeRef("Fusee.Engine.Common.AxisDescription"));

    $.Property({Static:false, Public:true }, "XVelDesc", $asm03.TypeRef("Fusee.Engine.Common.AxisDescription"));

    $.Property({Static:false, Public:true }, "YVelDesc", $asm03.TypeRef("Fusee.Engine.Common.AxisDescription"));

    $.Property({Static:false, Public:true }, "WheelVelDesc", $asm03.TypeRef("Fusee.Engine.Common.AxisDescription"));

    $.Property({Static:false, Public:true }, "LeftButton", $.Boolean);

    $.Property({Static:false, Public:true }, "MiddleButton", $.Boolean);

    $.Property({Static:false, Public:true }, "RightButton", $.Boolean);

    $.Property({Static:false, Public:true }, "LeftButtonDesc", $asm03.TypeRef("Fusee.Engine.Common.ButtonDescription"));

    $.Property({Static:false, Public:true }, "MiddleButtonDesc", $asm03.TypeRef("Fusee.Engine.Common.ButtonDescription"));

    $.Property({Static:false, Public:true }, "RightButtonDesc", $asm03.TypeRef("Fusee.Engine.Common.ButtonDescription"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.MultiSphereShape */ 

(function MultiSphereShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMultiSphereShapeImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.CapsuleShape)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMultiSphereShapeImp.get_SphereCount)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMultiSphereShapeImp.GetSpherePosition)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IMultiSphereShapeImp.GetSphereRadius)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function MultiSphereShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function MultiSphereShape_get_Margin () {
    return $IM00().Call(this._multiSphereShapeImp, null);
  }; 

  function MultiSphereShape_get_SphereCount () {
    return $IM01().Call(this._multiSphereShapeImp, null);
  }; 

  function MultiSphereShape_GetSpherePosition (index) {
    return $IM02().Call(this._multiSphereShapeImp, null, index);
  }; 

  function MultiSphereShape_GetSphereRadius (index) {
    return $IM03().Call(this._multiSphereShapeImp, null, index);
  }; 

  function MultiSphereShape_set_Margin (value) {
    var o = $T05().$Cast($IM04().Call(this._multiSphereShapeImp, null));
    $IM05().Call(o._capsuleShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.MultiSphereShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      MultiSphereShape__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      MultiSphereShape_get_Margin
    );

    $.Method({Static:false, Public:true }, "get_SphereCount", 
      JSIL.MethodSignature.Return($.Int32), 
      MultiSphereShape_get_SphereCount
    );

    $.Method({Static:false, Public:true }, "GetSpherePosition", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.float3"), [$.Int32]), 
      MultiSphereShape_GetSpherePosition
    );

    $.Method({Static:false, Public:true }, "GetSphereRadius", 
      new JSIL.MethodSignature($.Single, [$.Int32]), 
      MultiSphereShape_GetSphereRadius
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      MultiSphereShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_multiSphereShapeImp", $asm03.TypeRef("Fusee.Engine.Common.IMultiSphereShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);

    $.Property({Static:false, Public:true }, "SphereCount", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Point2PointConstraint */ 

(function Point2PointConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IPoint2PointConstraintImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.RigidBody)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm03.Fusee.Engine.Common.PointToPointFlags)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IPoint2PointConstraintImp.get_PivotInA)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IPoint2PointConstraintImp.get_PivotInB)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_UserObject)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyA)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyB)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IPoint2PointConstraintImp.GetParam)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.GetUid)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_UserObject)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IPoint2PointConstraintImp.SetParam)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.IPoint2PointConstraintImp.UpdateRhs)) ();
  };


  function Point2PointConstraint__ctor () {
  }; 

  function Point2PointConstraint_get_PivotInA () {
    return $IM00().Call(this._iP2PConstraintImp, null);
  }; 

  function Point2PointConstraint_get_PivotInB () {
    return $IM01().Call(this._iP2PConstraintImp, null);
  }; 

  function Point2PointConstraint_get_RigidBodyA () {
    var retval = $IM02().Call($IM03().Call(this._iP2PConstraintImp, null), null);
    return $T04().$Cast(retval);
  }; 

  function Point2PointConstraint_get_RigidBodyB () {
    var retval = $IM02().Call($IM04().Call(this._iP2PConstraintImp, null), null);
    return $T04().$Cast(retval);
  }; 

  function Point2PointConstraint_GetParam (param, axis) {
    return $IM05().Call(this._iP2PConstraintImp, null, param, axis);
  }; 

  function Point2PointConstraint_GetUid () {
    return $IM06().Call(this._iP2PConstraintImp, null);
  }; 

  function Point2PointConstraint_set_PivotInA (value) {
    var o = $thisType.$Cast($IM07().Call(this._iP2PConstraintImp, null));
    (o._iP2PConstraintImp.PivotInA = value.MemberwiseClone());
  }; 

  function Point2PointConstraint_set_PivotInB (value) {
    var o = $thisType.$Cast($IM07().Call(this._iP2PConstraintImp, null));
    (o._iP2PConstraintImp.PivotInB = value.MemberwiseClone());
  }; 

  function Point2PointConstraint_SetParam (param, value, axis) {
    var o = $thisType.$Cast($IM07().Call(this._iP2PConstraintImp, null));
    $IM08().Call(o._iP2PConstraintImp, null, param, value, axis);
  }; 

  function Point2PointConstraint_UpdateRhS (timeStep) {
    var o = $thisType.$Cast($IM07().Call(this._iP2PConstraintImp, null));
    $IM09().Call(o._iP2PConstraintImp, null, timeStep);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Point2PointConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Point2PointConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "get_PivotInA", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Point2PointConstraint_get_PivotInA
    );

    $.Method({Static:false, Public:true }, "get_PivotInB", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Point2PointConstraint_get_PivotInB
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyA", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      Point2PointConstraint_get_RigidBodyA
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyB", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      Point2PointConstraint_get_RigidBodyB
    );

    $.Method({Static:false, Public:true }, "GetParam", 
      new JSIL.MethodSignature($.Single, [$asm03.TypeRef("Fusee.Engine.Common.PointToPointFlags"), $.Int32]), 
      Point2PointConstraint_GetParam
    );

    $.Method({Static:false, Public:true }, "GetUid", 
      JSIL.MethodSignature.Return($.Int32), 
      Point2PointConstraint_GetUid
    );

    $.Method({Static:false, Public:true }, "set_PivotInA", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Point2PointConstraint_set_PivotInA
    );

    $.Method({Static:false, Public:true }, "set_PivotInB", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      Point2PointConstraint_set_PivotInB
    );

    $.Method({Static:false, Public:true }, "SetParam", 
      new JSIL.MethodSignature(null, [
          $asm03.TypeRef("Fusee.Engine.Common.PointToPointFlags"), $.Single, 
          $.Int32
        ]), 
      Point2PointConstraint_SetParam
    );

    $.Method({Static:false, Public:true }, "UpdateRhS", 
      JSIL.MethodSignature.Action($.Single), 
      Point2PointConstraint_UpdateRhS
    );

    $.Field({Static:false, Public:false}, "_iP2PConstraintImp", $asm03.TypeRef("Fusee.Engine.Common.IPoint2PointConstraintImp"));

    $.Property({Static:false, Public:true }, "PivotInA", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "PivotInB", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "RigidBodyA", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));

    $.Property({Static:false, Public:true }, "RigidBodyB", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.RigidBody */ 

(function RigidBody$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.EventHandler)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.RigidBody_$l$gc)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Delegate)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Threading.Interlocked)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm04.$lPrivateImplementationDetails$g)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Engine.Core.ConeShape)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IConeShapeImp)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm04.Fusee.Engine.Core.BoxShape)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IBoxShapeImp)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm04.Fusee.Engine.Core.StaticPlaneShape)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IStaticPlaneShapeImp)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm04.Fusee.Engine.Core.GImpactMeshShape)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm03.Fusee.Engine.Common.IGImpactMeshShapeImp)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm04.Fusee.Engine.Core.CylinderShape)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICylinderShapeImp)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm04.Fusee.Engine.Core.CapsuleShape)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICapsuleShapeImp)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm04.Fusee.Engine.Core.EmptyShape)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm03.Fusee.Engine.Common.IEmptyShapeImp)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm04.Fusee.Engine.Core.CompoundShape)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm03.Fusee.Engine.Common.ICompoundShapeImp)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm04.Fusee.Engine.Core.MultiSphereShape)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm03.Fusee.Engine.Common.IMultiSphereShapeImp)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm04.Fusee.Engine.Core.ConvexHullShape)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm03.Fusee.Engine.Common.IConvexHullShapeImp)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm04.Fusee.Engine.Core.SphereShape)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISphereShapeImp)) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm11.System.Diagnostics.Debug)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm0E.System.EventArgs]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0E.TypeRef("System.String")))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_UserObject)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.ApplyCentralForce)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.ApplyCentralImpulse)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.ApplyForce)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.ApplyImpulse)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.ApplyTorque)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.ApplyTorqueImpulse)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_AngularDrag)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_LinearFactor)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_AngularVelocity)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_CollisionShape)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_UserObject)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_Friction)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_Gravity)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_Inertia)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_LinearDrag)) ();
  };
  var $IM10 = function () {
    return ($IM10 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_LinearVelocity)) ();
  };
  var $IM11 = function () {
    return ($IM11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_Mass)) ();
  };
  var $IM12 = function () {
    return ($IM12 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_Position)) ();
  };
  var $IM13 = function () {
    return ($IM13 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_Restitution)) ();
  };
  var $IM14 = function () {
    return ($IM14 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_WorldTransform)) ();
  };
  var $IM15 = function () {
    return ($IM15 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_Rotation)) ();
  };
  var $IM16 = function () {
    return ($IM16 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.set_CollisionShape)) ();
  };
  var $IM17 = function () {
    return ($IM17 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.set_Friction)) ();
  };
  var $IM18 = function () {
    return ($IM18 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.set_Mass)) ();
  };
  var $IM19 = function () {
    return ($IM19 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.set_Restitution)) ();
  };
  var $IM1A = function () {
    return ($IM1A = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.SetDrag)) ();
  };


  function RigidBody__ctor () {
    var arg_20_1 = null;
    if ((arg_20_1 = $T01().$l$g9__52_0) === null) {
      arg_20_1 = $T01().$l$g9__52_0 = $T00().New($T01().$l$g9, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.RigidBody_$l$gc, "$l_ctor$gb__52_0", $S00(), false, false));
    }
    this.WhileCollidingEvent = arg_20_1;
  }; 

  function RigidBody_add_WhileCollidingEvent (value) {
    var eventHandler = this.WhileCollidingEvent;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T02().Combine(eventHandler2, value);
      eventHandler = $T03().CompareExchange$b1($T00())(/* ref */ new JSIL.MemberReference(this, "WhileCollidingEvent"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  function RigidBody_ApplyCentralForce (centralForce) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    $IM01().Call(o._iRigidBodyImp, null, centralForce.MemberwiseClone());
  }; 

  function RigidBody_ApplyCentralImpulse (centralImpulse) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    $IM02().Call(o._iRigidBodyImp, null, centralImpulse.MemberwiseClone());
  }; 

  function RigidBody_ApplyForce (force, relPos) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    $IM03().Call(o._iRigidBodyImp, null, force.MemberwiseClone(), relPos.MemberwiseClone());
  }; 

  function RigidBody_ApplyImpulse (impulse, relPos) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    $IM04().Call(o._iRigidBodyImp, null, impulse.MemberwiseClone(), relPos.MemberwiseClone());
  }; 

  function RigidBody_ApplyTorque (torque) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    $IM05().Call(o._iRigidBodyImp, null, torque.MemberwiseClone());
  }; 

  function RigidBody_ApplyTorqueImpulse (torqueImpulse) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    $IM06().Call(o._iRigidBodyImp, null, torqueImpulse.MemberwiseClone());
  }; 

  function RigidBody_get_AngularDrag () {
    return $IM07().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_AngularFactor () {
    return $IM08().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_AngularVelocity () {
    return $IM09().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_CollisionShape () {
    var shape = $IM0A().Call(this._iRigidBodyImp, null);
    var shapeType = (JSIL.GetType(shape)).toString();
    var text = shapeType;
    var num = ($T0A().ComputeStringHash(text) >>> 0);
    if (num <= 1897919175) {
      if (num <= 1564528284) {
        if (num !== 969439150) {
          if (num === 1564528284) {
            if (text == "Fusee.Engine._coneShapeImp") {
              var cone = new ($T0B())();
              cone._coneShapeImp = $T0C().$Cast(shape);
              $IM0B().Call(shape, null, cone);
              var result = cone;
              return result;
            }
          }
        } else if (text == "Fusee.Engine._boxShapeImp") {
          var box = new ($T0E())();
          box._boxShapeImp = $T0F().$Cast(shape);
          $IM0B().Call(shape, null, box);
          result = box;
          return result;
        }
      } else if (num !== 1576819597) {
        if (num !== 1643911949) {
          if (num === 1897919175) {
            if (text == "Fusee.Engine._staticPlaneShapeImp") {
              var staticPlane = new ($T10())();
              staticPlane._staticPlaneShapeImp = $T11().$Cast(shape);
              $IM0B().Call(shape, null, staticPlane);
              result = staticPlane;
              return result;
            }
          }
        } else if (text == "Fusee.Engine._gImpactMeshShapeImp") {
          var gimp = new ($T12())();
          gimp._gImpactMeshShapeImp = $T13().$Cast(shape);
          $IM0B().Call(shape, null, gimp);
          result = gimp;
          return result;
        }
      } else if (text == "Fusee.Engine._cylinderShapeImp") {
        var cylinder = new ($T14())();
        cylinder._cylinderShapeImp = $T15().$Cast(shape);
        $IM0B().Call(shape, null, cylinder);
        result = cylinder;
        return result;
      }
    } else if (num <= 2667469352) {
      if (num !== 2444095446) {
        if (num !== 2615718639) {
          if (num === 2667469352) {
            if (text == "Fusee.Engine._capsuleShapeImp") {
              var capsule = new ($T16())();
              capsule._capsuleShapeImp = $T17().$Cast(shape);
              $IM0B().Call(shape, null, capsule);
              result = capsule;
              return result;
            }
          }
        } else if (text == "Fusee.Engine.EmptyShape") {
          var empty = new ($T18())();
          empty._emtyShapeImp = $T19().$Cast(shape);
          $IM0B().Call(shape, null, empty);
          result = empty;
          return result;
        }
      } else if (text == "Fusee.Engine._compoundShapeImp") {
        var comp = new ($T1A())();
        comp._compoundShapeImp = $T1B().$Cast(shape);
        $IM0B().Call(shape, null, comp);
        result = comp;
        return result;
      }
    } else if (num !== 3500362078) {
      if (num !== 3780937395) {
        if (num === 3909512595) {
          if (text == "Fusee.Engine._multiSphereShapeImp") {
            var multiSphere = new ($T1C())();
            multiSphere._multiSphereShapeImp = $T1D().$Cast(shape);
            $IM0B().Call(shape, null, multiSphere);
            result = multiSphere;
            return result;
          }
        }
      } else if (text == "Fusee.Engine._convexHullShapeImp") {
        var convHull = new ($T1E())();
        convHull._convexHullShapeImp = $T1F().$Cast(shape);
        $IM0B().Call(shape, null, convHull);
        result = convHull;
        return result;
      }
    } else if (text == "Fusee.Engine._sphereShapeImp") {
      var sphere = new ($T20())();
      sphere._sphereShapeImp = $T21().$Cast(shape);
      $IM0B().Call(shape, null, sphere);
      result = sphere;
      return result;
    }
    result = new ($T18())();
    return result;
  }; 

  function RigidBody_get_Friction () {
    return $IM0C().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_Gravity () {
    return $IM0D().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_Inertia () {
    return $IM0E().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_LinearDrag () {
    return $IM0F().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_LinearFactor () {
    return $IM08().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_LinearVelocity () {
    return $IM10().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_Mass () {
    return $IM11().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_Position () {
    return $IM12().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_Restitution () {
    return $IM13().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_get_WorldTransform () {
    return $IM14().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_remove_WhileCollidingEvent (value) {
    var eventHandler = this.WhileCollidingEvent;

    do {
      var eventHandler2 = eventHandler;
      var value2 = $T02().Remove(eventHandler2, value);
      eventHandler = $T03().CompareExchange$b1($T00())(/* ref */ new JSIL.MemberReference(this, "WhileCollidingEvent"), value2, eventHandler2);
    } while (eventHandler !== eventHandler2);
  }; 

  function RigidBody_Rotation () {
    return $IM15().Call(this._iRigidBodyImp, null);
  }; 

  function RigidBody_set_AngularFactor (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    (o._iRigidBodyImp.AngularFactor = value.MemberwiseClone());
  }; 

  function RigidBody_set_AngularVelocity (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    (o._iRigidBodyImp.AngularVelocity = value.MemberwiseClone());
  }; 

  function RigidBody_set_CollisionShape (value) {
    var shapeType = (JSIL.GetType(value)).toString();
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    var text = shapeType;
    var num = ($T0A().ComputeStringHash(text) >>> 0);
    if (num <= 1844105875) {
      if (num <= 1319428916) {
        if (num !== 505077084) {
          if (num === 1319428916) {
            if (text == "Fusee.Engine.MultiSphereShape") {
              var multiSphere = $T1C().$Cast(value);
              $IM16().Call(o._iRigidBodyImp, null, multiSphere._multiSphereShapeImp);
              return;
            }
          }
        } else if (text == "Fusee.Engine.CylinderShape") {
          var cylinder = $T14().$Cast(value);
          $IM16().Call(o._iRigidBodyImp, null, cylinder._cylinderShapeImp);
          return;
        }
      } else if (num !== 1574939861) {
        if (num !== 1681802816) {
          if (num === 1844105875) {
            if (text == "Fusee.Engine.BoxShape") {
              var box = $T0E().$Cast(value);
              $IM16().Call(o._iRigidBodyImp, null, box._boxShapeImp);
              return;
            }
          }
        } else if (text == "Fusee.Engine.StaticPlaneShape") {
          var staticPlane = $T10().$Cast(value);
          $IM16().Call(o._iRigidBodyImp, null, staticPlane._staticPlaneShapeImp);
          return;
        }
      } else if (text == "Fusee.Engine.CompoundShape") {
        var compShape = $T1A().$Cast(value);
        $IM16().Call(o._iRigidBodyImp, null, compShape._compoundShapeImp);
        return;
      }
    } else if (num <= 2615718639) {
      if (num !== 2569625669) {
        if (num === 2615718639) {
          if (text == "Fusee.Engine.EmptyShape") {
            var empty = $T18().$Cast(value);
            $IM16().Call(o._iRigidBodyImp, null, empty._emtyShapeImp);
            return;
          }
        }
      } else if (text == "Fusee.Engine.CapsuleShape") {
        var capsule = $T16().$Cast(value);
        $IM16().Call(o._iRigidBodyImp, null, capsule._capsuleShapeImp);
        return;
      }
    } else if (num !== 2828003299) {
      if (num !== 3405169718) {
        if (num === 3680950897) {
          if (text == "Fusee.Engine.SphereShape") {
            var sphere = $T20().$Cast(value);
            $IM16().Call(o._iRigidBodyImp, null, sphere._sphereShapeImp);
            return;
          }
        }
      } else if (text == "Fusee.Engine.ConvexHullShape") {
        var convHull = $T1E().$Cast(value);
        $IM16().Call(o._iRigidBodyImp, null, convHull._convexHullShapeImp);
        return;
      }
    } else if (text == "Fusee.Engine.ConeShape") {
      var cone = $T0B().$Cast(value);
      $IM16().Call(o._iRigidBodyImp, null, cone._coneShapeImp);
      return;
    }
    var defaultShape = new ($T18())();
    $S01().CallStatic($T22(), "WriteLine", null, "default");
  }; 

  function RigidBody_set_Friction (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    $IM17().Call(o._iRigidBodyImp, null, value);
  }; 

  function RigidBody_set_Gravity (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    (this._iRigidBodyImp.Gravity = value.MemberwiseClone());
  }; 

  function RigidBody_set_Inertia (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    (o._iRigidBodyImp.Inertia = value.MemberwiseClone());
  }; 

  function RigidBody_set_LinearFactor (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    (o._iRigidBodyImp.LinearFactor = value.MemberwiseClone());
  }; 

  function RigidBody_set_LinearVelocity (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    (o._iRigidBodyImp.LinearVelocity = value.MemberwiseClone());
  }; 

  function RigidBody_set_Mass (value) {
    $IM18().Call(this._iRigidBodyImp, null, value);
  }; 

  function RigidBody_set_Position (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    (o._iRigidBodyImp.Position = value.MemberwiseClone());
  }; 

  function RigidBody_set_Restitution (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    $IM19().Call(o._iRigidBodyImp, null, value);
  }; 

  function RigidBody_set_WorldTransform (value) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    (o._iRigidBodyImp.WorldTransform = value.MemberwiseClone());
  }; 

  function RigidBody_SetDrag (linearDrag, anglularDrag) {
    var o = $thisType.$Cast($IM00().Call(this._iRigidBodyImp, null));
    $IM1A().Call(o._iRigidBodyImp, null, linearDrag, anglularDrag);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.RigidBody", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      RigidBody__ctor
    );

    $.Method({Static:false, Public:true }, "add_WhileCollidingEvent", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler")), 
      RigidBody_add_WhileCollidingEvent
    );

    $.Method({Static:false, Public:true }, "ApplyCentralForce", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_ApplyCentralForce
    );

    $.Method({Static:false, Public:true }, "ApplyCentralImpulse", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_ApplyCentralImpulse
    );

    $.Method({Static:false, Public:true }, "ApplyForce", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3")]), 
      RigidBody_ApplyForce
    );

    $.Method({Static:false, Public:true }, "ApplyImpulse", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3")]), 
      RigidBody_ApplyImpulse
    );

    $.Method({Static:false, Public:true }, "ApplyTorque", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_ApplyTorque
    );

    $.Method({Static:false, Public:true }, "ApplyTorqueImpulse", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_ApplyTorqueImpulse
    );

    $.Method({Static:false, Public:true }, "get_AngularDrag", 
      JSIL.MethodSignature.Return($.Single), 
      RigidBody_get_AngularDrag
    );

    $.Method({Static:false, Public:true }, "get_AngularFactor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_get_AngularFactor
    );

    $.Method({Static:false, Public:true }, "get_AngularVelocity", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_get_AngularVelocity
    );

    $.Method({Static:false, Public:true }, "get_CollisionShape", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.CollisionShape")), 
      RigidBody_get_CollisionShape
    );

    $.Method({Static:false, Public:true }, "get_Friction", 
      JSIL.MethodSignature.Return($.Single), 
      RigidBody_get_Friction
    );

    $.Method({Static:false, Public:true }, "get_Gravity", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_get_Gravity
    );

    $.Method({Static:false, Public:true }, "get_Inertia", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_get_Inertia
    );

    $.Method({Static:false, Public:true }, "get_LinearDrag", 
      JSIL.MethodSignature.Return($.Single), 
      RigidBody_get_LinearDrag
    );

    $.Method({Static:false, Public:true }, "get_LinearFactor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_get_LinearFactor
    );

    $.Method({Static:false, Public:true }, "get_LinearVelocity", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_get_LinearVelocity
    );

    $.Method({Static:false, Public:true }, "get_Mass", 
      JSIL.MethodSignature.Return($.Single), 
      RigidBody_get_Mass
    );

    $.Method({Static:false, Public:true }, "get_Position", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_get_Position
    );

    $.Method({Static:false, Public:true }, "get_Restitution", 
      JSIL.MethodSignature.Return($.Single), 
      RigidBody_get_Restitution
    );

    $.Method({Static:false, Public:true }, "get_WorldTransform", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RigidBody_get_WorldTransform
    );

    $.Method({Static:false, Public:true }, "remove_WhileCollidingEvent", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.EventHandler")), 
      RigidBody_remove_WhileCollidingEvent
    );

    $.Method({Static:false, Public:true }, "Rotation", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.Quaternion")), 
      RigidBody_Rotation
    );

    $.Method({Static:false, Public:true }, "set_AngularFactor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_set_AngularFactor
    );

    $.Method({Static:false, Public:true }, "set_AngularVelocity", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_set_AngularVelocity
    );

    $.Method({Static:false, Public:true }, "set_CollisionShape", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.CollisionShape")), 
      RigidBody_set_CollisionShape
    );

    $.Method({Static:false, Public:true }, "set_Friction", 
      JSIL.MethodSignature.Action($.Single), 
      RigidBody_set_Friction
    );

    $.Method({Static:false, Public:true }, "set_Gravity", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_set_Gravity
    );

    $.Method({Static:false, Public:true }, "set_Inertia", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_set_Inertia
    );

    $.Method({Static:false, Public:true }, "set_LinearFactor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_set_LinearFactor
    );

    $.Method({Static:false, Public:true }, "set_LinearVelocity", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_set_LinearVelocity
    );

    $.Method({Static:false, Public:true }, "set_Mass", 
      JSIL.MethodSignature.Action($.Single), 
      RigidBody_set_Mass
    );

    $.Method({Static:false, Public:true }, "set_Position", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      RigidBody_set_Position
    );

    $.Method({Static:false, Public:true }, "set_Restitution", 
      JSIL.MethodSignature.Action($.Single), 
      RigidBody_set_Restitution
    );

    $.Method({Static:false, Public:true }, "set_WorldTransform", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RigidBody_set_WorldTransform
    );

    $.Method({Static:false, Public:true }, "SetDrag", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      RigidBody_SetDrag
    );

    $.Field({Static:false, Public:false}, "WhileCollidingEvent", $asm0E.TypeRef("System.EventHandler"));

    $.Field({Static:false, Public:false}, "_iRigidBodyImp", $asm03.TypeRef("Fusee.Engine.Common.IRigidBodyImp"));

    $.Property({Static:false, Public:true }, "Gravity", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "Mass", $.Single);

    $.Property({Static:false, Public:true }, "Inertia", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "WorldTransform", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "Position", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "LinearVelocity", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "AngularVelocity", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "LinearFactor", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "AngularFactor", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "Restitution", $.Single);

    $.Property({Static:false, Public:true }, "Friction", $.Single);

    $.Property({Static:false, Public:true }, "LinearDrag", $.Single);

    $.Property({Static:false, Public:true }, "AngularDrag", $.Single);

    $.Property({Static:false, Public:true }, "CollisionShape", $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"));

    $.Event({Static:false, Public:true }, "WhileCollidingEvent", $asm0E.TypeRef("System.EventHandler"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.RigidBody+<>c */ 

(function $l$gc$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.EventArgs)) ();
  };


  function $l$gc__ctor () {
  }; 

  function $l$gc_$l_ctor$gb__52_0 ($lp0$g, $lp1$g) {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.RigidBody+<>c", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__ctor
    );

    $.Method({Static:false, Public:false}, "$l.ctor$gb__52_0", 
      new JSIL.MethodSignature(null, [$.Object, $asm0E.TypeRef("System.EventArgs")]), 
      $l$gc_$l_ctor$gb__52_0
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "$l$g9", $.Type);

    $.Field({Static:true , Public:true }, "$l$g9__52_0", $asm0E.TypeRef("System.EventHandler"));


    function $l$gc__cctor () {
      $thisType.$l$g9 = new $thisType();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__cctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.PickResult */ 

(function PickResult$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };


  function PickResult__ctor () {
  }; 

  function PickResult_get_CameraPos () {
    return (this.get_ModelPos()).TransformPerspective($S00().CallStatic($T01(), "op_Multiply", null, this.View.MemberwiseClone(), this.Model.MemberwiseClone()));
  }; 

  function PickResult_get_ClipPos () {
    return (this.get_ModelPos()).TransformPerspective($S00().CallStatic($T01(), "op_Multiply", null, $S00().CallStatic($T01(), "op_Multiply", null, this.Projection.MemberwiseClone(), this.View.MemberwiseClone()).MemberwiseClone(), this.Model.MemberwiseClone()));
  }; 

  function PickResult_get_ModelPos () {
    var a = new JSIL.BoxedVariable(new ($T00())());
    var b = new JSIL.BoxedVariable(new ($T00())());
    var c = new JSIL.BoxedVariable(new ($T00())());
    this.GetTriangle(/* ref */ a, /* ref */ b, /* ref */ c);
    return $T00().Barycentric(
      a.get().MemberwiseClone(), 
      b.get().MemberwiseClone(), 
      c.get().MemberwiseClone(), 
      this.U, 
      this.V
    );
  }; 

  function PickResult_get_WorldPos () {
    return (this.get_ModelPos()).TransformPerspective(this.Model);
  }; 

  function PickResult_GetTriangle (/* ref */ a, /* ref */ b, /* ref */ c) {
    a.set(this.Mesh.Vertices[this.Mesh.Triangles[this.Triangle]].MemberwiseClone());
    b.set(this.Mesh.Vertices[this.Mesh.Triangles[(((this.Triangle | 0) + 1) | 0)]].MemberwiseClone());
    c.set(this.Mesh.Vertices[this.Mesh.Triangles[(((this.Triangle | 0) + 2) | 0)]].MemberwiseClone());
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.PickResult", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      PickResult__ctor
    );

    $.Method({Static:false, Public:true }, "get_CameraPos", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      PickResult_get_CameraPos
    );

    $.Method({Static:false, Public:true }, "get_ClipPos", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      PickResult_get_ClipPos
    );

    $.Method({Static:false, Public:true }, "get_ModelPos", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      PickResult_get_ModelPos
    );

    $.Method({Static:false, Public:true }, "get_WorldPos", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      PickResult_get_WorldPos
    );

    $.Method({Static:false, Public:true }, "GetTriangle", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$asm09.TypeRef("Fusee.Math.Core.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm09.TypeRef("Fusee.Math.Core.float3")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm09.TypeRef("Fusee.Math.Core.float3")])
        ]), 
      PickResult_GetTriangle
    );

    $.Field({Static:false, Public:true }, "Node", $asm0A.TypeRef("Fusee.Serialization.SceneNodeContainer"));

    $.Field({Static:false, Public:true }, "Mesh", $asm0A.TypeRef("Fusee.Serialization.MeshComponent"));

    $.Field({Static:false, Public:true }, "Triangle", $.Int32);

    $.Field({Static:false, Public:true }, "U", $.Single);

    $.Field({Static:false, Public:true }, "V", $.Single);

    $.Field({Static:false, Public:true }, "Model", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:true }, "View", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:true }, "Projection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "ModelPos", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "ClipPos", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "WorldPos", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "CameraPos", $asm09.TypeRef("Fusee.Math.Core.float3"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ScenePicker */ 

(function ScenePicker$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.Fusee.Serialization.SceneContainer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0C.Fusee.Xene.Viserator$b2.Of($asm04.Fusee.Engine.Core.PickResult, $asm04.Fusee.Engine.Core.ScenePicker_PickerState))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0A.Fusee.Serialization.SceneNodeContainer))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.ScenePicker_PickerState)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0C.Fusee.Xene.ViseratorBase$b1.Of($asm04.Fusee.Engine.Core.PickResult))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.Fusee.Serialization.MeshComponent)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize(System.Array.Of($asm0E.System.UInt16))) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm04.Fusee.Engine.Core.PickResult)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0C.Fusee.Xene.SceneVisitor)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0A.Fusee.Serialization.TransformComponent)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0C.Fusee.Xene.ContainerExtensions)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float4, [$asm09.Fusee.Math.Core.float3, $asm0E.System.Single]))) ();
  };


  function ScenePicker__ctor (scene) {
    $T01().prototype._ctor.call(this, $T02().prototype.GetEnumerator.call(scene.Children).MemberwiseClone());
    this.View = $T03().Identity.MemberwiseClone();
    this.Projection = $T03().Identity.MemberwiseClone();
  }; 

  function ScenePicker_get_PickPosClip () {
    return this.ScenePicker$PickPosClip$value;
  }; 

  function ScenePicker_InitState () {
    $T01().prototype.InitState.call(this);
    (this.State.Model = $T03().Identity.MemberwiseClone());
  }; 

  function ScenePicker_Pick (pickPos) {
    (this.ScenePicker$PickPosClip$value = pickPos.MemberwiseClone());
    return $T06().prototype.Viserate.call(this);
  }; 

  function ScenePicker_PickMesh (meshComponent) {
    var u = new JSIL.BoxedVariable(0);
    var v = new JSIL.BoxedVariable(0);
    var mvp = $S00().CallStatic($T03(), "op_Multiply", null, 
      $S00().CallStatic($T03(), "op_Multiply", null, this.Projection.MemberwiseClone(), this.View.MemberwiseClone()).MemberwiseClone(), 
      (this.State).get_Model().MemberwiseClone()
    ).MemberwiseClone();

    for (var i = 0; i < (meshComponent.Triangles.length | 0); i = ((i + 3) | 0)) {
      var a = ($S01().Construct(meshComponent.Vertices[meshComponent.Triangles[i]], 1)).TransformPerspective(mvp).MemberwiseClone();
      var b = ($S01().Construct(meshComponent.Vertices[meshComponent.Triangles[((i + 1) | 0)]], 1)).TransformPerspective(mvp).MemberwiseClone();
      var c = ($S01().Construct(meshComponent.Vertices[meshComponent.Triangles[((i + 2) | 0)]], 1)).TransformPerspective(mvp);
      var flag = $T05().PointInTriangle(
        a.get_xy().MemberwiseClone(), 
        b.get_xy().MemberwiseClone(), 
        c.get_xy(), 
        this.ScenePicker$PickPosClip$value.MemberwiseClone(), 
        /* ref */ u, 
        /* ref */ v
      );
      if (flag) {
        var expr_D9 = new ($T0D())();
        expr_D9.Mesh = meshComponent;
        expr_D9.Node = this.SceneVisitor$CurrentNode$value;
        expr_D9.Triangle = i;
        expr_D9.Model = (this.State).get_Model().MemberwiseClone();
        expr_D9.View = this.View.MemberwiseClone();
        expr_D9.Projection = this.Projection.MemberwiseClone();
        expr_D9.U = +u.get();
        expr_D9.V = +v.get();
        $T06().prototype.YieldItem.call(this, expr_D9);
      }
    }
  }; 

  function ScenePicker_PickTransform (transform) {
    this.State.Model = $S00().CallStatic($T03(), "op_Multiply", null, this.State.Model.MemberwiseClone(), $T10().Matrix(transform).MemberwiseClone()).MemberwiseClone();
  }; 

  function ScenePicker_set_PickPosClip (value) {
    this.ScenePicker$PickPosClip$value = value.MemberwiseClone();
  }; 

  JSIL.MakeType({
      BaseType: $asm0C.TypeRef("Fusee.Xene.Viserator`2", [$asm04.TypeRef("Fusee.Engine.Core.PickResult"), $asm04.TypeRef("Fusee.Engine.Core.ScenePicker+PickerState")]), 
      Name: "Fusee.Engine.Core.ScenePicker", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.SceneContainer")), 
      ScenePicker__ctor
    );

    $.Method({Static:false, Public:true }, "get_PickPosClip", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float2")), 
      ScenePicker_get_PickPosClip
    );

    $.Method({Static:false, Public:false, Virtual:true }, "InitState", 
      JSIL.MethodSignature.Void, 
      ScenePicker_InitState
    );

    $.Method({Static:false, Public:true }, "Pick", 
      new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm04.TypeRef("Fusee.Engine.Core.PickResult")]), [$asm09.TypeRef("Fusee.Math.Core.float2")]), 
      ScenePicker_Pick
    );

    $.Method({Static:false, Public:true }, "PickMesh", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MeshComponent")), 
      ScenePicker_PickMesh
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "PickTransform", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.TransformComponent")), 
      ScenePicker_PickTransform
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "set_PickPosClip", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float2")), 
      ScenePicker_set_PickPosClip
    );

    $.Field({Static:false, Public:true }, "View", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:true }, "Projection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "ScenePicker$PickPosClip$value", $asm09.TypeRef("Fusee.Math.Core.float2"));

    $.Property({Static:false, Public:true }, "PickPosClip", $asm09.TypeRef("Fusee.Math.Core.float2"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ScenePicker+PickerState */ 

(function PickerState$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0C.Fusee.Xene.CollapsingStateStack$b1.Of($asm09.Fusee.Math.Core.float4x4))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0C.Fusee.Xene.VisitorState)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };


  function PickerState__ctor () {
    this._model = new ($T00())(4);
    $T01().prototype._ctor.call(this);
    this.RegisterState(this._model);
  }; 

  function PickerState_get_Model () {
    return (this._model).get_Tos();
  }; 

  function PickerState_set_Model (value) {
    (this._model).set_Tos(value.MemberwiseClone());
  }; 

  JSIL.MakeType({
      BaseType: $asm0C.TypeRef("Fusee.Xene.VisitorState"), 
      Name: "Fusee.Engine.Core.ScenePicker+PickerState", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      PickerState__ctor
    );

    $.Method({Static:false, Public:true }, "get_Model", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      PickerState_get_Model
    );

    $.Method({Static:false, Public:true }, "set_Model", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      PickerState_set_Model
    );

    $.Field({Static:false, Public:false}, "_model", $asm0C.TypeRef("Fusee.Xene.CollapsingStateStack`1", [$asm09.TypeRef("Fusee.Math.Core.float4x4")]));

    $.Property({Static:false, Public:true }, "Model", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.AABBCalculator */ 

(function AABBCalculator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.Fusee.Serialization.SceneContainer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.AABBCalculator_AABBState)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0C.Fusee.Xene.SceneVisitor)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0A.Fusee.Serialization.SceneNodeContainer))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.Fusee.Serialization.SceneNodeContainer)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0C.Fusee.Xene.SceneVisitorHelpers)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0C.Fusee.Xene.VisitorState)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.Fusee.Serialization.MeshComponent)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm09.Fusee.Math.Core.AABBf)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.Fusee.Serialization.TransformComponent)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0C.Fusee.Xene.ContainerExtensions)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0A.TypeRef("Fusee.Serialization.SceneNodeContainer")])))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };


  function AABBCalculator__ctor$00 (sc) {
    this._state = new ($T01())();
    $T02().prototype._ctor.call(this);
    this._sncList = sc.Children;
  }; 

  function AABBCalculator__ctor$01 (sncList) {
    this._state = new ($T01())();
    $T02().prototype._ctor.call(this);
    this._sncList = sncList;
  }; 

  function AABBCalculator__ctor$02 (snc) {
    this._state = new ($T01())();
    $T02().prototype._ctor.call(this);
    this._sncList = $T05().SingleRootEnumerable(snc);
  }; 

  function AABBCalculator_GetBox () {
    $S00().CallVirtual("Traverse", null, this, this._sncList);
    var boxValid = this._boxValid;
    if (boxValid) {
      var result = this._result.MemberwiseClone();
    } else {
      result = null;
    }
    return result;
  }; 

  function AABBCalculator_InitState () {
    this._boxValid = false;
    (this._state).Clear();
    (this._state.ModelView = $T08().Identity.MemberwiseClone());
  }; 

  function AABBCalculator_OnMesh (meshComponent) {
    var box = $T0A().op_Multiply((this._state).get_ModelView(), meshComponent.BoundingBox.MemberwiseClone()).MemberwiseClone();
    if (!this._boxValid) {
      this._result = box.MemberwiseClone();
      this._boxValid = true;
    } else {
      this._result = $T0A().Union(this._result, box).MemberwiseClone();
    }
  }; 

  function AABBCalculator_OnTransform (transform) {
    this._state.ModelView = $S01().CallStatic($T08(), "op_Multiply", null, this._state.ModelView.MemberwiseClone(), $T0C().Matrix(transform).MemberwiseClone()).MemberwiseClone();
  }; 

  function AABBCalculator_PopState () {
    (this._state).Pop();
  }; 

  function AABBCalculator_PushState () {
    (this._state).Push();
  }; 

  JSIL.MakeType({
      BaseType: $asm0C.TypeRef("Fusee.Xene.SceneVisitor"), 
      Name: "Fusee.Engine.Core.AABBCalculator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.SceneContainer")), 
      AABBCalculator__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0A.TypeRef("Fusee.Serialization.SceneNodeContainer")])), 
      AABBCalculator__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.SceneNodeContainer")), 
      AABBCalculator__ctor$02
    );

    $.Method({Static:false, Public:true }, "GetBox", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Nullable`1", [$asm09.TypeRef("Fusee.Math.Core.AABBf")])), 
      AABBCalculator_GetBox
    );

    $.Method({Static:false, Public:false, Virtual:true }, "InitState", 
      JSIL.MethodSignature.Void, 
      AABBCalculator_InitState
    );

    $.Method({Static:false, Public:true }, "OnMesh", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MeshComponent")), 
      AABBCalculator_OnMesh
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "OnTransform", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.TransformComponent")), 
      AABBCalculator_OnTransform
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "PopState", 
      JSIL.MethodSignature.Void, 
      AABBCalculator_PopState
    );

    $.Method({Static:false, Public:false, Virtual:true }, "PushState", 
      JSIL.MethodSignature.Void, 
      AABBCalculator_PushState
    );

    $.Field({Static:false, Public:false}, "_sncList", $asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0A.TypeRef("Fusee.Serialization.SceneNodeContainer")]));

    $.Field({Static:false, Public:false}, "_state", $asm04.TypeRef("Fusee.Engine.Core.AABBCalculator+AABBState"));

    $.Field({Static:false, Public:false}, "_boxValid", $.Boolean);

    $.Field({Static:false, Public:false}, "_result", $asm09.TypeRef("Fusee.Math.Core.AABBf"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.AABBCalculator+AABBState */ 

(function AABBState$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0C.Fusee.Xene.CollapsingStateStack$b1.Of($asm09.Fusee.Math.Core.float4x4))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0C.Fusee.Xene.VisitorState)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };


  function AABBState__ctor () {
    this._modelView = new ($T00())(4);
    $T01().prototype._ctor.call(this);
    this.RegisterState(this._modelView);
  }; 

  function AABBState_get_ModelView () {
    return (this._modelView).get_Tos();
  }; 

  function AABBState_set_ModelView (value) {
    (this._modelView).set_Tos(value.MemberwiseClone());
  }; 

  JSIL.MakeType({
      BaseType: $asm0C.TypeRef("Fusee.Xene.VisitorState"), 
      Name: "Fusee.Engine.Core.AABBCalculator+AABBState", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AABBState__ctor
    );

    $.Method({Static:false, Public:true }, "get_ModelView", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      AABBState_get_ModelView
    );

    $.Method({Static:false, Public:true }, "set_ModelView", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      AABBState_set_ModelView
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_modelView", $asm0C.TypeRef("Fusee.Xene.CollapsingStateStack`1", [$asm09.TypeRef("Fusee.Math.Core.float4x4")]));

    $.Property({Static:false, Public:true }, "ModelView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum Fusee.Engine.Core.LightingCalculationMethod */ 

JSIL.MakeEnum(
  {
    FullName: "Fusee.Engine.Core.LightingCalculationMethod", 
    BaseType: $asm0E.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    SIMPLE: 0, 
    ADVANCED: 1, 
    ADVANCEDwENVMAP: 2, 
  }
);

/* class Fusee.Engine.Core.SceneRenderer */ 

(function SceneRenderer$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.Fusee.Serialization.SceneContainer)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.LightingCalculationMethod)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.LightResult)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0C.Fusee.Xene.SceneVisitor)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult)))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Engine.Core.LightSetup)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0C.Fusee.Xene.ViseratorExtensions)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult)))) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.Collections.IEnumerator)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.IDisposable)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.Fusee.Serialization.LightComponent)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0A.Fusee.Serialization.LightType)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm04.Fusee.Engine.Core.SceneRenderer_RendererState)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0D.Fusee.Xirkit.ChannelBase))) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0D.Fusee.Xirkit.Animation)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm04.Fusee.Engine.Core.Time)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm0A.Fusee.Serialization.MaterialComponent)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderCodeBuilder)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration))) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm04.Fusee.Engine.Core.EffectParameterDeclaration)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0A.Fusee.Serialization.ShaderComponent)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderEffect)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.ShaderComponent, $asm04.Fusee.Engine.Core.ShaderEffect))) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm0A.Fusee.Serialization.TypeContainer)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm0A.Fusee.Serialization.TypeContainerDouble)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm0A.Fusee.Serialization.TypeContainerInt)) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm0A.Fusee.Serialization.TypeContainerFloat)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm0A.Fusee.Serialization.TypeContainerFloat2)) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm0A.Fusee.Serialization.TypeContainerFloat3)) ();
  };
  var $T25 = function () {
    return ($T25 = JSIL.Memoize($asm0A.Fusee.Serialization.TypeContainerFloat4)) ();
  };
  var $T26 = function () {
    return ($T26 = JSIL.Memoize($asm0A.Fusee.Serialization.TypeContainerBool)) ();
  };
  var $T27 = function () {
    return ($T27 = JSIL.Memoize($asm11.System.IO.InvalidDataException)) ();
  };
  var $T28 = function () {
    return ($T28 = JSIL.Memoize($asm0A.Fusee.Serialization.TypeId)) ();
  };
  var $T29 = function () {
    return ($T29 = JSIL.Memoize($asm0E.System.Double)) ();
  };
  var $T2A = function () {
    return ($T2A = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T2B = function () {
    return ($T2B = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T2C = function () {
    return ($T2C = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T2D = function () {
    return ($T2D = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T2E = function () {
    return ($T2E = JSIL.Memoize(System.Array.Of($asm04.Fusee.Engine.Core.EffectPassDeclaration))) ();
  };
  var $T2F = function () {
    return ($T2F = JSIL.Memoize($asm04.Fusee.Engine.Core.EffectPassDeclaration)) ();
  };
  var $T30 = function () {
    return ($T30 = JSIL.Memoize($asm04.Fusee.Engine.Core.DeferredShaderHelper)) ();
  };
  var $T31 = function () {
    return ($T31 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderStateSet)) ();
  };
  var $T32 = function () {
    return ($T32 = JSIL.Memoize($asm0E.System.Predicate$b1.Of($asm0A.Fusee.Serialization.AnimationComponent))) ();
  };
  var $T33 = function () {
    return ($T33 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0A.Fusee.Serialization.SceneNodeContainer))) ();
  };
  var $T34 = function () {
    return ($T34 = JSIL.Memoize($asm04.Fusee.Engine.Core.SceneRenderer_$l$gc)) ();
  };
  var $T35 = function () {
    return ($T35 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm0A.Fusee.Serialization.AnimationComponent))) ();
  };
  var $T36 = function () {
    return ($T36 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0A.Fusee.Serialization.AnimationComponent))) ();
  };
  var $T37 = function () {
    return ($T37 = JSIL.Memoize($asm0A.Fusee.Serialization.AnimationComponent)) ();
  };
  var $T38 = function () {
    return ($T38 = JSIL.Memoize($asm0C.Fusee.Xene.SceneFinderExtensions)) ();
  };
  var $T39 = function () {
    return ($T39 = JSIL.Memoize($asm0A.Fusee.Serialization.AnimationTrackContainer)) ();
  };
  var $T3A = function () {
    return ($T3A = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1.Of($asm0E.System.Int32))) ();
  };
  var $T3B = function () {
    return ($T3B = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1_LerpFunc.Of($asm0E.System.Int32))) ();
  };
  var $T3C = function () {
    return ($T3C = JSIL.Memoize($asm0A.Fusee.Serialization.AnimationKeyContainerInt)) ();
  };
  var $T3D = function () {
    return ($T3D = JSIL.Memoize($asm0D.Fusee.Xirkit.Keyframe$b1.Of($asm0E.System.Int32))) ();
  };
  var $T3E = function () {
    return ($T3E = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1.Of($asm0E.System.Single))) ();
  };
  var $T3F = function () {
    return ($T3F = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1_LerpFunc.Of($asm0E.System.Single))) ();
  };
  var $T40 = function () {
    return ($T40 = JSIL.Memoize($asm0A.Fusee.Serialization.AnimationKeyContainerFloat)) ();
  };
  var $T41 = function () {
    return ($T41 = JSIL.Memoize($asm0D.Fusee.Xirkit.Keyframe$b1.Of($asm0E.System.Single))) ();
  };
  var $T42 = function () {
    return ($T42 = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T43 = function () {
    return ($T43 = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1_LerpFunc.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T44 = function () {
    return ($T44 = JSIL.Memoize($asm0A.Fusee.Serialization.AnimationKeyContainerFloat2)) ();
  };
  var $T45 = function () {
    return ($T45 = JSIL.Memoize($asm0D.Fusee.Xirkit.Keyframe$b1.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T46 = function () {
    return ($T46 = JSIL.Memoize($asm0A.Fusee.Serialization.LerpType)) ();
  };
  var $T47 = function () {
    return ($T47 = JSIL.Memoize($asm0E.System.InvalidOperationException)) ();
  };
  var $T48 = function () {
    return ($T48 = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1_LerpFunc.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T49 = function () {
    return ($T49 = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T4A = function () {
    return ($T4A = JSIL.Memoize($asm0A.Fusee.Serialization.AnimationKeyContainerFloat3)) ();
  };
  var $T4B = function () {
    return ($T4B = JSIL.Memoize($asm0D.Fusee.Xirkit.Keyframe$b1.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T4C = function () {
    return ($T4C = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1.Of($asm09.Fusee.Math.Core.float4))) ();
  };
  var $T4D = function () {
    return ($T4D = JSIL.Memoize($asm0D.Fusee.Xirkit.Channel$b1_LerpFunc.Of($asm09.Fusee.Math.Core.float4))) ();
  };
  var $T4E = function () {
    return ($T4E = JSIL.Memoize($asm0A.Fusee.Serialization.AnimationKeyContainerFloat4)) ();
  };
  var $T4F = function () {
    return ($T4F = JSIL.Memoize($asm0D.Fusee.Xirkit.Keyframe$b1.Of($asm09.Fusee.Math.Core.float4))) ();
  };
  var $T50 = function () {
    return ($T50 = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T51 = function () {
    return ($T51 = JSIL.Memoize($asm0C.Fusee.Xene.VisitorState)) ();
  };
  var $T52 = function () {
    return ($T52 = JSIL.Memoize($asm09.Fusee.Math.Core.MinMaxRect)) ();
  };
  var $T53 = function () {
    return ($T53 = JSIL.Memoize($asm14.System.Linq.Enumerable)) ();
  };
  var $T54 = function () {
    return ($T54 = JSIL.Memoize($asm09.Fusee.Math.Core.M)) ();
  };
  var $T55 = function () {
    return ($T55 = JSIL.Memoize($asm00.Fusee.Base.Common.ImageData)) ();
  };
  var $T56 = function () {
    return ($T56 = JSIL.Memoize($asm01.Fusee.Base.Core.AssetStorage)) ();
  };
  var $T57 = function () {
    return ($T57 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.MaterialComponent, $asm04.Fusee.Engine.Core.ShaderEffect))) ();
  };
  var $T58 = function () {
    return ($T58 = JSIL.Memoize($asm0A.Fusee.Serialization.MaterialLightComponent)) ();
  };
  var $T59 = function () {
    return ($T59 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.MaterialLightComponent, $asm04.Fusee.Engine.Core.ShaderEffect))) ();
  };
  var $T5A = function () {
    return ($T5A = JSIL.Memoize($asm0A.Fusee.Serialization.MaterialPBRComponent)) ();
  };
  var $T5B = function () {
    return ($T5B = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.MaterialPBRComponent, $asm04.Fusee.Engine.Core.ShaderEffect))) ();
  };
  var $T5C = function () {
    return ($T5C = JSIL.Memoize($asm0A.Fusee.Serialization.WeightComponent)) ();
  };
  var $T5D = function () {
    return ($T5D = JSIL.Memoize($asm0C.Fusee.Xene.ContainerExtensions)) ();
  };
  var $T5E = function () {
    return ($T5E = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration))) ();
  };
  var $T5F = function () {
    return ($T5F = JSIL.Memoize($asm0E.System.Exception)) ();
  };
  var $T60 = function () {
    return ($T60 = JSIL.Memoize($asm0A.Fusee.Serialization.MeshComponent)) ();
  };
  var $T61 = function () {
    return ($T61 = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T62 = function () {
    return ($T62 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float4))) ();
  };
  var $T63 = function () {
    return ($T63 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0A.Fusee.Serialization.VertexWeightList))) ();
  };
  var $T64 = function () {
    return ($T64 = JSIL.Memoize($asm0A.Fusee.Serialization.VertexWeightList)) ();
  };
  var $T65 = function () {
    return ($T65 = JSIL.Memoize(System.Array.Of($asm0A.Fusee.Serialization.VertexWeight))) ();
  };
  var $T66 = function () {
    return ($T66 = JSIL.Memoize($asm0A.Fusee.Serialization.VertexWeight)) ();
  };
  var $T67 = function () {
    return ($T67 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0A.Fusee.Serialization.VertexWeight))) ();
  };
  var $T68 = function () {
    return ($T68 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0A.Fusee.Serialization.VertexWeight))) ();
  };
  var $T69 = function () {
    return ($T69 = JSIL.Memoize($asm0E.System.Math)) ();
  };
  var $T6A = function () {
    return ($T6A = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0A.Fusee.Serialization.RenderPass))) ();
  };
  var $T6B = function () {
    return ($T6B = JSIL.Memoize($asm0A.Fusee.Serialization.RenderPass)) ();
  };
  var $T6C = function () {
    return ($T6C = JSIL.Memoize($asm0A.Fusee.Serialization.BoneComponent)) ();
  };
  var $T6D = function () {
    return ($T6D = JSIL.Memoize($asm0A.Fusee.Serialization.SceneNodeContainer)) ();
  };
  var $T6E = function () {
    return ($T6E = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.SceneNodeContainer, $asm09.Fusee.Math.Core.float4x4))) ();
  };
  var $T6F = function () {
    return ($T6F = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderProgram)) ();
  };
  var $T70 = function () {
    return ($T70 = JSIL.Memoize($asm03.Fusee.Engine.Common.IShaderParam)) ();
  };
  var $T71 = function () {
    return ($T71 = JSIL.Memoize($asm03.Fusee.Engine.Common.GBufferHandle)) ();
  };
  var $T72 = function () {
    return ($T72 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2_KeyCollection.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult))) ();
  };
  var $T73 = function () {
    return ($T73 = JSIL.Memoize($asm03.Fusee.Engine.Common.WritableTextureFormat)) ();
  };
  var $T74 = function () {
    return ($T74 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.MeshComponent, $asm04.Fusee.Engine.Core.Mesh))) ();
  };
  var $T75 = function () {
    return ($T75 = JSIL.Memoize($asm0A.Fusee.Serialization.RectTransformComponent)) ();
  };
  var $T76 = function () {
    return ($T76 = JSIL.Memoize($asm0A.Fusee.Serialization.TransformComponent)) ();
  };
  var $T77 = function () {
    return ($T77 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float4x4))) ();
  };
  var $T78 = function () {
    return ($T78 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm09.Fusee.Math.Core.float4x4))) ();
  };
  var $T79 = function () {
    return ($T79 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0A.Fusee.Serialization.SceneNodeContainer))) ();
  };
  var $T7A = function () {
    return ($T7A = JSIL.Memoize($asm03.Fusee.Engine.Common.HardwareCapability)) ();
  };
  var $T7B = function () {
    return ($T7B = JSIL.Memoize($asm0E.System.ArgumentNullException)) ();
  };
  var $T7C = function () {
    return ($T7C = JSIL.Memoize($asm0A.Fusee.Serialization.MatChannelContainer)) ();
  };
  var $T7D = function () {
    return ($T7D = JSIL.Memoize($asm0A.Fusee.Serialization.SpecularChannelContainer)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!1"]), [$asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0A.Fusee.Serialization.SceneNodeContainer)], ["TViserator", "TResult"]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float3, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration), null))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.EffectParameterDeclaration")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm11.System.IO.InvalidDataException, [$asm0E.System.String]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Boolean, [$asm0A.Fusee.Serialization.AnimationComponent]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"]), [$asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0A.Fusee.Serialization.SceneNodeContainer), $asm0E.TypeRef("System.Predicate`1", ["!!0"])], ["TComponent"]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0D.Fusee.Xirkit.Channel$b1.Of($asm0E.System.Int32), [$asm0D.TypeRef("Fusee.Xirkit.Channel`1+LerpFunc", [$asm0E.TypeRef("System.Int32")])]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Int32, [
        $asm0E.System.Int32, $asm0E.System.Int32, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.ConstructorSignature($asm0D.Fusee.Xirkit.Channel$b1.Of($asm0E.System.Single), [$asm0D.TypeRef("Fusee.Xirkit.Channel`1+LerpFunc", [$asm0E.TypeRef("System.Single")])]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Single, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.ConstructorSignature($asm0D.Fusee.Xirkit.Channel$b1.Of($asm09.Fusee.Math.Core.float2), [$asm0D.TypeRef("Fusee.Xirkit.Channel`1+LerpFunc", [$asm09.TypeRef("Fusee.Math.Core.float2")])]))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float2, [
        $asm09.Fusee.Math.Core.float2, $asm09.Fusee.Math.Core.float2, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $S0F = function () {
    return ($S0F = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.InvalidOperationException, [$asm0E.System.String]))) ();
  };
  var $S10 = function () {
    return ($S10 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float3, [
        $asm09.Fusee.Math.Core.float3, $asm09.Fusee.Math.Core.float3, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $S11 = function () {
    return ($S11 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float3, [
        $asm09.Fusee.Math.Core.float3, $asm09.Fusee.Math.Core.float3, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $S12 = function () {
    return ($S12 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0D.Fusee.Xirkit.Channel$b1.Of($asm09.Fusee.Math.Core.float3), [$asm0D.TypeRef("Fusee.Xirkit.Channel`1+LerpFunc", [$asm09.TypeRef("Fusee.Math.Core.float3")])]))) ();
  };
  var $S13 = function () {
    return ($S13 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0D.Fusee.Xirkit.Channel$b1.Of($asm09.Fusee.Math.Core.float4), [$asm0D.TypeRef("Fusee.Xirkit.Channel`1+LerpFunc", [$asm09.TypeRef("Fusee.Math.Core.float4")])]))) ();
  };
  var $S14 = function () {
    return ($S14 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4, [
        $asm09.Fusee.Math.Core.float4, $asm09.Fusee.Math.Core.float4, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $S15 = function () {
    return ($S15 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float3, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float3]))) ();
  };
  var $S16 = function () {
    return ($S16 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4]))) ();
  };
  var $S17 = function () {
    return ($S17 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.Fusee.Engine.Core.ShaderCodeBuilder, [
        $asm0A.Fusee.Serialization.MaterialComponent, $asm0A.Fusee.Serialization.MeshComponent, 
        $asm0A.Fusee.Serialization.WeightComponent, $asm0E.System.Boolean
      ]))) ();
  };
  var $S18 = function () {
    return ($S18 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.Fusee.Engine.Core.ShaderCodeBuilder, [
        $asm0A.Fusee.Serialization.MaterialComponent, $asm0A.Fusee.Serialization.MeshComponent, 
        $asm04.Fusee.Engine.Core.LightingCalculationMethod, $asm0A.Fusee.Serialization.WeightComponent, 
        $asm0E.System.Boolean
      ]))) ();
  };
  var $S19 = function () {
    return ($S19 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Exception, [$asm0E.System.String]))) ();
  };
  var $S1A = function () {
    return ($S1A = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm0A.Fusee.Serialization.VertexWeight), [$asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0A.TypeRef("Fusee.Serialization.VertexWeight")])]))) ();
  };
  var $S1B = function () {
    return ($S1B = JSIL.Memoize(JSIL.MethodSignature.Action($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0A.TypeRef("Fusee.Serialization.SceneNodeContainer")])))) ();
  };
  var $S1C = function () {
    return ($S1C = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };
  var $S1D = function () {
    return ($S1D = JSIL.Memoize(new JSIL.MethodSignature($asm04.Fusee.Engine.Core.ShaderEffect, [$asm0A.Fusee.Serialization.MaterialComponent]))) ();
  };
  var $S1E = function () {
    return ($S1E = JSIL.Memoize(new JSIL.MethodSignature($asm04.Fusee.Engine.Core.ShaderEffect, [$asm0A.Fusee.Serialization.MaterialLightComponent]))) ();
  };
  var $S1F = function () {
    return ($S1F = JSIL.Memoize(new JSIL.MethodSignature($asm04.Fusee.Engine.Core.ShaderEffect, [$asm0A.Fusee.Serialization.MaterialPBRComponent]))) ();
  };
  var $S20 = function () {
    return ($S20 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float2, [$asm09.Fusee.Math.Core.float2, $asm09.Fusee.Math.Core.float2]))) ();
  };
  var $S21 = function () {
    return ($S21 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Int32, [$asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"])], ["TSource"]))) ();
  };
  var $S22 = function () {
    return ($S22 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentNullException, [$asm0E.System.String]))) ();
  };
  var $S23 = function () {
    return ($S23 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.MeshComponent, $asm04.Fusee.Engine.Core.Mesh), null))) ();
  };
  var $S24 = function () {
    return ($S24 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.MaterialComponent, $asm04.Fusee.Engine.Core.ShaderEffect), null))) ();
  };
  var $S25 = function () {
    return ($S25 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.MaterialLightComponent, $asm04.Fusee.Engine.Core.ShaderEffect), null))) ();
  };
  var $S26 = function () {
    return ($S26 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.MaterialPBRComponent, $asm04.Fusee.Engine.Core.ShaderEffect), null))) ();
  };
  var $S27 = function () {
    return ($S27 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.SceneNodeContainer, $asm09.Fusee.Math.Core.float4x4), null))) ();
  };
  var $S28 = function () {
    return ($S28 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.ShaderComponent, $asm04.Fusee.Engine.Core.ShaderEffect), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult)).GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0E.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult)).get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0E.System.IDisposable.Dispose)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0A.Fusee.Serialization.AnimationComponent).GetEnumerator)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm0A.Fusee.Serialization.AnimationComponent).get_Current)) ();
  };


  function SceneRenderer__ctor$00 (sc, lightCalcMethod, RenderDeferred, RenderShadows) {
    $thisType.prototype._ctor.call(this, sc);
    $thisType.LightingCalculationMethod = lightCalcMethod;
    if (RenderShadows) {
      this._wantToRenderWithShadows = true;
    }
    if (RenderDeferred) {
      this._wantToRenderDeferred = true;
    }
    if (lightCalcMethod === $T02().ADVANCEDwENVMAP) {
      this._wantToRenderEnvMap = true;
    }
  }; 

  function SceneRenderer__ctor$01 (sc) {
    var result = new JSIL.BoxedVariable(new ($T04())());
    this.SceneRenderer$ShadowMapSize$value = $S01().Construct(1024, 1024);
    this._lightComponents = $S00().Construct();
    $T06().prototype._ctor.call(this);
    var results = $S02().CallStatic($T0A(), "Viserate$b2", [$asm04.Fusee.Engine.Core.LightSetup, $asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult)], sc.Children);
    var enumerator = $IM00().Call(results, null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var keyValuePair = $IM02().Call(enumerator, null).MemberwiseClone();
        var flag = (this._lightComponents).TryGetValue(keyValuePair.get_Key(), /* ref */ result);
        if (!flag) {
          (this._lightComponents).Add(
            keyValuePair.get_Key(), 
            keyValuePair.get_Value().MemberwiseClone()
          );
        }
      }
    } finally {
      if (enumerator !== null) {
        $IM03().Call(enumerator, null);
      }
    }
    $thisType.AllLightResults = this._lightComponents;
    var flag2 = ($thisType.AllLightResults.get_Count() | 0) === 0;
    if (flag2) {
      var arg_147_0 = $thisType.AllLightResults;
      var arg_147_1 = new ($T0E())();
      var value = new ($T04())();
      value.PositionWorldSpace = $T0F().UnitZ.MemberwiseClone();
      value.Position = $T0F().UnitZ.MemberwiseClone();
      value.Active = true;
      value.AmbientCoefficient = 0;
      value.Attenuation = 0;
      value.Color = $S03().Construct(1, 1, 1);
      value.ConeAngle = 45;
      value.ConeDirection = $T0F().UnitZ.MemberwiseClone();
      value.ModelMatrix = $T10().Identity.MemberwiseClone();
      value.Type = $T11().Legacy;
      arg_147_0.Add(arg_147_1, value.MemberwiseClone());
    }
    this._sc = sc;
    this._state = new ($T12())();
    this.InitAnimations(this._sc);
  }; 

  function SceneRenderer_AccumulateLight (lightComponent) {
    var result = new JSIL.BoxedVariable(new ($T04())());
    var flag = $thisType.AllLightResults.TryGetValue(lightComponent, /* ref */ result);
    if (!flag) {
      var results = $S02().CallStatic($T0A(), "Viserate$b2", [$asm04.Fusee.Engine.Core.LightSetup, $asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult)], this._sc.Children);
      var enumerator = $IM00().Call(results, null);
      try {

        while ($IM01().Call(enumerator, null)) {
          var keyValuePair = $IM02().Call(enumerator, null).MemberwiseClone();
          var flag2 = (this._lightComponents).TryGetValue(keyValuePair.get_Key(), /* ref */ result);
          if (!flag2) {
            (this._lightComponents).Add(
              keyValuePair.get_Key(), 
              keyValuePair.get_Value().MemberwiseClone()
            );
          }
        }
      } finally {
        if (enumerator !== null) {
          $IM03().Call(enumerator, null);
        }
      }
      $thisType.AllLightResults = this._lightComponents;
      this.LightsToModelViewSpace();
    }
  }; 

  function SceneRenderer_Animate () {
    var flag = (((this._animation).get_ChannelBaseList()).get_Count() >>> 0) > (0 >>> 0);
    if (flag) {
      (this._animation).Animate($T16().get_DeltaTime());
    }
  }; 

  function SceneRenderer_AssembleEffectParamers (mc, scb) {
    var effectParameters = new JSIL.BoxedVariable($S04().Construct());
    var hasDiffuse = mc.get_HasDiffuse();
    if (hasDiffuse) {
      var arg_42_0 = effectParameters.get();
      var item = new ($T1A())();
      item.Name = $T18().ShaderCodeBuilder$DiffuseColorName$value;
      item.Value = mc.Diffuse.Color.MemberwiseClone();
      $S05().CallVirtual("Add", null, arg_42_0, item.MemberwiseClone());
      var flag = mc.Diffuse.Texture !== null;
      if (flag) {
        var arg_88_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = $T18().ShaderCodeBuilder$DiffuseMixName$value;
        item.Value = $T1B().$Box(mc.Diffuse.Mix);
        $S05().CallVirtual("Add", null, arg_88_0, item.MemberwiseClone());
        var arg_BC_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = $T18().ShaderCodeBuilder$DiffuseTextureName$value;
        item.Value = this.LoadTexture(mc.Diffuse.Texture);
        $S05().CallVirtual("Add", null, arg_BC_0, item.MemberwiseClone());
      }
    }
    var hasSpecular = mc.get_HasSpecular();
    if (hasSpecular) {
      var arg_101_0 = effectParameters.get();
      item = new ($T1A())();
      item.Name = $T18().ShaderCodeBuilder$SpecularColorName$value;
      item.Value = mc.Specular.Color.MemberwiseClone();
      $S05().CallVirtual("Add", null, arg_101_0, item.MemberwiseClone());
      var arg_134_0 = effectParameters.get();
      item = new ($T1A())();
      item.Name = $T18().ShaderCodeBuilder$SpecularShininessName$value;
      item.Value = $T1B().$Box(mc.Specular.Shininess);
      $S05().CallVirtual("Add", null, arg_134_0, item.MemberwiseClone());
      var arg_167_0 = effectParameters.get();
      item = new ($T1A())();
      item.Name = $T18().ShaderCodeBuilder$SpecularIntensityName$value;
      item.Value = $T1B().$Box(mc.Specular.Intensity);
      $S05().CallVirtual("Add", null, arg_167_0, item.MemberwiseClone());
      var flag2 = mc.Specular.Texture !== null;
      if (flag2) {
        var arg_1AF_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = $T18().ShaderCodeBuilder$SpecularMixName$value;
        item.Value = $T1B().$Box(mc.Specular.Mix);
        $S05().CallVirtual("Add", null, arg_1AF_0, item.MemberwiseClone());
        var arg_1E3_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = $T18().ShaderCodeBuilder$SpecularTextureName$value;
        item.Value = this.LoadTexture(mc.Specular.Texture);
        $S05().CallVirtual("Add", null, arg_1E3_0, item.MemberwiseClone());
      }
    }
    var hasEmissive = mc.get_HasEmissive();
    if (hasEmissive) {
      var arg_228_0 = effectParameters.get();
      item = new ($T1A())();
      item.Name = $T18().ShaderCodeBuilder$EmissiveColorName$value;
      item.Value = mc.Emissive.Color.MemberwiseClone();
      $S05().CallVirtual("Add", null, arg_228_0, item.MemberwiseClone());
      var flag3 = mc.Emissive.Texture !== null;
      if (flag3) {
        var arg_270_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = $T18().ShaderCodeBuilder$EmissiveMixName$value;
        item.Value = $T1B().$Box(mc.Emissive.Mix);
        $S05().CallVirtual("Add", null, arg_270_0, item.MemberwiseClone());
        var arg_2A4_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = $T18().ShaderCodeBuilder$EmissiveTextureName$value;
        item.Value = this.LoadTexture(mc.Emissive.Texture);
        $S05().CallVirtual("Add", null, arg_2A4_0, item.MemberwiseClone());
      }
    }
    var hasBump = mc.get_HasBump();
    if (hasBump) {
      var arg_2E6_0 = effectParameters.get();
      item = new ($T1A())();
      item.Name = $T18().ShaderCodeBuilder$BumpIntensityName$value;
      item.Value = $T1B().$Box(mc.Bump.Intensity);
      $S05().CallVirtual("Add", null, arg_2E6_0, item.MemberwiseClone());
      var arg_31A_0 = effectParameters.get();
      item = new ($T1A())();
      item.Name = $T18().ShaderCodeBuilder$BumpTextureName$value;
      item.Value = this.LoadTexture(mc.Bump.Texture);
      $S05().CallVirtual("Add", null, arg_31A_0, item.MemberwiseClone());
    }
    $thisType.SetLightEffectParameters(/* ref */ effectParameters);
    return effectParameters.get();
  }; 

  function SceneRenderer_BuildMaterialFromShaderComponent (shaderComponent) {
    var shaderEffect = new JSIL.BoxedVariable(null);
    var flag = (this._shaderEffectMap).TryGetValue(shaderComponent, /* ref */ shaderEffect);
    if (flag) {
      var result = shaderEffect.get();
    } else {
      shaderEffect.set($thisType.MakeShader(shaderComponent));
      (shaderEffect.get()).AttachToContext(this._rc);
      (this._shaderEffectMap).Add(shaderComponent, shaderEffect.get());
      result = shaderEffect.get();
    }
    return result;
  }; 

  function SceneRenderer_CreateEffectParameterDeclaration (effectParameter) {
    var effectParameterDouble = null, effectParameterInt = null, effectParameterFloat = null, effectParameterFloat2 = null, effectParameterFloat3 = null, effectParameterFloat4 = null, effectParameterBool = null;
    var flag = effectParameter.Name === null;
    if (flag) {
      throw $S06().Construct("EffectParameterDeclaration: Name is empty!");
    }
    var effectParameterDeclaration = new ($T1A())();
    effectParameterDeclaration.Name = effectParameter.Name;
    var returnEffectParameterDeclaration = effectParameterDeclaration.MemberwiseClone();
    var t = effectParameter.TypeId;
    switch (t.valueOf()) {
      case 0: 
        var flag2 = (effectParameterDouble = $T20().$As(effectParameter)) !== null;
        if (flag2) {
          returnEffectParameterDeclaration.Value = $T29().$Box(effectParameterDouble.Value);
        }
        break;

      case 1: 
        var flag3 = (effectParameterInt = $T21().$As(effectParameter)) !== null;
        if (flag3) {
          returnEffectParameterDeclaration.Value = $T2A().$Box(effectParameterInt.Value);
        }
        break;

      case 2: 
        var flag4 = (effectParameterFloat = $T22().$As(effectParameter)) !== null;
        if (flag4) {
          returnEffectParameterDeclaration.Value = $T1B().$Box(effectParameterFloat.Value);
        }
        break;

      case 3: 
        var flag5 = (effectParameterFloat2 = $T23().$As(effectParameter)) !== null;
        if (flag5) {
          returnEffectParameterDeclaration.Value = effectParameterFloat2.Value.MemberwiseClone();
        }
        break;

      case 4: 
        var flag6 = (effectParameterFloat3 = $T24().$As(effectParameter)) !== null;
        if (flag6) {
          returnEffectParameterDeclaration.Value = effectParameterFloat3.Value.MemberwiseClone();
        }
        break;

      case 5: 
        var flag7 = (effectParameterFloat4 = $T25().$As(effectParameter)) !== null;
        if (flag7) {
          returnEffectParameterDeclaration.Value = effectParameterFloat4.Value.MemberwiseClone();
        }
        break;

      case 6: 
        var flag8 = (effectParameterBool = $T26().$As(effectParameter)) !== null;
        if (flag8) {
          returnEffectParameterDeclaration.Value = $T03().$Box(effectParameterBool.Value);
        }
        break;

      default: 
        throw $S06().Construct($T2B().Format("EffectParameterDeclaration:{0} is of unhandled type {1}!", JSIL.Array.New($T2C(), [effectParameter.Name, t.toString()])));

    }
    var flag9 = returnEffectParameterDeclaration.Value === null;
    if (flag9) {
      throw $S06().Construct($T2B().Format("EffectParameterDeclaration:{0}, value is null", JSIL.Array.New($T2C(), [effectParameter.Name])));
    }
    return returnEffectParameterDeclaration;
  }; 

  function SceneRenderer_CreateEnvMapPassEffect (rc) {
    var effectPass = JSIL.Array.New($T2F(), 1);
    var arg_37_0 = effectPass;
    var effectPassDeclaration = new ($T2F())();
    effectPassDeclaration.PS = $T30().EnvMapPixelShader;
    effectPassDeclaration.VS = $T30().EnvMapVertexShader;
    effectPassDeclaration.StateSet = new ($T31())();
    arg_37_0[0] = effectPassDeclaration.MemberwiseClone();
    var expr_41 = $S04().Construct();
    var item = new ($T1A())();
    item.Name = "ViewMatrix";
    item.Value = $T10().Identity.MemberwiseClone();
    $S05().CallVirtual("Add", null, expr_41, item.MemberwiseClone());
    item = new ($T1A())();
    item.Name = "DiffuseColor";
    item.Value = $S03().Construct(0.5, 0.5, 0.5);
    $S05().CallVirtual("Add", null, expr_41, item.MemberwiseClone());
    var effectParameter = expr_41;
    $T30().EnvMapPassShaderEffect = new ($T1D())(effectPass, effectParameter);
    $T30().EnvMapPassShaderEffect.AttachToContext(rc);
  }; 

  function SceneRenderer_CreateGBufferDrawPassEffect (rc) {
    $T30().Maxlights = ($thisType.AllLightResults.get_Count() | 0);
    var effectPass = JSIL.Array.New($T2F(), 1);
    var arg_46_0 = effectPass;
    var effectPassDeclaration = new ($T2F())();
    effectPassDeclaration.VS = $T30().DeferredDrawPassVertexShader();
    effectPassDeclaration.PS = $T30().DeferredDrawPassPixelShader();
    effectPassDeclaration.StateSet = new ($T31())();
    arg_46_0[0] = effectPassDeclaration.MemberwiseClone();
    var expr_50 = $S04().Construct();
    var item = new ($T1A())();
    item.Name = "gPosition";
    item.Value = $T30().GBufferTexture;
    $S05().CallVirtual("Add", null, expr_50, item.MemberwiseClone());
    item = new ($T1A())();
    item.Name = "gNormal";
    item.Value = $T30().GBufferTexture;
    $S05().CallVirtual("Add", null, expr_50, item.MemberwiseClone());
    item = new ($T1A())();
    item.Name = "gAlbedoSpec";
    item.Value = $T30().GBufferTexture;
    $S05().CallVirtual("Add", null, expr_50, item.MemberwiseClone());
    item = new ($T1A())();
    item.Name = "gViewDir";
    item.Value = $T30().GBufferTexture;
    $S05().CallVirtual("Add", null, expr_50, item.MemberwiseClone());
    item = new ($T1A())();
    item.Name = "gScreenSize";
    item.Value = $S01().Construct(+(this._rc.RenderContext$ViewportWidth$value), +(this._rc.RenderContext$ViewportHeight$value));
    $S05().CallVirtual("Add", null, expr_50, item.MemberwiseClone());
    var effectParameter = new JSIL.BoxedVariable(expr_50);
    $thisType.SetLightEffectParameters(/* ref */ effectParameter);
    $T30().GBufferDrawPassShaderEffect = new ($T1D())(effectPass, effectParameter.get());
    $T30().GBufferDrawPassShaderEffect.AttachToContext(rc);
  }; 

  function SceneRenderer_CreateGBufferPassEffect (rc) {
    var effectPass = JSIL.Array.New($T2F(), 1);
    var arg_37_0 = effectPass;
    var effectPassDeclaration = new ($T2F())();
    effectPassDeclaration.VS = $T30().DeferredPassVertexShader();
    effectPassDeclaration.PS = $T30().DeferredPassPixelShader();
    effectPassDeclaration.StateSet = new ($T31())();
    arg_37_0[0] = effectPassDeclaration.MemberwiseClone();
    var expr_41 = $S04().Construct();
    var item = new ($T1A())();
    item.Name = "DiffuseColor";
    item.Value = $T0F().Zero.MemberwiseClone();
    $S05().CallVirtual("Add", null, expr_41, item.MemberwiseClone());
    item = new ($T1A())();
    item.Name = "SpecularIntensity";
    item.Value = $T0F().One.MemberwiseClone();
    $S05().CallVirtual("Add", null, expr_41, item.MemberwiseClone());
    var effectParameter = expr_41;
    $T30().GBufferPassShaderEffect = new ($T1D())(effectPass, effectParameter);
    $T30().GBufferPassShaderEffect.AttachToContext(rc);
  }; 

  function SceneRenderer_CreateShadowPassShaderEffect (rc) {
    var effectPass = JSIL.Array.New($T2F(), 1);
    var arg_37_0 = effectPass;
    var effectPassDeclaration = new ($T2F())();
    effectPassDeclaration.PS = $T30().OrtographicShadowMapMvPixelShader();
    effectPassDeclaration.VS = $T30().OrtographicShadowMapMvVertexShader();
    effectPassDeclaration.StateSet = new ($T31())();
    arg_37_0[0] = effectPassDeclaration.MemberwiseClone();
    var expr_41 = $S04().Construct();
    var item = new ($T1A())();
    item.Name = "LightMVP";
    item.Value = $T30().DeferredShaderHelper$ShadowMapMVP$value.MemberwiseClone();
    $S05().CallVirtual("Add", null, expr_41, item.MemberwiseClone());
    var effectParameter = expr_41;
    $T30().ShadowPassShaderEffect = new ($T1D())(effectPass, effectParameter);
    $T30().ShadowPassShaderEffect.AttachToContext(rc);
  }; 

  function SceneRenderer_get_DoRenderDeferred () {
    return this._renderDeferred;
  }; 

  function SceneRenderer_get_DoRenderEnvMap () {
    return this._renderEnvMap;
  }; 

  function SceneRenderer_get_DoRenderWithShadows () {
    return this._renderWithShadows;
  }; 

  function SceneRenderer_get_ShadowMapSize () {
    return this.SceneRenderer$ShadowMapSize$value;
  }; 

  function SceneRenderer_InitAnimations (sc) {
    var $temp00, $temp01, $temp02, $temp03, $temp04, $temp05;
    var arg_33_1 = null;
    this._animation = new ($T15())(0);
    var arg_33_0 = sc.Children;
    if ((arg_33_1 = $T34().$l$g9__38_0) === null) {
      arg_33_1 = $T34().$l$g9__38_0 = $T32().New($T34().$l$g9, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.SceneRenderer_$l$gc, "$lInitAnimations$gb__38_0", $S07(), false, false));
    }
    var enumerator = $IM04().Call($S08().CallStatic($T38(), "FindComponents$b1", [$asm0A.Fusee.Serialization.AnimationComponent], arg_33_0, arg_33_1), null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var ac = $IM05().Call(enumerator, null);
        var flag = ac.AnimationTracks !== null;
        if (flag) {

          for (var a$0 = ac.AnimationTracks._items, i$0 = 0, l$0 = (ac.AnimationTracks._size | 0); i$0 < l$0; ($temp00 = i$0, 
              i$0 = ((i$0 + 1) | 0), 
              $temp00)) {
            var animTrackContainer = a$0[i$0];
            switch ((animTrackContainer.TypeId).valueOf()) {
              case 1: 
                var channel = $S09().Construct($T3B().New(null, null, new JSIL.MethodPointerInfo($asm0D.Fusee.Xirkit.Lerp, "IntLerp", $S0A(), true, false)));

                for (var a$1 = animTrackContainer.KeyFrames._items, i$1 = 0, l$1 = (animTrackContainer.KeyFrames._size | 0); i$1 < l$1; ($temp01 = i$1, 
                    i$1 = ((i$1 + 1) | 0), 
                    $temp01)) {
                  var key = $T3C().$Cast(a$1[i$1]);
                  $T3A().prototype.AddKeyframe.call(channel, new ($T3D())(key.Time, key.Value));
                }
                (this._animation).AddAnimation$b1($T2A())(channel, animTrackContainer.SceneComponent, animTrackContainer.Property);
                break;

              case 2: 
                var channel2 = $S0B().Construct($T3F().New(null, null, new JSIL.MethodPointerInfo($asm0D.Fusee.Xirkit.Lerp, "FloatLerp", $S0C(), true, false)));

                for (var a$2 = animTrackContainer.KeyFrames._items, i$2 = 0, l$2 = (animTrackContainer.KeyFrames._size | 0); i$2 < l$2; ($temp02 = i$2, 
                    i$2 = ((i$2 + 1) | 0), 
                    $temp02)) {
                  var key2 = $T40().$Cast(a$2[i$2]);
                  $T3E().prototype.AddKeyframe.call(channel2, new ($T41())(key2.Time, key2.Value));
                }
                (this._animation).AddAnimation$b1($T1B())(channel2, animTrackContainer.SceneComponent, animTrackContainer.Property);
                break;

              case 3: 
                var channel3 = $S0D().Construct($T43().New(null, null, new JSIL.MethodPointerInfo($asm0D.Fusee.Xirkit.Lerp, "Float2Lerp", $S0E(), true, false)));

                for (var a$3 = animTrackContainer.KeyFrames._items, i$3 = 0, l$3 = (animTrackContainer.KeyFrames._size | 0); i$3 < l$3; ($temp03 = i$3, 
                    i$3 = ((i$3 + 1) | 0), 
                    $temp03)) {
                  var key3 = $T44().$Cast(a$3[i$3]);
                  $T42().prototype.AddKeyframe.call(channel3, new ($T45())(key3.Time, key3.Value.MemberwiseClone()));
                }
                (this._animation).AddAnimation$b1($T05())(channel3, animTrackContainer.SceneComponent, animTrackContainer.Property);
                break;

              case 4: 
                var lerpType = animTrackContainer.LerpType;
                if ((lerpType.valueOf() | 0) !== 0) {
                  if (lerpType !== $T46().Slerp) {
                    throw $S0F().Construct(JSIL.ConcatString("Unknown lerp type: animTrackContainer.LerpType: ", $T2A().$Box((animTrackContainer.LerpType).valueOf())));
                  }
                  var lerpFunc = $T48().New(null, null, new JSIL.MethodPointerInfo($asm0D.Fusee.Xirkit.Lerp, "Float3QuaternionSlerp", $S10(), true, false));
                } else {
                  lerpFunc = $T48().New(null, null, new JSIL.MethodPointerInfo($asm0D.Fusee.Xirkit.Lerp, "Float3Lerp", $S11(), true, false));
                }
                var channel4 = $S12().Construct(lerpFunc);

                for (var a$4 = animTrackContainer.KeyFrames._items, i$4 = 0, l$4 = (animTrackContainer.KeyFrames._size | 0); i$4 < l$4; ($temp04 = i$4, 
                    i$4 = ((i$4 + 1) | 0), 
                    $temp04)) {
                  var key4 = $T4A().$Cast(a$4[i$4]);
                  $T49().prototype.AddKeyframe.call(channel4, new ($T4B())(key4.Time, key4.Value.MemberwiseClone()));
                }
                (this._animation).AddAnimation$b1($T0F())(channel4, animTrackContainer.SceneComponent, animTrackContainer.Property);
                break;

              case 5: 
                var channel5 = $S13().Construct($T4D().New(null, null, new JSIL.MethodPointerInfo($asm0D.Fusee.Xirkit.Lerp, "Float4Lerp", $S14(), true, false)));

                for (var a$5 = animTrackContainer.KeyFrames._items, i$5 = 0, l$5 = (animTrackContainer.KeyFrames._size | 0); i$5 < l$5; ($temp05 = i$5, 
                    i$5 = ((i$5 + 1) | 0), 
                    $temp05)) {
                  var key5 = $T4E().$Cast(a$5[i$5]);
                  $T4C().prototype.AddKeyframe.call(channel5, new ($T4F())(key5.Time, key5.Value.MemberwiseClone()));
                }
                (this._animation).AddAnimation$b1($T50())(channel5, animTrackContainer.SceneComponent, animTrackContainer.Property);
                break;

            }
          }
        }
      }
    } finally {
      if (enumerator !== null) {
        $IM03().Call(enumerator, null);
      }
    }
  }; 

  function SceneRenderer_InitState () {
    (this._state).Clear();
    (this._state.Model = $T10().Identity.MemberwiseClone());
    var arg_4A_0 = this._state;
    var uiRect = new ($T52())();
    uiRect.Min = $T05().op_UnaryNegation($T05().One.MemberwiseClone());
    uiRect.Max = $T05().One.MemberwiseClone();
    (arg_4A_0.UiRect = uiRect.MemberwiseClone());
    (this._state).set_Effect(this._defaultEffect);
    this._view = (this._rc).get_ModelView().MemberwiseClone();
  }; 

  function SceneRenderer_LightsToModelViewSpace () {
    var $temp00;
    var lightConeDirectionFloat4 = new ($T50())();

    for (var a$0 = $T53().ToList$b1($T0E())($thisType.AllLightResults.get_Keys())._items, i$0 = 0, l$0 = ($T53().ToList$b1($T0E())($thisType.AllLightResults.get_Keys())._size | 0); i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var key = a$0[i$0];
      var light = $thisType.AllLightResults.get_Item(key).MemberwiseClone();
      light.PositionModelViewSpace = $S15().CallStatic($T10(), "op_Multiply", null, (this._rc).get_ModelView(), light.PositionWorldSpace);
      (lightConeDirectionFloat4 = lightConeDirectionFloat4.MemberwiseClone(), 
        $T50().prototype._ctor.call(lightConeDirectionFloat4, light.ConeDirection.x, light.ConeDirection.y, light.ConeDirection.z, 0));
      lightConeDirectionFloat4 = $S16().CallStatic($T10(), "op_Multiply", null, (this._rc).get_ModelView(), lightConeDirectionFloat4);
      lightConeDirectionFloat4.Normalize();
      light.ConeDirectionModelViewSpace = $S03().Construct(lightConeDirectionFloat4.x, lightConeDirectionFloat4.y, lightConeDirectionFloat4.z);
      light.ConeAngle = +$T54().DegreesToRadians(light.ConeAngle);
      $thisType.AllLightResults.set_Item(key, light.MemberwiseClone());
    }
  }; 

  function SceneRenderer_LoadTexture (path) {
    var image = $T56().Get$b1($T55())(path).MemberwiseClone();
    return (this._rc).CreateTexture(image.MemberwiseClone(), false);
  }; 

  function SceneRenderer_LookupMaterial$02 (mc) {
    var mat = new JSIL.BoxedVariable(null);
    var flag = (this._matMap).TryGetValue(mc, /* ref */ mat);
    if (flag) {
      var result = mat.get();
    } else {
      mat.set(this.MakeMaterial(mc));
      (mat.get()).AttachToContext(this._rc);
      (this._matMap).Add(mc, mat.get());
      result = mat.get();
    }
    return result;
  }; 

  function SceneRenderer_LookupMaterial$03 (mc) {
    var mat = new JSIL.BoxedVariable(null);
    var flag = (this._lightMatMap).TryGetValue(mc, /* ref */ mat);
    if (flag) {
      var result = mat.get();
    } else {
      mat.set(this.MakeMaterial(mc));
      (mat.get()).AttachToContext(this._rc);
      (this._lightMatMap).Add(mc, mat.get());
      result = mat.get();
    }
    return result;
  }; 

  function SceneRenderer_LookupMaterial$04 (mc) {
    var mat = new JSIL.BoxedVariable(null);
    var flag = (this._pbrComponent).TryGetValue(mc, /* ref */ mat);
    if (flag) {
      var result = mat.get();
    } else {
      mat.set(this.MakeMaterial(mc));
      (mat.get()).AttachToContext(this._rc);
      (this._pbrComponent).Add(mc, mat.get());
      result = mat.get();
    }
    return result;
  }; 

  function SceneRenderer_MakeMaterial (mc) {
    var lightMat = null, pbrMaterial = null;
    var wc = $T5D().GetWeights(this.SceneVisitor$CurrentNode$value, 0);
    var scb = null;
    if (JSIL.GetType(mc) === $T58().__Type__) {
      var flag2 = (lightMat = $T58().$As(mc)) !== null;
      if (flag2) {
        scb = $S17().Construct(lightMat, null, wc, this._renderWithShadows);
      }
    } else {
      if (JSIL.GetType(mc) === $T5A().__Type__) {
        var flag4 = (pbrMaterial = $T5A().$As(mc)) !== null;
        if (flag4) {
          scb = $S18().Construct(pbrMaterial, null, $thisType.LightingCalculationMethod, wc, this._renderWithShadows);
        }
      } else {
        scb = $S17().Construct(mc, null, wc, this._renderWithShadows);
      }
    }
    var effectParameters = this.AssembleEffectParamers(mc, scb);
    var flag5 = scb !== null;
    if (flag5) {
      var expr_BA = JSIL.Array.New($T2F(), 1);
      var effectPassDeclaration = new ($T2F())();
      effectPassDeclaration.VS = scb.ShaderCodeBuilder$VS$value;
      effectPassDeclaration.PS = scb.ShaderCodeBuilder$PS$value;
      var expr_E5 = new ($T31())();
      expr_E5.set_ZEnable(true);
      expr_E5.set_AlphaBlendEnable(false);
      effectPassDeclaration.StateSet = expr_E5;
      expr_BA[0] = effectPassDeclaration.MemberwiseClone();
      return new ($T1D())(expr_BA, effectParameters);
    }
    throw $S19().Construct("Material could not be evaluated or be built!");
  }; 

  function SceneRenderer_MakeMesh (mc) {
    var wc = $T5D().GetWeights(this.SceneVisitor$CurrentNode$value, 0);
    if (wc === null) {
      var expr_1C = new ($T61())();
      expr_1C.set_Colors(null);
      expr_1C.set_Normals(mc.Normals);
      expr_1C.set_UVs(mc.UVs);
      expr_1C.set_Vertices(mc.Vertices);
      expr_1C.set_Triangles(mc.Triangles);
      var rm = expr_1C;
    } else {
      var boneWeights = JSIL.Array.New($T50(), (wc.WeightMap).get_Count());
      var boneIndices = JSIL.Array.New($T50(), (wc.WeightMap).get_Count());

      for (var iVert = 0; iVert < ((wc.WeightMap).get_Count() | 0); iVert = ((iVert + 1) | 0)) {
        var vwl = (wc.WeightMap).get_Item(iVert);
        var flag2 = vwl === null;
        if (flag2) {
          vwl = new ($T64())();
        }
        var flag3 = vwl.VertexWeightList$VertexWeights$value === null;
        if (flag3) {
          var arg_EF_0 = vwl;
          var expr_C5 = JSIL.Array.New($T66(), 1);
          var vertexWeight = new ($T66())();
          vertexWeight.JointIndex = 0;
          vertexWeight.Weight = 1;
          expr_C5[0] = vertexWeight.MemberwiseClone();
          arg_EF_0.VertexWeightList$VertexWeights$value = $S1A().Construct($T68().$Cast(expr_C5));
        }
        var nJoints = ($T69().Min(4, (vwl.VertexWeightList$VertexWeights$value).get_Count()) | 0);

        for (var iJoint = 0; iJoint < nJoints; iJoint = ((iJoint + 1) | 0)) {
          switch (iJoint) {
            case 0: 
              boneWeights[iVert].x = +(vwl.VertexWeightList$VertexWeights$value).get_Item(iJoint).Weight;
              boneIndices[iVert].x = +((vwl.VertexWeightList$VertexWeights$value).get_Item(iJoint).JointIndex);
              break;

            case 1: 
              boneWeights[iVert].y = +(vwl.VertexWeightList$VertexWeights$value).get_Item(iJoint).Weight;
              boneIndices[iVert].y = +((vwl.VertexWeightList$VertexWeights$value).get_Item(iJoint).JointIndex);
              break;

            case 2: 
              boneWeights[iVert].z = +(vwl.VertexWeightList$VertexWeights$value).get_Item(iJoint).Weight;
              boneIndices[iVert].z = +((vwl.VertexWeightList$VertexWeights$value).get_Item(iJoint).JointIndex);
              break;

            case 3: 
              boneWeights[iVert].w = +(vwl.VertexWeightList$VertexWeights$value).get_Item(iJoint).Weight;
              boneIndices[iVert].w = +((vwl.VertexWeightList$VertexWeights$value).get_Item(iJoint).JointIndex);
              break;

          }
        }
        (boneWeights[iVert].MemberwiseClone()).Normalize1();
      }
      var expr_290 = new ($T61())();
      expr_290.set_Colors(null);
      expr_290.set_Normals(mc.Normals);
      expr_290.set_UVs(mc.UVs);
      expr_290.set_BoneIndices(boneIndices);
      expr_290.set_BoneWeights(boneWeights);
      expr_290.set_Vertices(mc.Vertices);
      expr_290.set_Triangles(mc.Triangles);
      rm = expr_290;
    }
    return rm;
  }; 

  function SceneRenderer_MakeShader (shaderComponent) {
    var $temp00;
    var effectParametersFromShaderComponent = $S04().Construct();
    var renderStateSet = new ($T31())();
    var flag = shaderComponent.EffectParameter !== null;
    if (flag) {
      var allEffectParameterDeclaration = $S04().Construct();

      for (var a$0 = shaderComponent.EffectParameter._items, i$0 = 0, l$0 = (shaderComponent.EffectParameter._size | 0); i$0 < l$0; ($temp00 = i$0, 
          i$0 = ((i$0 + 1) | 0), 
          $temp00)) {
        var effectParam = a$0[i$0];
        $S05().CallVirtual("Add", null, allEffectParameterDeclaration, $thisType.CreateEffectParameterDeclaration(effectParam).MemberwiseClone());
      }
      $T19().prototype.AddRange.call(effectParametersFromShaderComponent, allEffectParameterDeclaration);
    }
    var flag2 = shaderComponent.EffectPasses === null;
    if (flag2) {
      throw $S06().Construct("No EffectPasses in Shader Component! Please specify at least one pass");
    }
    var effectPasses = JSIL.Array.New($T2F(), (shaderComponent.EffectPasses).get_Count());

    for (var i = 0; i < ((shaderComponent.EffectPasses).get_Count() | 0); i = ((i + 1) | 0)) {
      var newEffectPass = new ($T2F())();
      var effectPass = (shaderComponent.EffectPasses).get_Item(i);
      var flag3 = effectPass.RenderStateContainer !== null;
      if (flag3) {
        renderStateSet = new ($T31())();
        renderStateSet.SetRenderStates(effectPass.RenderStateContainer);
      }
      newEffectPass.VS = effectPass.VS;
      newEffectPass.PS = effectPass.PS;
      newEffectPass.StateSet = renderStateSet;
      effectPasses[i] = newEffectPass.MemberwiseClone();
    }
    return new ($T1D())(effectPasses, effectParametersFromShaderComponent);
  }; 

  function SceneRenderer_PopState () {
    (this._state).Pop();
    (this._rc.Model = (this._state).get_Model().MemberwiseClone());
    (this._rc.View = this._view.MemberwiseClone());
  }; 

  function SceneRenderer_PushState () {
    (this._state).Push();
  }; 

  function SceneRenderer_Render (rc) {
    this.SetContext(rc);
    var doRenderWithShadows = this.get_DoRenderWithShadows();
    if (doRenderWithShadows) {
      this.RenderWithShadow(rc);
    } else {
      var doRenderDeferred = this.get_DoRenderDeferred();
      if (doRenderDeferred) {
        this.RenderDeferredPasses(rc);
      } else {
        var doRenderEnvMap = this.get_DoRenderEnvMap();
        if (doRenderEnvMap) {
          this.RenderEnvMapPasses(rc);
        } else {
          rc.SetRenderTarget(null);
          $S1B().CallVirtual("Traverse", null, this, this._sc.Children);
        }
      }
    }
  }; 

  function SceneRenderer_RenderBone (bone) {
    var transform = new JSIL.BoxedVariable(new ($T10())());
    var boneContainer = this.SceneVisitor$CurrentNode$value;
    var flag = !(this._boneMap).TryGetValue(boneContainer, /* ref */ transform);
    if (flag) {
      (this._boneMap).Add(boneContainer, (this._rc).get_ModelView().MemberwiseClone());
    } else {
      (this._boneMap).set_Item(boneContainer, (this._rc).get_ModelView().MemberwiseClone());
    }
  }; 

  function SceneRenderer_RenderCurrentPass (rm, effect) {
    var doRenderWithShadows = this.get_DoRenderWithShadows();
    if (doRenderWithShadows) {
      if (($T30().CurrentRenderPass | 0) === 0) {
        this.RenderFirstShadowPass(rm);
      } else {
        this.RenderSecondShadowPass(rm, effect);
      }
    } else {
      var doRenderDeferred = this.get_DoRenderDeferred();
      if (doRenderDeferred) {
        if (($T30().CurrentRenderPass | 0) === 0) {
          $thisType.RenderDeferredModelPass(rm, effect);
        }
      } else {
        var doRenderEnvMap = this.get_DoRenderEnvMap();
        if (doRenderEnvMap) {
          if (($T30().CurrentRenderPass | 0) === 0) {
            this.RenderEnvMapFirstPass(rm, effect);
          } else {
            this.RenderEnvMapSecondPass(rm, effect);
          }
        } else {
          this.RenderStandardPass(rm, effect);
        }
      }
    }
  }; 

  function SceneRenderer_RenderDeferredLightPass () {
    if ($T30().GBufferDrawPassShaderEffect !== null) {
      var programm = (this._rc).CreateShader(
        $T30().DeferredDrawPassVertexShader(), 
        $T30().DeferredDrawPassPixelShader()
      );
      $T30().GBufferDrawPassShaderEffect._rc.SetShader(programm);
      var gPosition = $T30().GBufferDrawPassShaderEffect._rc.get_CurrentShader().GetShaderParam("gPosition");
      var flag2 = gPosition !== null;
      if (flag2) {
        $T30().GBufferDrawPassShaderEffect._rc.SetShaderParamTexture(gPosition, $T30().GBufferTexture, $T71().GPositionHandle);
      }
      var gNormal = $T30().GBufferDrawPassShaderEffect._rc.get_CurrentShader().GetShaderParam("gNormal");
      var flag3 = gNormal !== null;
      if (flag3) {
        $T30().GBufferDrawPassShaderEffect._rc.SetShaderParamTexture(gNormal, $T30().GBufferTexture, $T71().GNormalHandle);
      }
      var gAlbedoSpec = $T30().GBufferDrawPassShaderEffect._rc.get_CurrentShader().GetShaderParam("gAlbedoSpec");
      var flag4 = gAlbedoSpec !== null;
      if (flag4) {
        $T30().GBufferDrawPassShaderEffect._rc.SetShaderParamTexture(gAlbedoSpec, $T30().GBufferTexture, $T71().GAlbedoHandle);
      }
      var gDepth = $T30().GBufferDrawPassShaderEffect._rc.get_CurrentShader().GetShaderParam("gDepth");
      var flag5 = gDepth !== null;
      if (flag5) {
        $T30().GBufferDrawPassShaderEffect._rc.SetShaderParamTexture(gDepth, $T30().GBufferTexture, $T71().GDepth);
      }
      $T30().GBufferDrawPassShaderEffect.SetEffectParam("gScreenSize", $S01().Construct(+(this._rc.RenderContext$ViewportWidth$value), +(this._rc.RenderContext$ViewportHeight$value)));

      for (var i = 0; i < (((this._lightComponents).get_Keys()).get_Count() | 0); i = ((i + 1) | 0)) {
        $thisType.UpdateGBufferDrawPassLights(i, (this._lightComponents).get_Item($T53().ElementAt$b1($T0E())((this._lightComponents).get_Keys(), i)).MemberwiseClone(), $T30().GBufferDrawPassShaderEffect);
      }
      $T30().GBufferDrawPassShaderEffect.RenderMesh($T30().DeferredFullscreenQuad());
    }
  }; 

  function SceneRenderer_RenderDeferredModelPass (rm, effect) {
    var diffuse = $T0F().One.MemberwiseClone();
    var flag = ((effect._rc).get_CurrentShader() !== null) && 
    (effect.GetEffectParam("DiffuseColor") !== null);
    if (flag) {
      diffuse = $T0F().$Cast(effect.GetEffectParam("DiffuseColor")).MemberwiseClone();
    }
    $T30().GBufferPassShaderEffect.SetEffectParam("DiffuseColor", diffuse.MemberwiseClone());
    $T30().GBufferPassShaderEffect.RenderMesh(rm);
  }; 

  function SceneRenderer_RenderDeferredPasses (rc) {
    this.SetContext(rc);
    if ($T30().GBufferTexture === null) {
      $T30().GBufferTexture = rc.CreateWritableTexture(rc.RenderContext$ViewportWidth$value, rc.RenderContext$ViewportHeight$value, $T73().GBuffer);
    }
    if ($T30().GBufferPassShaderEffect === null) {
      $thisType.CreateGBufferPassEffect(rc);
    }
    if ($T30().GBufferDrawPassShaderEffect === null) {
      this.CreateGBufferDrawPassEffect(rc);
    }
    if ($T30().GBufferPassShaderEffect !== null) {
      $T30().GBufferPassShaderEffect.AttachToContext(rc);
    }
    rc.SetRenderTarget($T30().GBufferTexture);
    $S1B().CallVirtual("Traverse", null, this, this._sc.Children);
    $T30().CurrentRenderPass = ((($T30().CurrentRenderPass | 0) + 1) | 0);
    rc.SetRenderTarget(null);
    rc.CopyDepthBufferFromDeferredBuffer($T30().GBufferTexture);
    this.RenderDeferredLightPass();
    $T30().CurrentRenderPass = ((($T30().CurrentRenderPass | 0) - 1) | 0);
  }; 

  function SceneRenderer_RenderEnvMapFirstPass (rm, effect) {
    var View = $T10().Identity.MemberwiseClone();
    switch ($T30().EnvMapTextureOrientation) {
      case 0: 
        View = $T10().LookAt(
          0, 
          0, 
          0, 
          1, 
          0, 
          0, 
          0, 
          1, 
          0
        );
        break;

      case 1: 
        View = $T10().LookAt(
          0, 
          0, 
          0, 
          -1, 
          0, 
          0, 
          0, 
          1, 
          0
        );
        break;

      case 2: 
        View = $T10().LookAt(
          0, 
          0, 
          0, 
          0, 
          10, 
          0, 
          1, 
          0, 
          0
        );
        break;

      case 3: 
        View = $T10().LookAt(
          0, 
          0, 
          0, 
          0, 
          -10, 
          0, 
          1, 
          0, 
          0
        );
        break;

      case 4: 
        View = $T10().LookAt(
          0, 
          0, 
          0, 
          0, 
          0, 
          10, 
          0, 
          1, 
          0
        );
        break;

      case 5: 
        View = $T10().LookAt(
          0, 
          0, 
          0, 
          0, 
          0, 
          -10, 
          0, 
          1, 
          0
        );
        break;

    }
    View = $S1C().CallStatic($T10(), "op_Multiply", null, 
      $S1C().CallStatic($T10(), "op_Multiply", null, (this._rc).get_Projection().MemberwiseClone(), View.MemberwiseClone()).MemberwiseClone(), 
      (this._state).get_Model().MemberwiseClone()
    ).MemberwiseClone();
    var flag = ($thisType.AllLightResults.get_Count() | 0) === 0;
    if (!flag) {
      var diffuse = $T0F().One.MemberwiseClone();
      var flag2 = effect.GetEffectParam("DiffuseColor") !== null;
      if (flag2) {
        diffuse = $T0F().$Cast(effect.GetEffectParam("DiffuseColor")).MemberwiseClone();
      }
      $T30().EnvMapPassShaderEffect.SetEffectParam("DiffuseColor", diffuse.MemberwiseClone());
      $T30().EnvMapPassShaderEffect.SetEffectParam("ViewMatrix", View.MemberwiseClone());
      $T30().EnvMapPassShaderEffect.RenderMesh(rm);
    }
  }; 

  function SceneRenderer_RenderEnvMapPasses (rc) {
    this.SetContext(rc);
    if ($T30().EnvMapTexture === null) {
      $T30().EnvMapTexture = rc.CreateWritableTexture(rc.RenderContext$ViewportWidth$value, rc.RenderContext$ViewportHeight$value, $T73().CubeMap);
    }
    if ($T30().EnvMapPassShaderEffect === null) {
      $thisType.CreateEnvMapPassEffect(rc);
    }
    if ($T30().EnvMapPassShaderEffect !== null) {
      $T30().EnvMapPassShaderEffect.AttachToContext(rc);
    }

    for (var i = 0; i < 6; i = ((i + 1) | 0)) {
      rc.SetCubeMapRenderTarget($T30().EnvMapTexture, i);
      $T30().EnvMapTextureOrientation = i;
      $S1B().CallVirtual("Traverse", null, this, this._sc.Children);
    }
    $T30().CurrentRenderPass = ((($T30().CurrentRenderPass | 0) + 1) | 0);
    rc.SetRenderTarget(null);
    $S1B().CallVirtual("Traverse", null, this, this._sc.Children);
    $T30().CurrentRenderPass = ((($T30().CurrentRenderPass | 0) - 1) | 0);
  }; 

  function SceneRenderer_RenderEnvMapSecondPass (rm, effect) {
    var flag = (effect._rc).get_CurrentShader() === null;
    if (!flag) {
      var handle = (effect._rc).GetShaderParam((effect._rc).get_CurrentShader(), "envMap");
      var flag2 = handle !== null;
      if (flag2) {
        (effect._rc).SetShaderParamTexture(handle, $T30().EnvMapTexture, $T71().EnvMap);
      }
      this.RenderStandardPass(rm, effect);
    }
  }; 

  function SceneRenderer_RenderFirstShadowPass (rm) {
    var flag = ($thisType.AllLightResults.get_Count() | 0) === 0;
    if (!flag) {
      (this._rc).Viewport(0, 0, ((this.SceneRenderer$ShadowMapSize$value.x) | 0), ((this.SceneRenderer$ShadowMapSize$value.y) | 0));
      $T30().SetShadowMapMVP(
        $thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), 0)).Position.MemberwiseClone(), 
        $thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), 0)).ConeDirection, 
        1, 
        this._view.MemberwiseClone()
      );
      $T30().ShadowPassShaderEffect.SetEffectParam("LightMVP", $T30().DeferredShaderHelper$ShadowMapMVP$value.MemberwiseClone());
      $T30().ShadowPassShaderEffect.RenderMesh(rm);
    }
  }; 

  function SceneRenderer_RenderMaterial$05 (matComp) {
    var effect = $S1D().CallVirtual("LookupMaterial", null, this, matComp);
    this.UpdateEffectParameters(matComp, effect);
    (this._state).set_Effect(effect);
  }; 

  function SceneRenderer_RenderMaterial$06 (matComp) {
    var effect = $S1E().CallVirtual("LookupMaterial", null, this, matComp);
    (this._state).set_Effect(effect);
  }; 

  function SceneRenderer_RenderMaterial$07 (matComp) {
    var effect = $S1F().CallVirtual("LookupMaterial", null, this, matComp);
    (this._state).set_Effect(effect);
  }; 

  function SceneRenderer_RenderMesh (meshComponent) {
    var rm = new JSIL.BoxedVariable(null);
    var flag = !(this._meshMap).TryGetValue(meshComponent, /* ref */ rm);
    if (flag) {
      rm.set(this.MakeMesh(meshComponent));
      (this._meshMap).Add(meshComponent, rm.get());
    }
    this.RenderCurrentPass(rm.get(), (this._state).get_Effect());
  }; 

  function SceneRenderer_RenderRectTransform (rtc) {
    var newRect = new ($T52())();
    newRect.Min = $T05().op_Addition($T05().op_Addition(
        (this._state).get_UiRect().Min.MemberwiseClone(), 
        $S20().CallStatic($T05(), "op_Multiply", null, ((this._state).get_UiRect()).get_Size().MemberwiseClone(), rtc.Anchors.Min)
      ).MemberwiseClone(), rtc.Offsets.Min);
    newRect.Max = $T05().op_Addition($T05().op_Addition(
        (this._state).get_UiRect().Min.MemberwiseClone(), 
        $S20().CallStatic($T05(), "op_Multiply", null, ((this._state).get_UiRect()).get_Size().MemberwiseClone(), rtc.Anchors.Max)
      ).MemberwiseClone(), rtc.Offsets.Max);
    var trans = $T05().op_Subtraction(
      newRect.get_Center().MemberwiseClone(), 
      ((this._state).get_UiRect()).get_Center()
    );
    var scale = $S01().Construct(+((+newRect.get_Size().x / +((this._state).get_UiRect()).get_Size().x)), +((+newRect.get_Size().y / +((this._state).get_UiRect()).get_Size().y)));
    var model = $S1C().CallStatic($T10(), "op_Multiply", null, 
      $T10().CreateTranslation(trans.x, trans.y, 0).MemberwiseClone(), 
      $T10().Scale(scale.x, scale.y, 1).MemberwiseClone()
    );
    (this._state.UiRect = newRect.MemberwiseClone());
    this._state.Model = $S1C().CallStatic($T10(), "op_Multiply", null, this._state.Model.MemberwiseClone(), $T10().Identity.MemberwiseClone()).MemberwiseClone();
    (this._rc.Model = (this._state).get_Model().MemberwiseClone());
    (this._rc.View = this._view.MemberwiseClone());
  }; 

  function SceneRenderer_RenderSecondShadowPass (rm, effect) {
    var flag = (effect._rc).get_CurrentShader() === null;
    if (!flag) {
      (this._rc).Viewport(0, 0, ((this._rcViewportOriginalSize.x) | 0), ((this._rcViewportOriginalSize.y) | 0));
      var handleLight = (effect._rc).GetShaderParam((effect._rc).get_CurrentShader(), "shadowMVP");
      var flag2 = handleLight !== null;
      if (flag2) {
        (effect._rc).SetShaderParamfloat4x4(handleLight, $T30().DeferredShaderHelper$ShadowMapMVP$value.MemberwiseClone());
      }
      var handle = (effect._rc).GetShaderParam((effect._rc).get_CurrentShader(), "firstPassTex");
      var flag3 = handle !== null;
      if (flag3) {
        (effect._rc).SetShaderParamTexture(handle, $T30().ShadowTexture);
      }
      this.RenderStandardPass(rm, effect);
    }
  }; 

  function SceneRenderer_RenderShader (shaderComponent) {
    var effect = this.BuildMaterialFromShaderComponent(shaderComponent);
    (this._state).set_Effect(effect);
  }; 

  function SceneRenderer_RenderStandardPass (rm, effect) {

    for (var i = 0; i < (((this._lightComponents).get_Keys()).get_Count() | 0); i = ((i + 1) | 0)) {
      $thisType.UpdateLightParamsInPixelShader(i, (this._lightComponents).get_Item($T53().ElementAt$b1($T0E())((this._lightComponents).get_Keys(), i)).MemberwiseClone(), effect);
      effect.RenderMesh(rm);
    }
  }; 

  function SceneRenderer_RenderTransform (transform) {
    this._state.Model = $S1C().CallStatic($T10(), "op_Multiply", null, this._state.Model.MemberwiseClone(), $T5D().Matrix(transform).MemberwiseClone()).MemberwiseClone();
    (this._rc.Model = (this._state).get_Model().MemberwiseClone());
    (this._rc.View = this._view.MemberwiseClone());
  }; 

  function SceneRenderer_RenderWeight (weight) {
    var boneArray = JSIL.Array.New($T10(), $S21().CallStatic($T53(), "Count$b1", [$asm0A.Fusee.Serialization.SceneNodeContainer], weight.Joints));

    for (var i = 0; i < ($S21().CallStatic($T53(), "Count$b1", [$asm0A.Fusee.Serialization.SceneNodeContainer], weight.Joints) | 0); i = ((i + 1) | 0)) {
      var tmp = (weight.BindingMatrices).get_Item(i).MemberwiseClone();
      boneArray[i] = $S1C().CallStatic($T10(), "op_Multiply", null, (this._boneMap).get_Item((weight.Joints).get_Item(i)).MemberwiseClone(), tmp.MemberwiseClone()).MemberwiseClone();
    }
    (this._rc).set_Bones(boneArray);
  }; 

  function SceneRenderer_RenderWithShadow (rc) {
    (this.SceneRenderer$ShadowMapSize$value = $S01().Construct(1024, 1024));
    this.SetContext(rc);
    if ($T30().ShadowTexture === null) {
      $T30().ShadowTexture = rc.CreateWritableTexture(((this.SceneRenderer$ShadowMapSize$value.x) | 0), ((this.SceneRenderer$ShadowMapSize$value.y) | 0), $T73().Depth);
    }
    if ($T30().ShadowPassShaderEffect === null) {
      $thisType.CreateShadowPassShaderEffect(rc);
    }
    rc.SetRenderTarget($T30().ShadowTexture);
    $S1B().CallVirtual("Traverse", null, this, this._sc.Children);
    $T30().CurrentRenderPass = ((($T30().CurrentRenderPass | 0) + 1) | 0);
    rc.SetRenderTarget(null);
    $S1B().CallVirtual("Traverse", null, this, this._sc.Children);
    $T30().CurrentRenderPass = ((($T30().CurrentRenderPass | 0) - 1) | 0);
  }; 

  function SceneRenderer_set_DoRenderDeferred (value) {
    this._renderDeferred = (((this._rc).GetHardwareCapabilities($T7A().DefferedPossible) >>> 0) === 1) & value;
  }; 

  function SceneRenderer_set_DoRenderEnvMap (value) {
    this._renderEnvMap = (((this._rc).GetHardwareCapabilities($T7A().DefferedPossible) >>> 0) === 1) & value;
  }; 

  function SceneRenderer_set_DoRenderWithShadows (value) {
    this._renderWithShadows = (((this._rc).GetHardwareCapabilities($T7A().DefferedPossible) >>> 0) === 1) & value;
  }; 

  function SceneRenderer_set_ShadowMapSize (value) {
    this.SceneRenderer$ShadowMapSize$value = value.MemberwiseClone();
  }; 

  function SceneRenderer_SetContext (rc) {
    if (rc === null) {
      throw $S22().Construct("rc");
    }
    var flag2 = rc !== this._rc;
    if (flag2) {
      this._rc = rc;
      this._rcViewportOriginalSize = $S01().Construct(+(this._rc.RenderContext$ViewportWidth$value), +(this._rc.RenderContext$ViewportHeight$value));
      this._meshMap = $S23().Construct();
      this._matMap = $S24().Construct();
      this._lightMatMap = $S25().Construct();
      this._pbrComponent = $S26().Construct();
      this._boneMap = $S27().Construct();
      this._shaderEffectMap = $S28().Construct();
      var expr_9B = new ($T17())();
      var expr_A1 = new ($T7C())();
      expr_A1.Color = $S03().Construct(0.5, 0.5, 0.5);
      expr_9B.Diffuse = expr_A1;
      var expr_C6 = new ($T7D())();
      expr_C6.Color = $S03().Construct(1, 1, 1);
      expr_C6.Intensity = 0.5;
      expr_C6.Shininess = 22;
      expr_9B.Specular = expr_C6;
      this._defaultEffect = this.MakeMaterial(expr_9B);
      (this._defaultEffect).AttachToContext(this._rc);
      this.set_DoRenderDeferred(this._wantToRenderDeferred);
      this.set_DoRenderWithShadows(this._wantToRenderWithShadows);
      this.set_DoRenderEnvMap(this._wantToRenderEnvMap);
    }
  }; 

  function SceneRenderer_SetLightEffectParameters (/* ref */ effectParameters) {

    for (var i = 0; i < ($thisType.AllLightResults.get_Keys().get_Count() | 0); i = ((i + 1) | 0)) {
      var flag = !$thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), i)).Active;
      if (!flag) {
        var arg_86_0 = effectParameters.get();
        var item = new ($T1A())();
        item.Name = (JSIL.ConcatString("allLights[", $T2A().$Box(i), "].position"));
        item.Value = $thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), i)).PositionWorldSpace.MemberwiseClone();
        $S05().CallVirtual("Add", null, arg_86_0, item.MemberwiseClone());
        var arg_DE_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = (JSIL.ConcatString("allLights[", $T2A().$Box(i), "].intensities"));
        item.Value = $thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), i)).Color.MemberwiseClone();
        $S05().CallVirtual("Add", null, arg_DE_0, item.MemberwiseClone());
        var arg_136_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = (JSIL.ConcatString("allLights[", $T2A().$Box(i), "].attenuation"));
        item.Value = $T1B().$Box($thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), i)).Attenuation);
        $S05().CallVirtual("Add", null, arg_136_0, item.MemberwiseClone());
        var arg_18E_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = (JSIL.ConcatString("allLights[", $T2A().$Box(i), "].ambientCoefficient"));
        item.Value = $T1B().$Box($thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), i)).AmbientCoefficient);
        $S05().CallVirtual("Add", null, arg_18E_0, item.MemberwiseClone());
        var arg_1E6_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = (JSIL.ConcatString("allLights[", $T2A().$Box(i), "].coneAngle"));
        item.Value = $T1B().$Box($thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), i)).ConeAngle);
        $S05().CallVirtual("Add", null, arg_1E6_0, item.MemberwiseClone());
        var arg_23E_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = (JSIL.ConcatString("allLights[", $T2A().$Box(i), "].coneDirection"));
        item.Value = $thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), i)).ConeDirection.MemberwiseClone();
        $S05().CallVirtual("Add", null, arg_23E_0, item.MemberwiseClone());
        var arg_296_0 = effectParameters.get();
        item = new ($T1A())();
        item.Name = (JSIL.ConcatString("allLights[", $T2A().$Box(i), "].lightType"));
        item.Value = $T2A().$Box(($thisType.AllLightResults.get_Item($T53().ElementAt$b1($T0E())($thisType.AllLightResults.get_Keys(), i)).Type).valueOf());
        $S05().CallVirtual("Add", null, arg_296_0, item.MemberwiseClone());
      }
    }
  }; 

  function SceneRenderer_UpdateEffectParameters (mc, fx) {
    var hasDiffuse = mc.get_HasDiffuse();
    if (hasDiffuse) {
      fx.SetEffectParam($T18().ShaderCodeBuilder$DiffuseColorName$value, mc.Diffuse.Color.MemberwiseClone());
      var flag = mc.Diffuse.Texture !== null;
      if (flag) {
        fx.SetEffectParam($T18().ShaderCodeBuilder$DiffuseMixName$value, $T1B().$Box(mc.Diffuse.Mix));
      }
    }
    var hasSpecular = mc.get_HasSpecular();
    if (hasSpecular) {
      fx.SetEffectParam($T18().ShaderCodeBuilder$SpecularColorName$value, mc.Specular.Color.MemberwiseClone());
      fx.SetEffectParam($T18().ShaderCodeBuilder$SpecularShininessName$value, $T1B().$Box(mc.Specular.Shininess));
      fx.SetEffectParam($T18().ShaderCodeBuilder$SpecularIntensityName$value, $T1B().$Box(mc.Specular.Intensity));
      var flag2 = mc.Specular.Texture !== null;
      if (flag2) {
        fx.SetEffectParam($T18().ShaderCodeBuilder$SpecularMixName$value, $T1B().$Box(mc.Specular.Mix));
      }
    }
    var hasEmissive = mc.get_HasEmissive();
    if (hasEmissive) {
      fx.SetEffectParam($T18().ShaderCodeBuilder$EmissiveColorName$value, mc.Emissive.Color.MemberwiseClone());
      var flag3 = mc.Emissive.Texture !== null;
      if (flag3) {
        fx.SetEffectParam($T18().ShaderCodeBuilder$EmissiveMixName$value, $T1B().$Box(mc.Emissive.Mix));
      }
    }
    var hasBump = mc.get_HasBump();
    if (hasBump) {
      fx.SetEffectParam($T18().ShaderCodeBuilder$BumpIntensityName$value, $T1B().$Box(mc.Bump.Intensity));
    }
  }; 

  function SceneRenderer_UpdateGBufferDrawPassLights (position, light, effect) {
    var flag = !light.Active;
    if (!flag) {
      effect.SetEffectParam($T2B().Format("allLights[{0}].position", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), light.PositionWorldSpace.MemberwiseClone());
      effect.SetEffectParam($T2B().Format("allLights[{0}].intensities", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), light.Color.MemberwiseClone());
      effect.SetEffectParam($T2B().Format("allLights[{0}].attenuation", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), $T1B().$Box(light.Attenuation));
      effect.SetEffectParam($T2B().Format("allLights[{0}].ambientCoefficient", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), $T1B().$Box(light.AmbientCoefficient));
      effect.SetEffectParam($T2B().Format("allLights[{0}].coneAngle", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), $T1B().$Box(light.ConeAngle));
      effect.SetEffectParam($T2B().Format("allLights[{0}].coneDirection", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), light.ConeDirectionWorldSpace.MemberwiseClone());
      effect.SetEffectParam($T2B().Format("allLights[{0}].lightType", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), light.Type);
    }
  }; 

  function SceneRenderer_UpdateLightParamsInPixelShader (position, light, effect) {
    var flag = !light.Active;
    if (!flag) {
      effect.SetEffectParam($T2B().Format("allLights[{0}].position", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), light.PositionModelViewSpace.MemberwiseClone());
      effect.SetEffectParam($T2B().Format("allLights[{0}].intensities", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), light.Color.MemberwiseClone());
      effect.SetEffectParam($T2B().Format("allLights[{0}].attenuation", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), $T1B().$Box(light.Attenuation));
      effect.SetEffectParam($T2B().Format("allLights[{0}].ambientCoefficient", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), $T1B().$Box(light.AmbientCoefficient));
      effect.SetEffectParam($T2B().Format("allLights[{0}].coneAngle", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), $T1B().$Box(light.ConeAngle));
      effect.SetEffectParam($T2B().Format("allLights[{0}].coneDirection", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), light.ConeDirectionModelViewSpace.MemberwiseClone());
      effect.SetEffectParam($T2B().Format("allLights[{0}].lightType", JSIL.Array.New($T2C(), [$T2A().$Box(position)])), light.Type);
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm0C.TypeRef("Fusee.Xene.SceneVisitor"), 
      Name: "Fusee.Engine.Core.SceneRenderer", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("Fusee.Serialization.SceneContainer"), $asm04.TypeRef("Fusee.Engine.Core.LightingCalculationMethod"), 
          $.Boolean, $.Boolean
        ]), 
      SceneRenderer__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.SceneContainer")), 
      SceneRenderer__ctor$01
    );

    $.Method({Static:false, Public:true }, "AccumulateLight", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.LightComponent")), 
      SceneRenderer_AccumulateLight
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "Animate", 
      JSIL.MethodSignature.Void, 
      SceneRenderer_Animate
    );

    $.Method({Static:false, Public:false}, "AssembleEffectParamers", 
      new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm04.TypeRef("Fusee.Engine.Core.EffectParameterDeclaration")]), [$asm0A.TypeRef("Fusee.Serialization.MaterialComponent"), $asm04.TypeRef("Fusee.Engine.Core.ShaderCodeBuilder")]), 
      SceneRenderer_AssembleEffectParamers
    );

    $.Method({Static:false, Public:false}, "BuildMaterialFromShaderComponent", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), [$asm0A.TypeRef("Fusee.Serialization.ShaderComponent")]), 
      SceneRenderer_BuildMaterialFromShaderComponent
    );

    $.Method({Static:true , Public:false}, "CreateEffectParameterDeclaration", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.EffectParameterDeclaration"), [$asm0A.TypeRef("Fusee.Serialization.TypeContainer")]), 
      SceneRenderer_CreateEffectParameterDeclaration
    );

    $.Method({Static:true , Public:false}, "CreateEnvMapPassEffect", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      SceneRenderer_CreateEnvMapPassEffect
    );

    $.Method({Static:false, Public:false}, "CreateGBufferDrawPassEffect", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      SceneRenderer_CreateGBufferDrawPassEffect
    );

    $.Method({Static:true , Public:false}, "CreateGBufferPassEffect", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      SceneRenderer_CreateGBufferPassEffect
    );

    $.Method({Static:true , Public:false}, "CreateShadowPassShaderEffect", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      SceneRenderer_CreateShadowPassShaderEffect
    );

    $.Method({Static:false, Public:true }, "get_DoRenderDeferred", 
      JSIL.MethodSignature.Return($.Boolean), 
      SceneRenderer_get_DoRenderDeferred
    );

    $.Method({Static:false, Public:true }, "get_DoRenderEnvMap", 
      JSIL.MethodSignature.Return($.Boolean), 
      SceneRenderer_get_DoRenderEnvMap
    );

    $.Method({Static:false, Public:true }, "get_DoRenderWithShadows", 
      JSIL.MethodSignature.Return($.Boolean), 
      SceneRenderer_get_DoRenderWithShadows
    );

    $.Method({Static:false, Public:true }, "get_ShadowMapSize", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float2")), 
      SceneRenderer_get_ShadowMapSize
    );

    $.Method({Static:false, Public:true }, "InitAnimations", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.SceneContainer")), 
      SceneRenderer_InitAnimations
    );

    $.Method({Static:false, Public:false, Virtual:true }, "InitState", 
      JSIL.MethodSignature.Void, 
      SceneRenderer_InitState
    );

    $.Method({Static:false, Public:false}, "LightsToModelViewSpace", 
      JSIL.MethodSignature.Void, 
      SceneRenderer_LightsToModelViewSpace
    );

    $.Method({Static:false, Public:false}, "LoadTexture", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.ITexture"), [$.String]), 
      SceneRenderer_LoadTexture
    );

    $.Method({Static:false, Public:false}, "LookupMaterial", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), [$asm0A.TypeRef("Fusee.Serialization.MaterialComponent")]), 
      SceneRenderer_LookupMaterial$02
    );

    $.Method({Static:false, Public:false}, "LookupMaterial", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), [$asm0A.TypeRef("Fusee.Serialization.MaterialLightComponent")]), 
      SceneRenderer_LookupMaterial$03
    );

    $.Method({Static:false, Public:false}, "LookupMaterial", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), [$asm0A.TypeRef("Fusee.Serialization.MaterialPBRComponent")]), 
      SceneRenderer_LookupMaterial$04
    );

    $.Method({Static:false, Public:false}, "MakeMaterial", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), [$asm0A.TypeRef("Fusee.Serialization.MaterialComponent")]), 
      SceneRenderer_MakeMaterial
    );

    $.Method({Static:false, Public:true }, "MakeMesh", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.Mesh"), [$asm0A.TypeRef("Fusee.Serialization.MeshComponent")]), 
      SceneRenderer_MakeMesh
    );

    $.Method({Static:true , Public:false}, "MakeShader", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"), [$asm0A.TypeRef("Fusee.Serialization.ShaderComponent")]), 
      SceneRenderer_MakeShader
    );

    $.Method({Static:false, Public:false, Virtual:true }, "PopState", 
      JSIL.MethodSignature.Void, 
      SceneRenderer_PopState
    );

    $.Method({Static:false, Public:false, Virtual:true }, "PushState", 
      JSIL.MethodSignature.Void, 
      SceneRenderer_PushState
    );

    $.Method({Static:false, Public:true }, "Render", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      SceneRenderer_Render
    );

    $.Method({Static:false, Public:true }, "RenderBone", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.BoneComponent")), 
      SceneRenderer_RenderBone
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "RenderCurrentPass", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.Mesh"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]), 
      SceneRenderer_RenderCurrentPass
    );

    $.Method({Static:false, Public:false}, "RenderDeferredLightPass", 
      JSIL.MethodSignature.Void, 
      SceneRenderer_RenderDeferredLightPass
    );

    $.Method({Static:true , Public:false}, "RenderDeferredModelPass", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.Mesh"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]), 
      SceneRenderer_RenderDeferredModelPass
    );

    $.Method({Static:false, Public:false}, "RenderDeferredPasses", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      SceneRenderer_RenderDeferredPasses
    );

    $.Method({Static:false, Public:false}, "RenderEnvMapFirstPass", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.Mesh"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]), 
      SceneRenderer_RenderEnvMapFirstPass
    );

    $.Method({Static:false, Public:false}, "RenderEnvMapPasses", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      SceneRenderer_RenderEnvMapPasses
    );

    $.Method({Static:false, Public:false}, "RenderEnvMapSecondPass", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.Mesh"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]), 
      SceneRenderer_RenderEnvMapSecondPass
    );

    $.Method({Static:false, Public:false}, "RenderFirstShadowPass", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      SceneRenderer_RenderFirstShadowPass
    );

    $.Method({Static:false, Public:true }, "RenderMaterial", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialComponent")), 
      SceneRenderer_RenderMaterial$05
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "RenderMaterial", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialLightComponent")), 
      SceneRenderer_RenderMaterial$06
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "RenderMaterial", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialPBRComponent")), 
      SceneRenderer_RenderMaterial$07
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "RenderMesh", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MeshComponent")), 
      SceneRenderer_RenderMesh
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "RenderRectTransform", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.RectTransformComponent")), 
      SceneRenderer_RenderRectTransform
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:false}, "RenderSecondShadowPass", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.Mesh"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]), 
      SceneRenderer_RenderSecondShadowPass
    );

    $.Method({Static:false, Public:true }, "RenderShader", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.ShaderComponent")), 
      SceneRenderer_RenderShader
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:false}, "RenderStandardPass", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.Mesh"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]), 
      SceneRenderer_RenderStandardPass
    );

    $.Method({Static:false, Public:true }, "RenderTransform", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.TransformComponent")), 
      SceneRenderer_RenderTransform
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "RenderWeight", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.WeightComponent")), 
      SceneRenderer_RenderWeight
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:false}, "RenderWithShadow", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      SceneRenderer_RenderWithShadow
    );

    $.Method({Static:false, Public:false}, "set_DoRenderDeferred", 
      JSIL.MethodSignature.Action($.Boolean), 
      SceneRenderer_set_DoRenderDeferred
    );

    $.Method({Static:false, Public:false}, "set_DoRenderEnvMap", 
      JSIL.MethodSignature.Action($.Boolean), 
      SceneRenderer_set_DoRenderEnvMap
    );

    $.Method({Static:false, Public:false}, "set_DoRenderWithShadows", 
      JSIL.MethodSignature.Action($.Boolean), 
      SceneRenderer_set_DoRenderWithShadows
    );

    $.Method({Static:false, Public:true }, "set_ShadowMapSize", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float2")), 
      SceneRenderer_set_ShadowMapSize
    );

    $.Method({Static:false, Public:true }, "SetContext", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      SceneRenderer_SetContext
    );

    $.Method({Static:true , Public:false}, "SetLightEffectParameters", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$asm0E.TypeRef("System.Collections.Generic.List`1", [$asm04.TypeRef("Fusee.Engine.Core.EffectParameterDeclaration")])])), 
      SceneRenderer_SetLightEffectParameters
    );

    $.Method({Static:false, Public:false}, "UpdateEffectParameters", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("Fusee.Serialization.MaterialComponent"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]), 
      SceneRenderer_UpdateEffectParameters
    );

    $.Method({Static:true , Public:false}, "UpdateGBufferDrawPassLights", 
      new JSIL.MethodSignature(null, [
          $.Int32, $asm04.TypeRef("Fusee.Engine.Core.LightResult"), 
          $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")
        ]), 
      SceneRenderer_UpdateGBufferDrawPassLights
    );

    $.Method({Static:true , Public:false}, "UpdateLightParamsInPixelShader", 
      new JSIL.MethodSignature(null, [
          $.Int32, $asm04.TypeRef("Fusee.Engine.Core.LightResult"), 
          $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")
        ]), 
      SceneRenderer_UpdateLightParamsInPixelShader
    );

    $.Field({Static:true , Public:true }, "LightingCalculationMethod", $asm04.TypeRef("Fusee.Engine.Core.LightingCalculationMethod"));

    $.Field({Static:true , Public:true }, "AllLightResults", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0A.TypeRef("Fusee.Serialization.LightComponent"), $asm04.TypeRef("Fusee.Engine.Core.LightResult")]));

    $.Field({Static:false, Public:false}, "_renderWithShadows", $.Boolean);

    $.Field({Static:false, Public:false}, "_renderDeferred", $.Boolean);

    $.Field({Static:false, Public:false}, "_renderEnvMap", $.Boolean);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_wantToRenderWithShadows", $.Boolean);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_wantToRenderDeferred", $.Boolean);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_wantToRenderEnvMap", $.Boolean);

    $.Field({Static:false, Public:false}, "SceneRenderer$ShadowMapSize$value", $asm09.TypeRef("Fusee.Math.Core.float2"));

    $.Field({Static:false, Public:false}, "_meshMap", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0A.TypeRef("Fusee.Serialization.MeshComponent"), $asm04.TypeRef("Fusee.Engine.Core.Mesh")]));

    $.Field({Static:false, Public:false}, "_matMap", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0A.TypeRef("Fusee.Serialization.MaterialComponent"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]));

    $.Field({Static:false, Public:false}, "_lightMatMap", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0A.TypeRef("Fusee.Serialization.MaterialLightComponent"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]));

    $.Field({Static:false, Public:false}, "_pbrComponent", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0A.TypeRef("Fusee.Serialization.MaterialPBRComponent"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]));

    $.Field({Static:false, Public:false}, "_boneMap", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0A.TypeRef("Fusee.Serialization.SceneNodeContainer"), $asm09.TypeRef("Fusee.Math.Core.float4x4")]));

    $.Field({Static:false, Public:false}, "_shaderEffectMap", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0A.TypeRef("Fusee.Serialization.ShaderComponent"), $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]));

    $.Field({Static:false, Public:false}, "_animation", $asm0D.TypeRef("Fusee.Xirkit.Animation"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_sc", $asm0A.TypeRef("Fusee.Serialization.SceneContainer"));

    $.Field({Static:false, Public:false}, "_rc", $asm04.TypeRef("Fusee.Engine.Core.RenderContext"));

    $.Field({Static:false, Public:false}, "_lightComponents", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0A.TypeRef("Fusee.Serialization.LightComponent"), $asm04.TypeRef("Fusee.Engine.Core.LightResult")]));

    $.Field({Static:false, Public:false}, "_scenePathDirectory", $.String);

    $.Field({Static:false, Public:false}, "_defaultEffect", $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"));

    $.Field({Static:false, Public:false}, "_state", $asm04.TypeRef("Fusee.Engine.Core.SceneRenderer+RendererState"));

    $.Field({Static:false, Public:false}, "_view", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_rcViewportOriginalSize", $asm09.TypeRef("Fusee.Math.Core.float2"));


    function SceneRenderer__cctor () {
      $thisType.AllLightResults = $S00().Construct();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      SceneRenderer__cctor
    );

    $.Property({Static:false, Public:true }, "ShadowMapSize", $asm09.TypeRef("Fusee.Math.Core.float2"));

    $.Property({Static:false, Public:true }, "DoRenderWithShadows", $.Boolean);

    $.Property({Static:false, Public:true }, "DoRenderDeferred", $.Boolean);

    $.Property({Static:false, Public:true }, "DoRenderEnvMap", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.SceneRenderer+RendererState */ 

(function RendererState$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0C.Fusee.Xene.CollapsingStateStack$b1.Of($asm09.Fusee.Math.Core.float4x4))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0C.Fusee.Xene.CollapsingStateStack$b1.Of($asm09.Fusee.Math.Core.MinMaxRect))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0C.Fusee.Xene.StateStack$b1.Of($asm04.Fusee.Engine.Core.ShaderEffect))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0C.Fusee.Xene.VisitorState)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderEffect)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm09.Fusee.Math.Core.MinMaxRect)) ();
  };


  function RendererState__ctor () {
    this._model = new ($T00())(4);
    this._uiRect = new ($T01())(4);
    this._effect = new ($T02())(8);
    $T03().prototype._ctor.call(this);
    this.RegisterState(this._model);
    this.RegisterState(this._effect);
    this.RegisterState(this._uiRect);
  }; 

  function RendererState_get_Effect () {
    return (this._effect).get_Tos();
  }; 

  function RendererState_get_Model () {
    return (this._model).get_Tos();
  }; 

  function RendererState_get_UiRect () {
    return (this._uiRect).get_Tos();
  }; 

  function RendererState_set_Effect (value) {
    (this._effect).set_Tos(value);
  }; 

  function RendererState_set_Model (value) {
    (this._model).set_Tos(value.MemberwiseClone());
  }; 

  function RendererState_set_UiRect (value) {
    (this._uiRect).set_Tos(value.MemberwiseClone());
  }; 

  JSIL.MakeType({
      BaseType: $asm0C.TypeRef("Fusee.Xene.VisitorState"), 
      Name: "Fusee.Engine.Core.SceneRenderer+RendererState", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      RendererState__ctor
    );

    $.Method({Static:false, Public:true }, "get_Effect", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")), 
      RendererState_get_Effect
    );

    $.Method({Static:false, Public:true }, "get_Model", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RendererState_get_Model
    );

    $.Method({Static:false, Public:true }, "get_UiRect", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.MinMaxRect")), 
      RendererState_get_UiRect
    );

    $.Method({Static:false, Public:true }, "set_Effect", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")), 
      RendererState_set_Effect
    );

    $.Method({Static:false, Public:true }, "set_Model", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RendererState_set_Model
    );

    $.Method({Static:false, Public:true }, "set_UiRect", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.MinMaxRect")), 
      RendererState_set_UiRect
    );

    $.Field({Static:false, Public:false}, "_model", $asm0C.TypeRef("Fusee.Xene.CollapsingStateStack`1", [$asm09.TypeRef("Fusee.Math.Core.float4x4")]));

    $.Field({Static:false, Public:false}, "_uiRect", $asm0C.TypeRef("Fusee.Xene.CollapsingStateStack`1", [$asm09.TypeRef("Fusee.Math.Core.MinMaxRect")]));

    $.Field({Static:false, Public:false}, "_effect", $asm0C.TypeRef("Fusee.Xene.StateStack`1", [$asm04.TypeRef("Fusee.Engine.Core.ShaderEffect")]));

    $.Property({Static:false, Public:true }, "Model", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "UiRect", $asm09.TypeRef("Fusee.Math.Core.MinMaxRect"));

    $.Property({Static:false, Public:true }, "Effect", $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.SceneRenderer+<>c */ 

(function $l$gc$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.Fusee.Serialization.AnimationComponent)) ();
  };


  function $l$gc__ctor () {
  }; 

  function $l$gc_$lInitAnimations$gb__38_0 (c) {
    return true;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.SceneRenderer+<>c", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__ctor
    );

    $.Method({Static:false, Public:false}, "$lInitAnimations$gb__38_0", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("Fusee.Serialization.AnimationComponent")]), 
      $l$gc_$lInitAnimations$gb__38_0
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "$l$g9", $.Type);

    $.Field({Static:true , Public:true }, "$l$g9__38_0", $asm0E.TypeRef("System.Predicate`1", [$asm0A.TypeRef("Fusee.Serialization.AnimationComponent")]));


    function $l$gc__cctor () {
      $thisType.$l$g9 = new $thisType();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__cctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Engine.Core.LightResult */ 

(function LightResult$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.ValueType"), 
      Name: "Fusee.Engine.Core.LightResult", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "Active", $.Boolean);

    $.Field({Static:false, Public:true }, "Position", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "Color", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "Attenuation", $.Single);

    $.Field({Static:false, Public:true }, "AmbientCoefficient", $.Single);

    $.Field({Static:false, Public:true }, "Type", $asm0A.TypeRef("Fusee.Serialization.LightType"));

    $.Field({Static:false, Public:true }, "ConeAngle", $.Single);

    $.Field({Static:false, Public:true }, "ConeDirection", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "ModelMatrix", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:true }, "PositionWorldSpace", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "ConeDirectionWorldSpace", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "PositionModelViewSpace", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "ConeDirectionModelViewSpace", $asm09.TypeRef("Fusee.Math.Core.float3"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.LightSetupState */ 

(function LightSetupState$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0C.Fusee.Xene.CollapsingStateStack$b1.Of($asm09.Fusee.Math.Core.float4x4))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0C.Fusee.Xene.VisitorState)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };


  function LightSetupState__ctor () {
    this._model = new ($T00())(4);
    $T01().prototype._ctor.call(this);
    this.RegisterState(this._model);
  }; 

  function LightSetupState_get_Model () {
    return (this._model).get_Tos();
  }; 

  function LightSetupState_set_Model (value) {
    (this._model).set_Tos(value.MemberwiseClone());
  }; 

  JSIL.MakeType({
      BaseType: $asm0C.TypeRef("Fusee.Xene.VisitorState"), 
      Name: "Fusee.Engine.Core.LightSetupState", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      LightSetupState__ctor
    );

    $.Method({Static:false, Public:true }, "get_Model", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      LightSetupState_get_Model
    );

    $.Method({Static:false, Public:true }, "set_Model", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      LightSetupState_set_Model
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_model", $asm0C.TypeRef("Fusee.Xene.CollapsingStateStack`1", [$asm09.TypeRef("Fusee.Math.Core.float4x4")]));

    $.Property({Static:false, Public:true }, "Model", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.LightSetup */ 

(function LightSetup$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0C.Fusee.Xene.Viserator$b2.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult), $asm04.Fusee.Engine.Core.LightSetupState))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.LightSetupState)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.Fusee.Serialization.LightComponent)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.LightResult)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0C.Fusee.Xene.ViseratorBase$b1.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult)))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.Fusee.Serialization.TransformComponent)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0C.Fusee.Xene.ContainerExtensions)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float3, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float3]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };


  function LightSetup__ctor () {
    this.FoundLightResults = $S00().Construct();
    $T01().prototype._ctor.call(this);
  }; 

  function LightSetup_InitState () {
    $T01().prototype.InitState.call(this);
    (this.State.Model = $T03().Identity.MemberwiseClone());
  }; 

  function LightSetup_OnLight (lightComponent) {
    var lightResult2 = new ($T05())();
    lightResult2.Type = lightComponent.Type;
    lightResult2.Color = lightComponent.Color.MemberwiseClone();
    lightResult2.ConeAngle = +lightComponent.ConeAngle;
    lightResult2.ConeDirection = lightComponent.ConeDirection.MemberwiseClone();
    lightResult2.AmbientCoefficient = +lightComponent.AmbientCoefficient;
    lightResult2.ModelMatrix = (this.State).get_Model().MemberwiseClone();
    lightResult2.Position = lightComponent.Position.MemberwiseClone();
    lightResult2.PositionWorldSpace = $S01().CallStatic($T03(), "op_Multiply", null, (this.State).get_Model(), lightComponent.Position);
    lightResult2.ConeDirectionWorldSpace = $S01().CallStatic($T03(), "op_Multiply", null, (this.State).get_Model(), lightComponent.ConeDirection);
    lightResult2.Active = lightComponent.Active;
    lightResult2.Attenuation = +lightComponent.Attenuation;
    var lightResult = lightResult2;
    $T06().prototype.YieldItem.call(this, new ($T07())(lightComponent, lightResult.MemberwiseClone()));
  }; 

  function LightSetup_OnTransform (xform) {
    this.State.Model = $S02().CallStatic($T03(), "op_Multiply", null, this.State.Model.MemberwiseClone(), $T09().Matrix(xform).MemberwiseClone()).MemberwiseClone();
  }; 

  JSIL.MakeType({
      BaseType: $asm0C.TypeRef("Fusee.Xene.Viserator`2", [$asm0E.TypeRef("System.Collections.Generic.KeyValuePair`2", [$asm0A.TypeRef("Fusee.Serialization.LightComponent"), $asm04.TypeRef("Fusee.Engine.Core.LightResult")]), $asm04.TypeRef("Fusee.Engine.Core.LightSetupState")]), 
      Name: "Fusee.Engine.Core.LightSetup", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      LightSetup__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "InitState", 
      JSIL.MethodSignature.Void, 
      LightSetup_InitState
    );

    $.Method({Static:false, Public:true }, "OnLight", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.LightComponent")), 
      LightSetup_OnLight
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Method({Static:false, Public:true }, "OnTransform", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.TransformComponent")), 
      LightSetup_OnTransform
    )
      .Attribute($asm0C.TypeRef("Fusee.Xene.VisitMethodAttribute"));

    $.Field({Static:false, Public:true }, "FoundLightResults", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0A.TypeRef("Fusee.Serialization.LightComponent"), $asm04.TypeRef("Fusee.Engine.Core.LightResult")]));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ScreenConfig */ 

(function ScreenConfig$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Int32)) ();
  };


  function ScreenConfig__ctor () {
    (this.ScreenConfig$Transform$value = $T00().Identity.MemberwiseClone());
    this.ScreenConfig$ScaleDepth$value = 1;
    this.ScreenConfig$ScaleSize$value = 1;
    this.ScreenConfig$Hit$value = 0;
  }; 

  function ScreenConfig_get_Hit () {
    return this.ScreenConfig$Hit$value;
  }; 

  function ScreenConfig_get_ScaleDepth () {
    return this.ScreenConfig$ScaleDepth$value;
  }; 

  function ScreenConfig_get_ScaleSize () {
    return this.ScreenConfig$ScaleSize$value;
  }; 

  function ScreenConfig_get_Transform () {
    return this.ScreenConfig$Transform$value;
  }; 

  function ScreenConfig_set_Hit (value) {
    this.ScreenConfig$Hit$value = +value;
  }; 

  function ScreenConfig_set_ScaleDepth (value) {
    this.ScreenConfig$ScaleDepth$value = +value;
  }; 

  function ScreenConfig_set_ScaleSize (value) {
    this.ScreenConfig$ScaleSize$value = (value | 0);
  }; 

  function ScreenConfig_set_Transform (value) {
    this.ScreenConfig$Transform$value = value.MemberwiseClone();
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.ScreenConfig", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ScreenConfig__ctor
    );

    $.Method({Static:false, Public:true }, "get_Hit", 
      JSIL.MethodSignature.Return($.Single), 
      ScreenConfig_get_Hit
    );

    $.Method({Static:false, Public:true }, "get_ScaleDepth", 
      JSIL.MethodSignature.Return($.Single), 
      ScreenConfig_get_ScaleDepth
    );

    $.Method({Static:false, Public:true }, "get_ScaleSize", 
      JSIL.MethodSignature.Return($.Int32), 
      ScreenConfig_get_ScaleSize
    );

    $.Method({Static:false, Public:true }, "get_Transform", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      ScreenConfig_get_Transform
    );

    $.Method({Static:false, Public:true }, "set_Hit", 
      JSIL.MethodSignature.Action($.Single), 
      ScreenConfig_set_Hit
    );

    $.Method({Static:false, Public:true }, "set_ScaleDepth", 
      JSIL.MethodSignature.Action($.Single), 
      ScreenConfig_set_ScaleDepth
    );

    $.Method({Static:false, Public:true }, "set_ScaleSize", 
      JSIL.MethodSignature.Action($.Int32), 
      ScreenConfig_set_ScaleSize
    );

    $.Method({Static:false, Public:true }, "set_Transform", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      ScreenConfig_set_Transform
    );

    $.Field({Static:false, Public:false}, "ScreenConfig$Transform$value", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "ScreenConfig$ScaleDepth$value", $.Single);

    $.Field({Static:false, Public:false}, "ScreenConfig$ScaleSize$value", $.Int32);

    $.Field({Static:false, Public:false}, "ScreenConfig$Hit$value", $.Single);

    $.Property({Static:false, Public:true }, "Transform", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "ScaleDepth", $.Single);

    $.Property({Static:false, Public:true }, "ScaleSize", $.Int32);

    $.Property({Static:false, Public:true }, "Hit", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Engine.Core.ScreenS3DTextures */ 

(function ScreenS3DTextures$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.ValueType"), 
      Name: "Fusee.Engine.Core.ScreenS3DTextures", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "Left", $asm03.TypeRef("Fusee.Engine.Common.ITexture"));

    $.Field({Static:false, Public:true }, "LeftDepth", $asm03.TypeRef("Fusee.Engine.Common.ITexture"));

    $.Field({Static:false, Public:true }, "Right", $asm03.TypeRef("Fusee.Engine.Common.ITexture"));

    $.Field({Static:false, Public:true }, "RightDepth", $asm03.TypeRef("Fusee.Engine.Common.ITexture"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ScreenS3D */ 

(function ScreenS3D$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.ScreenS3DTextures)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.ScreenConfig)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt16))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.UInt16)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderProgram)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Engine.Core.StereoCameraRig)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm03.Fusee.Engine.Common.ITexture)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm04.Fusee.Engine.Core.Stereo3DEye)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm04.Fusee.Engine.Core.Stereo3D)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float3, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm0E.System.Single]))) ();
  };


  function ScreenS3D__ctor (rc, textures) {
    this._rc = rc;
    this._screenMesh = this.CreatePlaneMesh();
    this.TexturesLR_DLR = textures.MemberwiseClone();
    this.InitializeShader();
    this.ScreenS3D$Config$value = new ($T02())();
  }; 

  function ScreenS3D_CreatePlaneMesh () {
    var mesh = new ($T03())();
    var expr_0D = JSIL.Array.New($T05(), 4);
    var float = new ($T05())();
    float.x = 0.5;
    float.y = -0.5;
    float.z = 0.5;
    expr_0D[0] = float.MemberwiseClone();
    float = new ($T05())();
    float.x = 0.5;
    float.y = 0.5;
    float.z = 0.5;
    expr_0D[1] = float.MemberwiseClone();
    float = new ($T05())();
    float.x = -0.5;
    float.y = 0.5;
    float.z = 0.5;
    expr_0D[2] = float.MemberwiseClone();
    float = new ($T05())();
    float.x = -0.5;
    float.y = -0.5;
    float.z = 0.5;
    expr_0D[3] = float.MemberwiseClone();
    var triangles = JSIL.Array.New($T07(), [1, 2, 0, 2, 3, 0]);
    var normals = JSIL.Array.New($T05(), [$S00().Construct(0, 0, -1), $S00().Construct(0, 0, -1), $S00().Construct(0, 0, -1), $S00().Construct(0, 0, -1)]);
    var uVs = JSIL.Array.New($T09(), [$S01().Construct(0, 0), $S01().Construct(0, 1), $S01().Construct(1, 1), $S01().Construct(1, 0)]);
    mesh.set_Vertices(expr_0D);
    mesh.set_Triangles(triangles);
    mesh.set_Normals(normals);
    mesh.set_UVs(uVs);
    return mesh;
  }; 

  function ScreenS3D_get_Config () {
    return this.ScreenS3D$Config$value;
  }; 

  function ScreenS3D_InitializeShader () {
    this._stereo3DShaderProgram = (this._rc).CreateShader("\r\n            attribute vec4 fuColor;\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;        \r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec4 FuVertex;\r\n\r\n            uniform mat4 FUSEE_MV;\r\n            uniform mat4 FUSEE_P;\r\n            uniform mat4 FUSEE_ITMV;\r\n            uniform mat4 FUSEE_MVP;\r\n            uniform mat4 FUSEE_IMV;\r\n\r\n            void main()\r\n            {               \r\n               \r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);                \r\n                \r\n                FuVertex = vec4(fuVertex, 1.0);              \r\n                \r\n                vNormal = mat3(FUSEE_ITMV[0].xyz, FUSEE_ITMV[1].xyz, FUSEE_ITMV[2].xyz) * fuNormal;\r\n                vUV = fuUV;\r\n            }", "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n           \r\n            //SahderParams\r\n            uniform sampler2D vTexture;\r\n            uniform sampler2D textureDepth;\r\n            uniform float scale;\r\n            uniform int invert;\r\n            uniform mat4 FUSEE_MV;\r\n            uniform mat4 FUSEE_P;\r\n            uniform mat4 FUSEE_MVP;\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec4 FuVertex;\r\n            float coordZ;\r\n         \r\n            void main()\r\n            {\r\n                //Read Texture Value (RGB)\r\n                vec4 colTex = texture(vTexture, vUV);    \r\n                //Read Texture Value (Grey/Depth)                  \r\n                float depthTexValue = texture(textureDepth, vUV);\r\n                if(invert == 1)\r\n                {\r\n                    depthTexValue = 1- depthTexValue;\r\n                }   \r\n                //homogenous vertex coordinates               \r\n                vec4 vertex = FuVertex;             \r\n    \r\n                if(depthTexValue >0.9)          \r\n                {                \r\n                    discard;\r\n                }\r\n                else\r\n                {          \r\n                    //Add offest from 'textureDepth' with scaling value;               \r\n                    vertex.z += ((depthTexValue*2)-1)*scale;\r\n                    //trnasform to ClipSpace \r\n                    vec4 clip = FUSEE_P*FUSEE_MV*vertex;                     \r\n                    //Noramlized Device Coordinates   \r\n                    float ndcDepth = (clip.z/clip.w);                    \r\n                    //Viewport transformation\r\n                    coordZ  = (gl_DepthRange.diff)*0.5*ndcDepth+(gl_DepthRange.diff)*0.5; \r\n                    //Fragment Depth Value\r\n\r\n                    gl_FragDepth =  coordZ;              \r\n                }\r\n                //write color \r\n                gl_FragColor = colTex /** dot(vNormal, vec3(0, 0, -1))*/;                            \r\n            }");
    this._colorTextureShaderParam = (this._stereo3DShaderProgram).GetShaderParam("vTexture");
    this._depthTextureShaderParam = (this._stereo3DShaderProgram).GetShaderParam("textureDepth");
    this._depthShaderParamScale = (this._stereo3DShaderProgram).GetShaderParam("scale");
    this._invertDepthShaderParam = (this._stereo3DShaderProgram).GetShaderParam("invert");
  }; 

  function ScreenS3D_Render (cameraRig, mtx) {
    var hit = 0;
    var textureColor = null;
    var textureDepth = null;
    var currentEye = cameraRig.get_CurrentEye();
    if ((currentEye.valueOf() | 0) !== 0) {
      if (currentEye === $T0F().Right) {
        textureColor = this.TexturesLR_DLR.Right;
        textureDepth = this.TexturesLR_DLR.RightDepth;
        hit = +(
          (+this.ScreenS3D$Config$value.ScreenConfig$Hit$value === 0)
             ? 0
             : +((+this.ScreenS3D$Config$value.ScreenConfig$Hit$value / 2)))
        ;
      }
    } else {
      textureColor = this.TexturesLR_DLR.Left;
      textureDepth = this.TexturesLR_DLR.LeftDepth;
      hit = +(
        (+this.ScreenS3D$Config$value.ScreenConfig$Hit$value === 0)
           ? 0
           : +((-this.ScreenS3D$Config$value.ScreenConfig$Hit$value / 2)))
      ;
    }
    var flag = (textureColor !== null) && 
    (textureDepth !== null);
    if (flag) {
      (this._rc).SetShader(this._stereo3DShaderProgram);
      (this._rc).SetShaderParamTexture(this._colorTextureShaderParam, textureColor);
      (this._rc).SetShaderParamTexture(this._depthTextureShaderParam, textureDepth);
      (this._rc).SetShaderParam1f(this._depthShaderParamScale, this.ScreenS3D$Config$value.ScreenConfig$ScaleDepth$value);
      (this._rc).SetShaderParamI(this._invertDepthShaderParam, 1);
      var mv = $S02().CallStatic($T0C(), "op_Multiply", null, 
        $S02().CallStatic($T0C(), "op_Multiply", null, 
          $S02().CallStatic($T0C(), "op_Multiply", null, 
            $S02().CallStatic($T0C(), "op_Multiply", null, mtx.MemberwiseClone(), this.ScreenS3D$Config$value.ScreenConfig$Transform$value.MemberwiseClone()).MemberwiseClone(), 
            $T0C().CreateTranslation(hit, 0, 0).MemberwiseClone()
          ).MemberwiseClone(), 
          $S03().CallStatic($T0C(), "CreateScale", null, +(this.ScreenS3D$Config$value.ScreenConfig$ScaleSize$value)).MemberwiseClone()
        ).MemberwiseClone(), 
        $T0C().CreateRotationY(-0.7853982).MemberwiseClone()
      ).MemberwiseClone();
      (this._rc.ModelView = mv.MemberwiseClone());
      (this._rc).Render(this._screenMesh);
    }
  }; 

  function ScreenS3D_set_Config (value) {
    this.ScreenS3D$Config$value = value;
  }; 

  function ScreenS3D_SetHit (offset) {
    var $temp00;
    ($temp00 = +this.ScreenS3D$Config$value.ScreenConfig$Hit$value + +offset, 
      this.ScreenS3D$Config$value.ScreenConfig$Hit$value = $temp00, 
      $temp00);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.ScreenS3D", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.RenderContext"), $asm04.TypeRef("Fusee.Engine.Core.ScreenS3DTextures")]), 
      ScreenS3D__ctor
    );

    $.Method({Static:false, Public:false}, "CreatePlaneMesh", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      ScreenS3D_CreatePlaneMesh
    );

    $.Method({Static:false, Public:true }, "get_Config", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.ScreenConfig")), 
      ScreenS3D_get_Config
    );

    $.Method({Static:false, Public:false}, "InitializeShader", 
      JSIL.MethodSignature.Void, 
      ScreenS3D_InitializeShader
    );

    $.Method({Static:false, Public:true }, "Render", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.StereoCameraRig"), $asm09.TypeRef("Fusee.Math.Core.float4x4")]), 
      ScreenS3D_Render
    );

    $.Method({Static:false, Public:false}, "set_Config", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.ScreenConfig")), 
      ScreenS3D_set_Config
    );

    $.Method({Static:false, Public:true }, "SetHit", 
      JSIL.MethodSignature.Action($.Single), 
      ScreenS3D_SetHit
    );

    $.Constant({Static:true , Public:false}, "VsS3dDepth", $.String, "\r\n            attribute vec4 fuColor;\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;        \r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec4 FuVertex;\r\n\r\n            uniform mat4 FUSEE_MV;\r\n            uniform mat4 FUSEE_P;\r\n            uniform mat4 FUSEE_ITMV;\r\n            uniform mat4 FUSEE_MVP;\r\n            uniform mat4 FUSEE_IMV;\r\n\r\n            void main()\r\n            {               \r\n               \r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);                \r\n                \r\n                FuVertex = vec4(fuVertex, 1.0);              \r\n                \r\n                vNormal = mat3(FUSEE_ITMV[0].xyz, FUSEE_ITMV[1].xyz, FUSEE_ITMV[2].xyz) * fuNormal;\r\n                vUV = fuUV;\r\n            }");

    $.Constant({Static:true , Public:false}, "PsS3dDepth", $.String, "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n           \r\n            //SahderParams\r\n            uniform sampler2D vTexture;\r\n            uniform sampler2D textureDepth;\r\n            uniform float scale;\r\n            uniform int invert;\r\n            uniform mat4 FUSEE_MV;\r\n            uniform mat4 FUSEE_P;\r\n            uniform mat4 FUSEE_MVP;\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec4 FuVertex;\r\n            float coordZ;\r\n         \r\n            void main()\r\n            {\r\n                //Read Texture Value (RGB)\r\n                vec4 colTex = texture(vTexture, vUV);    \r\n                //Read Texture Value (Grey/Depth)                  \r\n                float depthTexValue = texture(textureDepth, vUV);\r\n                if(invert == 1)\r\n                {\r\n                    depthTexValue = 1- depthTexValue;\r\n                }   \r\n                //homogenous vertex coordinates               \r\n                vec4 vertex = FuVertex;             \r\n    \r\n                if(depthTexValue >0.9)          \r\n                {                \r\n                    discard;\r\n                }\r\n                else\r\n                {          \r\n                    //Add offest from 'textureDepth' with scaling value;               \r\n                    vertex.z += ((depthTexValue*2)-1)*scale;\r\n                    //trnasform to ClipSpace \r\n                    vec4 clip = FUSEE_P*FUSEE_MV*vertex;                     \r\n                    //Noramlized Device Coordinates   \r\n                    float ndcDepth = (clip.z/clip.w);                    \r\n                    //Viewport transformation\r\n                    coordZ  = (gl_DepthRange.diff)*0.5*ndcDepth+(gl_DepthRange.diff)*0.5; \r\n                    //Fragment Depth Value\r\n\r\n                    gl_FragDepth =  coordZ;              \r\n                }\r\n                //write color \r\n                gl_FragColor = colTex /** dot(vNormal, vec3(0, 0, -1))*/;                            \r\n            }");

    $.Field({Static:false, Public:false}, "_rc", $asm04.TypeRef("Fusee.Engine.Core.RenderContext"));

    $.Field({Static:false, Public:false}, "_screenMesh", $asm04.TypeRef("Fusee.Engine.Core.Mesh"));

    $.Field({Static:false, Public:false}, "ScreenS3D$Config$value", $asm04.TypeRef("Fusee.Engine.Core.ScreenConfig"));

    $.Field({Static:false, Public:true }, "TexturesLR_DLR", $asm04.TypeRef("Fusee.Engine.Core.ScreenS3DTextures"));

    $.Field({Static:false, Public:false}, "_stereo3DShaderProgram", $asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"));

    $.Field({Static:false, Public:false}, "_colorTextureShaderParam", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false}, "_depthTextureShaderParam", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false}, "_depthShaderParamScale", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false}, "_invertDepthShaderParam", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Property({Static:false, Public:true }, "Config", $asm04.TypeRef("Fusee.Engine.Core.ScreenConfig"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.LegacyShaderCodeBuilder */ 

(function LegacyShaderCodeBuilder$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.LightResult))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.Fusee.Serialization.MaterialPBRComponent)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.Fusee.Serialization.MeshComponent)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.Fusee.Serialization.WeightComponent)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.LightingCalculationMethod)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0A.Fusee.Serialization.SceneNodeContainer))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Text.StringBuilder)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.Fusee.Serialization.MaterialLightComponent)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.Fusee.Serialization.MaterialComponent)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.ArgumentException)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.Globalization.CultureInfo)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.ArgumentOutOfRangeException)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0A.Fusee.Serialization.LightComponent, $asm04.Fusee.Engine.Core.LightResult))) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm04.Fusee.Engine.Core.SceneRenderer)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.LightResult), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialPBRComponent")))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Text.StringBuilder, null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialLightComponent")))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialComponent")))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentException, [$asm0E.System.String]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Text.StringBuilder, [$asm0E.System.String]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Text.StringBuilder, [$asm0E.System.String, System.Array.Of($asm0E.System.Object)]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentOutOfRangeException, [$asm0E.System.String]))) ();
  };


  function LegacyShaderCodeBuilder__ctor$00 (pbrMaterialPbrComponent, mesh, wc) {
    this._lightingCalculationMethod = $T04().SIMPLE;
    if (wc !== null) {
      this._hasWeightMap = true;
      this._nBones = ((wc.Joints).get_Count() | 0);
    } else {
      this._nBones = 0;
    }
    this._normalizeNormals = true;
    if (mesh !== null) {
      this.AnalyzeMesh(mesh);
    } else {
      this._hasVertices = this._hasNormals = this._hasUVs = true;
    }
    $S01().CallVirtual("AnalyzeMaterial", null, this, pbrMaterialPbrComponent);
    var vs = $S02().Construct();
    this.MeshInputDeclarations(vs);
    this.MatrixDeclarations(vs);
    this.VSBody(vs);
    this._vs = vs.toString();
    var ps = $S02().Construct();
    this.PixelInputDeclarations(ps);
    this.PSPBRBody(ps, pbrMaterialPbrComponent);
    this._ps = ps.toString();
  }; 

  function LegacyShaderCodeBuilder__ctor$01 (mlc, mesh, wc) {
    this._lightingCalculationMethod = $T04().SIMPLE;
    if (wc !== null) {
      this._hasWeightMap = true;
      this._nBones = ((wc.Joints).get_Count() | 0);
    } else {
      this._nBones = 0;
    }
    this._normalizeNormals = true;
    if (mesh !== null) {
      this.AnalyzeMesh(mesh);
    } else {
      this._hasVertices = this._hasNormals = this._hasUVs = true;
    }
    $S03().CallVirtual("AnalyzeMaterial", null, this, mlc);
    var vs = $S02().Construct();
    this.MeshInputDeclarations(vs);
    this.MatrixDeclarations(vs);
    this.VSBody(vs);
    this._vs = vs.toString();
    var ps = $S02().Construct();
    this.PixelInputDeclarations(ps);
    this.PSCustomBody(ps, mlc);
    this._ps = ps.toString();
  }; 

  function LegacyShaderCodeBuilder__ctor$02 (mc, mesh, wc) {
    this._lightingCalculationMethod = $T04().SIMPLE;
    if (wc !== null) {
      this._hasWeightMap = true;
      this._nBones = ((wc.Joints).get_Count() | 0);
    } else {
      this._nBones = 0;
    }
    this._normalizeNormals = true;
    if (mesh !== null) {
      this.AnalyzeMesh(mesh);
    } else {
      this._hasVertices = this._hasNormals = this._hasUVs = true;
    }
    $S04().CallVirtual("AnalyzeMaterial", null, this, mc);
    var vs = $S02().Construct();
    this.MeshInputDeclarations(vs);
    this.MatrixDeclarations(vs);
    this.VSBody(vs);
    this._vs = vs.toString();
    var ps = $S02().Construct();
    this.PixelInputDeclarations(ps);
    this.PSBody(ps);
    this._ps = ps.toString();
  }; 

  function LegacyShaderCodeBuilder_AddApplyLightCalculation (ps, mlc) {
    if (this._hasApplyLightString) {
      var flag2 = !$thisType.CheckApplyLightStringForErrors(mlc.ApplyLightString);
      if (flag2) {
        throw $S05().Construct(JSIL.ConcatString($T0C().Format("Error while compiling ApplyLight(). Are you sure this:\n {0} \nis correct?", JSIL.Array.New($T07(), [mlc.ApplyLightString])), "\nPerhaps (re)consult the documentation of MaterialLightComponent class."));
      }
      $S06().CallVirtual("Append", null, ps, JSIL.ConcatString("\n\n", mlc.ApplyLightString));
    }
  }; 

  function LegacyShaderCodeBuilder_AddBlinnphongLightning (ps) {
    this.AddNormalVec(ps);
    this.AddCameraVec(ps);
    this.AddLightVec(ps);
    var hasEmissive = this._hasEmissive;
    if (hasEmissive) {
      $S06().CallVirtual("Append", null, ps, "\n\n    //*********** Emissive *********\n");
      this.AddChannelBaseColorCalculation(ps, this._hasEmissiveTexture, "Emissive");
    }
    $S06().CallVirtual("Append", null, ps, "\n\n    //*********** DIFFUSE *********\n");
    this.AddChannelBaseColorCalculation(ps, this._hasDiffuseTexture, "Diffuse");
    $S06().CallVirtual("Append", null, ps, "\n\n    //*********** Specular *********\n");
    this.AddChannelBaseColorCalculation(ps, this._hasSpecularTexture, "Specular");
    $S06().CallVirtual("Append", null, ps, "\n\n   varying vec4 surfacePos; \n");
    $S06().CallVirtual("Append", null, ps, "vec3 ApplyLight(Light light) { \n\n");
    $S06().CallVirtual("Append", null, ps, "// switch type: 0 = Point; 1 = Parallel; 2 = Spot;\n");
    $S06().CallVirtual("Append", null, ps, "////// POINTLIGHT \n\n");
    $S06().CallVirtual("Append", null, ps, "if(light.lightType == 0) { \n\n");
    $S06().CallVirtual("Append", null, ps, "vec3 result = vec3(0, 0, 0); \n\n");
    $S06().CallVirtual("Append", null, ps, "vec3 DiffuseBaseColor = DiffuseColor; \n\n");
    $S06().CallVirtual("Append", null, ps, "float diffFactor = dot(LDir, Normal); \n\n");
    $S06().CallVirtual("Append", null, ps, "  result += DiffuseBaseColor * light.intensities * light.ambientCoefficient * max(diffFactor, 0.0); \n\n");
    $S06().CallVirtual("Append", null, ps, "  if (diffFactor > 0.0) \n\n");
    $S06().CallVirtual("Append", null, ps, " { \n\n");
    $S06().CallVirtual("Append", null, ps, " vec3 SpecularBaseColor = SpecularColor; \n\n");
    $S06().CallVirtual("Append", null, ps, " vec3 h = normalize(light.coneDirection + Camera); \n\n");
    $S06().CallVirtual("Append", null, ps, " result += SpecularBaseColor * light.intensities * light.ambientCoefficient * SpecularIntensity * pow(max(0.0, dot(h, vNormal)), SpecularShininess); \n\n");
    $S06().CallVirtual("Append", null, ps, " } \n\n");
    $S06().CallVirtual("Append", null, ps, " return result; \n\n");
    $S06().CallVirtual("Append", null, ps, "     }\n\n");
    $S06().CallVirtual("Append", null, ps, "////// SPOTLIGHT \n\n");
    $S06().CallVirtual("Append", null, ps, "if(light.lightType == 2) { \n\n");
    $S06().CallVirtual("Append", null, ps, " vec3 surfaceToLight; \n");
    $S06().CallVirtual("Append", null, ps, "  float attenuation = 1.0; \n\n");
    $S06().CallVirtual("Append", null, ps, " surfaceToLight = normalize(light.position.xyz - surfacePos.xyz); \n");
    $S06().CallVirtual("Append", null, ps, " float distanceToLight = length(light.position.xyz - surfacePos.xyz); \n");
    $S06().CallVirtual("Append", null, ps, "  attenuation = 1.0 / (1.0 + light.attenuation * pow(distanceToLight, 2.0)); \n\n");
    $S06().CallVirtual("Append", null, ps, " //cone restrictions (affects attenuation) \n");
    $S06().CallVirtual("Append", null, ps, " float lightToSurfaceAngle = degrees(acos(dot(-surfaceToLight, normalize(light.coneDirection)))); \n\n");
    $S06().CallVirtual("Append", null, ps, " if(lightToSurfaceAngle > light.coneAngle) { \n\n");
    $S06().CallVirtual("Append", null, ps, "  attenuation = 0.0; } \n\n");
    $S06().CallVirtual("Append", null, ps, "vec3 result = vec3(0, 0, 0); \n\n");
    $S06().CallVirtual("Append", null, ps, "vec3 DiffuseBaseColor = DiffuseColor; \n\n");
    $S06().CallVirtual("Append", null, ps, "float diffFactor = dot(LDir, Normal); \n\n");
    $S06().CallVirtual("Append", null, ps, "  result += attenuation * DiffuseBaseColor * light.intensities * light.ambientCoefficient * max(diffFactor, 0.0); \n\n");
    $S06().CallVirtual("Append", null, ps, "  if (diffFactor > 0.0) \n\n");
    $S06().CallVirtual("Append", null, ps, " { \n\n");
    $S06().CallVirtual("Append", null, ps, " vec3 SpecularBaseColor = SpecularColor; \n\n");
    $S06().CallVirtual("Append", null, ps, " vec3 h = normalize(light.coneDirection + Camera); \n\n");
    $S06().CallVirtual("Append", null, ps, " result += attenuation * SpecularBaseColor * light.intensities * light.ambientCoefficient * SpecularIntensity * pow(max(0.0, dot(h, Normal)), SpecularShininess); \n\n");
    $S06().CallVirtual("Append", null, ps, " } \n\n");
    $S06().CallVirtual("Append", null, ps, " return result; \n\n");
    $S06().CallVirtual("Append", null, ps, "     } \n\n");
    $S06().CallVirtual("Append", null, ps, "}\n\n");
  }; 

  function LegacyShaderCodeBuilder_AddCameraVec (ps) {
    if (this._hasSpecular) {
      $S06().CallVirtual("Append", null, ps, "    vec3 Camera = vViewDir;\n");
    }
  }; 

  function LegacyShaderCodeBuilder_AddChannelBaseColorCalculation (ps, hasChannelTexture, channelName) {
    var flag = !hasChannelTexture || 
    !this._hasUVs;
    if (flag) {
      $S06().CallVirtual("Append", null, ps, "    vec3 ");
      $S06().CallVirtual("Append", null, ps, channelName);
      $S06().CallVirtual("Append", null, ps, "BaseColor = ");
      $S06().CallVirtual("Append", null, ps, channelName);
      $S06().CallVirtual("Append", null, ps, "Color;\n");
    } else {
      $S06().CallVirtual("Append", null, ps, "    vec3 ");
      $S06().CallVirtual("Append", null, ps, channelName);
      $S06().CallVirtual("Append", null, ps, "BaseColor = ");
      $S06().CallVirtual("Append", null, ps, channelName);
      $S06().CallVirtual("Append", null, ps, "Color * (1.0 - ");
      $S06().CallVirtual("Append", null, ps, channelName);
      $S06().CallVirtual("Append", null, ps, "Mix) + texture2D(");
      $S06().CallVirtual("Append", null, ps, channelName);
      $S06().CallVirtual("Append", null, ps, "Texture, vUV).rgb * ");
      $S06().CallVirtual("Append", null, ps, channelName);
      $S06().CallVirtual("Append", null, ps, "Mix;\n");
    }
  }; 

  function LegacyShaderCodeBuilder_AddcooktorranceLightning (ps) {
    $S06().CallVirtual("Append", null, ps, "\n\n vec3 ApplyLight() { return vec3(0.0, 1.0, 1.0); } \n\n");
  }; 

  function LegacyShaderCodeBuilder_AddcooktorrancePBRMat (ps, mpbr) {
    var hasEmissive = this._hasEmissive;
    if (hasEmissive) {
      $S06().CallVirtual("Append", null, ps, "\n\n    //*********** Emissive *********\n");
      this.AddChannelBaseColorCalculation(ps, this._hasEmissiveTexture, "Emissive");
    }
    $S06().CallVirtual("Append", null, ps, "\n\n    //*********** DIFFUSE *********\n");
    this.AddChannelBaseColorCalculation(ps, this._hasDiffuseTexture, "Diffuse");
    $S06().CallVirtual("Append", null, ps, "\n\n    //*********** Specular *********\n");
    this.AddChannelBaseColorCalculation(ps, this._hasSpecularTexture, "Specular");
    $S06().CallVirtual("Append", null, ps, "\n\n   varying vec4 surfacePos; \n");
    $S06().CallVirtual("Append", null, ps, "\n\n   varying mat4 FUSEE_ITMV; \n");
    $S06().CallVirtual("Append", null, ps, "\n\n   varying vec3 oNormal; \n");
    $S06().CallVirtual("Append", null, ps, "vec3 ApplyLight(Light light) { \n\n");
    $S06().CallVirtual("Append", null, ps, " \n\nfloat roughnessValue = ");
    $S07().CallVirtual("AppendFormat", null, ps, "{0} ;\n", JSIL.Array.New($T07(), [$T0D().__Type__.__PublicInterface__.$ToString(mpbr.RoughnessValue, "00000.00", $T0E().get_InvariantCulture())]));
    $S07().CallVirtual("AppendFormat", null, ps, "float F0 = {0};\n", JSIL.Array.New($T07(), [$T0D().__Type__.__PublicInterface__.$ToString(mpbr.FresnelReflectance, "00000.00", $T0E().get_InvariantCulture())]));
    $S07().CallVirtual("AppendFormat", null, ps, "float k = {0};\n", JSIL.Array.New($T07(), [$T0D().__Type__.__PublicInterface__.$ToString(mpbr.DiffuseFraction, "00000.00", $T0E().get_InvariantCulture())]));
    $S06().CallVirtual("Append", null, ps, "vec3 lightColor = light.intensities;\n\nvec3 normal = Normal;\n\n// do the lighting calculation for each fragment.\nfloat NdotL = max(dot(normal, normalize(Camera)), 0.0);\n\n float specular = 0.0;\n\nif(NdotL > 0.0) {\n\nvec3 eyeDir = vViewDir;\n// calculate intermediary values\nvec3 halfVector = normalize(eyeDir + Camera);\nfloat NdotH = max(dot(normal, halfVector), 0.0); \nfloat NdotV = max(dot(normal, eyeDir), 0.0); // note: this could also be NdotL, which is the same value\nfloat VdotH = max(dot(eyeDir, halfVector), 0.0);\nfloat mSquared = roughnessValue * roughnessValue;\n\n// geometric attenuation\nfloat NH2 = 2.0 * NdotH;\nfloat g1 = (NH2 * NdotV) / VdotH;\nfloat g2 = (NH2 * NdotL) / VdotH;\nfloat geoAtt = min(1.0, min(g1, g2));\n\n // roughness (or: microfacet distribution function)\n // beckmann distribution function\nfloat r1 = 1.0 / ( 4.0 * mSquared * pow(NdotH, 4.0));\nfloat r2 = (NdotH * NdotH - 1.0) / (mSquared * NdotH * NdotH);\nfloat roughness = r1 * exp(r2);\n\n// fresnel - Schlick approximation\nfloat fresnel = pow(1.0 - VdotH, 5.0);\nfresnel *= (1.0 - F0);\nfresnel += F0;\nspecular = SpecularBaseColor * ( (fresnel * geoAtt * roughness) / (NdotV * NdotL * 3.14));\n\n}\n\nreturn light.ambientCoefficient * DiffuseBaseColor * lightColor * NdotL * (k + specular * (1.0 - k));\n");
    $S06().CallVirtual("Append", null, ps, "} \n\n");
  }; 

  function LegacyShaderCodeBuilder_AddDiffuseChannel (ps) {
    if (this._hasDiffuse) {
      $S06().CallVirtual("Append", null, ps, "\n\n    //*********** DIFFUSE *********\n");
      this.AddChannelBaseColorCalculation(ps, this._hasDiffuseTexture, "Diffuse");
      $S06().CallVirtual("Append", null, ps, "    float diffFactor = dot(LDir, Normal);\n");
      $S06().CallVirtual("Append", null, ps, "    result += DiffuseBaseColor * LColor * LIntensity * max(diffFactor, 0.0);\n");
    }
  }; 

  function LegacyShaderCodeBuilder_AddEmissiveChannel (ps) {
    if (this._hasEmissive) {
      $S06().CallVirtual("Append", null, ps, "\n\n    //*********** EMISSIVE *********\n");
      this.AddChannelBaseColorCalculation(ps, this._hasEmissiveTexture, "Emissive");
      $S06().CallVirtual("Append", null, ps, "    result += EmissiveBaseColor;\n");
    }
  }; 

  function LegacyShaderCodeBuilder_AddLightVec (ps) {
    if (this._hasDiffuse || this._hasSpecular) {
      $S06().CallVirtual("Append", null, ps, "    vec3 LDir = ");
      $S06().CallVirtual("Append", null, ps, $thisType.get_LightDirectionName());
      $S06().CallVirtual("Append", null, ps, ";\n");
      $S06().CallVirtual("Append", null, ps, "    vec3 LColor = ");
      $S06().CallVirtual("Append", null, ps, $thisType.get_LightColorName());
      $S06().CallVirtual("Append", null, ps, ";\n");
      $S06().CallVirtual("Append", null, ps, "    float LIntensity = ");
      $S06().CallVirtual("Append", null, ps, $thisType.get_LightIntensityName());
      $S06().CallVirtual("Append", null, ps, ";\n");
    }
  }; 

  function LegacyShaderCodeBuilder_AddNormalVec (ps) {
    var hasBump = this._hasBump;
    if (hasBump) {
      $S06().CallVirtual("Append", null, ps, "\n\n    //*********** BUMP *********\n");
      $S06().CallVirtual("Append", null, ps, "    vec3 bv =  normalize(texture2D(BumpTexture, vUV).xyz * 2.0 - 1.0);\n");
      $S06().CallVirtual("Append", null, ps, "    bv = vec3(bv.x, bv.y, -bv.z);\n");
      $S06().CallVirtual("Append", null, ps, "    vec3 Normal =  normalize(bv);\n\n");
    } else {
      $S06().CallVirtual("Append", null, ps, "    vec3 Normal = normalize(vNormal);\n");
    }
  }; 

  function LegacyShaderCodeBuilder_AddSpecularChannel (ps) {
    if (this._hasSpecular) {
      $S06().CallVirtual("Append", null, ps, "\n\n    //*********** SPECULAR *********\n");
      if (!this._hasDiffuse) {
        $S06().CallVirtual("Append", null, ps, "    float diffFactor = dot(LDir, Normal);\n");
      }
      $S06().CallVirtual("Append", null, ps, "    if (diffFactor > 0.0) {\n  ");
      this.AddChannelBaseColorCalculation(ps, this._hasSpecularTexture, "Specular");
      $S06().CallVirtual("Append", null, ps, "      vec3 h = normalize(LDir + Camera);\n");
      $S06().CallVirtual("Append", null, ps, "      result += SpecularBaseColor * LColor * LIntensity * SpecularIntensity * pow(max(0.0, dot(h, Normal)), SpecularShininess);\n");
      $S06().CallVirtual("Append", null, ps, "    }\n");
    }
  }; 

  function LegacyShaderCodeBuilder_AddStandardLightningCalculation (ps) {
    var hasApplyLightString = this._hasApplyLightString;
    if (!hasApplyLightString) {
      var lightingCalculationMethod = this._lightingCalculationMethod;
      if ((lightingCalculationMethod.valueOf() | 0) !== 0) {
        if (lightingCalculationMethod !== $T04().ADVANCED) {
          throw $S08().Construct($T0C().Format("Lightning calculation method: {0} not found!", JSIL.Array.New($T07(), [this._lightingCalculationMethod])));
        }
        $thisType.AddcooktorranceLightning(ps);
      } else {
        this.AddBlinnphongLightning(ps);
      }
      $S06().CallVirtual("Append", null, ps, "\n\n  void main()\n  {\n");
      $S06().CallVirtual("Append", null, ps, "    vec3 result = vec3(0, 0, 0);\n\n");
      $S06().CallVirtual("Append", null, ps, "\n   for(int i = 0; i < 3000; i++) { \n ");
      $S06().CallVirtual("Append", null, ps, "\n   if(i > MAX_LIGHTS) break; \n ");
      $S06().CallVirtual("Append", null, ps, "\n   result += ApplyLight(allLights[i]); \n ");
      $S06().CallVirtual("Append", null, ps, "\n   } \n ");
      $S06().CallVirtual("Append", null, ps, "\n   vec3 gamma = vec3(1.0/2.2);\n ");
      $S06().CallVirtual("Append", null, ps, "\n   vec3 final_light = pow(result, gamma); \n ");
      $S06().CallVirtual("Append", null, ps, "\n   gl_FragColor = vec4(final_light, 1.0);\n");
      $S06().CallVirtual("Append", null, ps, "  }\n\n");
    }
  }; 

  function LegacyShaderCodeBuilder_AnalyzeMaterial$03 (mc) {
    this._hasDiffuse = mc.get_HasDiffuse();
    var hasDiffuse = this._hasDiffuse;
    if (hasDiffuse) {
      this._hasDiffuseTexture = mc.Diffuse.Texture !== null;
    }
    this._hasSpecular = mc.get_HasSpecular();
    var hasSpecular = this._hasSpecular;
    if (hasSpecular) {
      this._hasSpecularTexture = mc.Specular.Texture !== null;
    }
    this._hasEmissive = mc.get_HasEmissive();
    var hasEmissive = this._hasEmissive;
    if (hasEmissive) {
      this._hasEmissiveTexture = mc.Emissive.Texture !== null;
    }
    this._hasBump = mc.get_HasBump();
  }; 

  function LegacyShaderCodeBuilder_AnalyzeMaterial$04 (mlc) {
    this._hasDiffuse = mlc.get_HasDiffuse();
    var hasDiffuse = this._hasDiffuse;
    if (hasDiffuse) {
      this._hasDiffuseTexture = mlc.Diffuse.Texture !== null;
    }
    this._hasSpecular = mlc.get_HasSpecular();
    var hasSpecular = this._hasSpecular;
    if (hasSpecular) {
      this._hasSpecularTexture = mlc.Specular.Texture !== null;
    }
    this._hasEmissive = mlc.get_HasEmissive();
    var hasEmissive = this._hasEmissive;
    if (hasEmissive) {
      this._hasEmissiveTexture = mlc.Emissive.Texture !== null;
    }
    this._hasBump = mlc.get_HasBump();
    this._hasApplyLightString = mlc.ApplyLightString !== null;
    this._hasFragmentString = mlc.FragmentShaderString !== null;
  }; 

  function LegacyShaderCodeBuilder_AnalyzeMaterial$05 (mlc) {
    this._hasDiffuse = mlc.get_HasDiffuse();
    var hasDiffuse = this._hasDiffuse;
    if (hasDiffuse) {
      this._hasDiffuseTexture = mlc.Diffuse.Texture !== null;
    }
    this._hasSpecular = mlc.get_HasSpecular();
    var hasSpecular = this._hasSpecular;
    if (hasSpecular) {
      this._hasSpecularTexture = mlc.Specular.Texture !== null;
    }
    this._hasEmissive = mlc.get_HasEmissive();
    var hasEmissive = this._hasEmissive;
    if (hasEmissive) {
      this._hasEmissiveTexture = mlc.Emissive.Texture !== null;
    }
    this._hasBump = mlc.get_HasBump();
  }; 

  function LegacyShaderCodeBuilder_AnalyzeMesh (mesh) {
    this._hasVertices = (mesh.Vertices !== null) && 
    ((mesh.Vertices.length >>> 0) > (0 >>> 0));
    this._hasNormals = (mesh.Normals !== null) && 
    ((mesh.Normals.length >>> 0) > (0 >>> 0));
    this._hasUVs = (mesh.UVs !== null) && 
    ((mesh.UVs.length >>> 0) > (0 >>> 0));
    this._hasColors = false;
  }; 

  function LegacyShaderCodeBuilder_BumpInputDeclaration (ps) {
    if (this._hasBump) {
      $S06().CallVirtual("Append", null, ps, "  uniform sampler2D BumpTexture;\n");
      $S06().CallVirtual("Append", null, ps, "  uniform float BumpIntensity;\n\n");
    }
  }; 

  function LegacyShaderCodeBuilder_ChannelInputDeclaration (ps, hasChannel, hasChannelTexture, channelName) {
    var flag = !hasChannel;
    if (!flag) {
      $S06().CallVirtual("Append", null, ps, "  uniform vec3 ");
      $S06().CallVirtual("Append", null, ps, channelName);
      $S06().CallVirtual("Append", null, ps, "Color;\n");
      var flag2 = !hasChannelTexture;
      if (!flag2) {
        $S06().CallVirtual("Append", null, ps, "  uniform sampler2D ");
        $S06().CallVirtual("Append", null, ps, channelName);
        $S06().CallVirtual("Append", null, ps, "Texture;\n");
        $S06().CallVirtual("Append", null, ps, "  uniform float ");
        $S06().CallVirtual("Append", null, ps, channelName);
        $S06().CallVirtual("Append", null, ps, "Mix;\n\n");
      }
    }
  }; 

  function LegacyShaderCodeBuilder_CheckApplyLightStringForErrors (applyLightMethod) {
    return (!$T0C().IsNullOrEmpty(applyLightMethod) && ((applyLightMethod.indexOf("vec3 ApplyLight(Light light)") != -1)));
  }; 

  function LegacyShaderCodeBuilder_CreatePSBodyFromLightningMethod (ps) {
    var flag = ($T14().AllLightResults.get_Count() | 0) === 0;
    if (flag) {
      $S06().CallVirtual("Append", null, ps, "\n\n  void main()\n  {\n");
      $S06().CallVirtual("Append", null, ps, "    vec3 result = vec3(0, 0, 0);\n\n");
      this.AddNormalVec(ps);
      this.AddCameraVec(ps);
      this.AddLightVec(ps);
      this.AddEmissiveChannel(ps);
      this.AddDiffuseChannel(ps);
      this.AddSpecularChannel(ps);
      $S06().CallVirtual("Append", null, ps, "\n    gl_FragColor = vec4(result, 1.0);\n");
      $S06().CallVirtual("Append", null, ps, "  }\n\n");
    } else {
      this.AddStandardLightningCalculation(ps);
    }
  }; 

  function LegacyShaderCodeBuilder_get_BumpIntensityName () {
    return (
      this._hasBump
         ? "BumpIntensity"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_BumpTextureName () {
    return (
      this._hasBump
         ? "BumpTexture"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_DiffuseColorName () {
    return (
      this._hasDiffuse
         ? "DiffuseColor"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_DiffuseMixName () {
    return (
      this._hasDiffuse
         ? "DiffuseMix"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_DiffuseTextureName () {
    return (
      this._hasDiffuseTexture
         ? "DiffuseTexture"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_EmissiveColorName () {
    return (
      this._hasEmissive
         ? "EmissiveColor"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_EmissiveMixName () {
    return (
      this._hasEmissive
         ? "EmissiveMix"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_EmissiveTextureName () {
    return (
      this._hasEmissiveTexture
         ? "EmissiveTexture"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_LightColorName () {
    return "LightColor";
  }; 

  function LegacyShaderCodeBuilder_get_LightDirectionName () {
    return "LightDirection";
  }; 

  function LegacyShaderCodeBuilder_get_LightIntensityName () {
    return "LightIntensity";
  }; 

  function LegacyShaderCodeBuilder_get_PS () {
    return this._ps;
  }; 

  function LegacyShaderCodeBuilder_get_SpecularColorName () {
    return (
      this._hasSpecular
         ? "SpecularColor"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_SpecularIntensityName () {
    return (
      this._hasSpecular
         ? "SpecularIntensity"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_SpecularMixName () {
    return (
      this._hasSpecular
         ? "SpecularMix"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_SpecularShininessName () {
    return (
      this._hasSpecular
         ? "SpecularShininess"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_SpecularTextureName () {
    return (
      this._hasSpecularTexture
         ? "SpecularTexture"
         : null)
    ;
  }; 

  function LegacyShaderCodeBuilder_get_VS () {
    return this._vs;
  }; 

  function LegacyShaderCodeBuilder_MatrixDeclarations (vs) {
    var hasSpecular = this._hasSpecular;
    if (hasSpecular) {
      $S06().CallVirtual("Append", null, vs, "  uniform mat4 FUSEE_IMV;\n");
    }
    var hasWeightMap = this._hasWeightMap;
    if (hasWeightMap) {
      $S06().CallVirtual("Append", null, vs, "uniform mat4 FUSEE_P;\n");
      $S06().CallVirtual("Append", null, vs, "uniform mat4 FUSEE_V;\n");
    } else {
      $S06().CallVirtual("Append", null, vs, "  uniform mat4 FUSEE_MVP;\n");
    }
    var hasWeightMap2 = this._hasWeightMap;
    if (hasWeightMap2) {
      $S06().CallVirtual("Append", null, vs, JSIL.ConcatString("  uniform mat4 FUSEE_BONES[", $T15().$Box(this._nBones), "];\n"));
    }
    $S06().CallVirtual("Append", null, vs, "varying vec4 surfacePos;\n");
    $S06().CallVirtual("Append", null, vs, "uniform mat4 FUSEE_MV;\n");
  }; 

  function LegacyShaderCodeBuilder_MeshInputDeclarations (vs) {
    var hasVertices = this._hasVertices;
    if (hasVertices) {
      $S06().CallVirtual("Append", null, vs, "  attribute vec3 fuVertex;\n");
      var hasSpecular = this._hasSpecular;
      if (hasSpecular) {
        $S06().CallVirtual("Append", null, vs, "  varying vec3 vViewDir;\n");
      }
    }
    var hasWeightMap = this._hasWeightMap;
    if (hasWeightMap) {
      $S06().CallVirtual("Append", null, vs, "  attribute vec4 fuBoneIndex;\n");
      $S06().CallVirtual("Append", null, vs, "  attribute vec4 fuBoneWeight;\n");
    }
    var hasNormals = this._hasNormals;
    if (hasNormals) {
      $S06().CallVirtual("Append", null, vs, "  attribute vec3 fuNormal;\n  varying vec3 vNormal;\n");
    }
    var hasUVs = this._hasUVs;
    if (hasUVs) {
      $S06().CallVirtual("Append", null, vs, "  attribute vec2 fuUV;\n  varying vec2 vUV;\n");
    }
    var hasColors = this._hasColors;
    if (hasColors) {
      $S06().CallVirtual("Append", null, vs, "  attribute vec4 fuColor;\n  varying vec4 vColors;\n");
    }
  }; 

  function LegacyShaderCodeBuilder_ParseLights (ps) {
    $S06().CallVirtual("Append", null, ps, "\n\n uniform struct Light {\nvec3 position;\nvec3 intensities;\nvec3 coneDirection;\nfloat attenuation;\nfloat ambientCoefficient;\nfloat coneAngle;\nint lightType;\n};\n\n\n");
    $S06().CallVirtual("Append", null, ps, "\n\n uniform Light allLights[MAX_LIGHTS]; \n\n\n");
  }; 

  function LegacyShaderCodeBuilder_PixelInputDeclarations (ps) {
    $S06().CallVirtual("Append", null, ps, "#ifdef GL_ES\n");
    $S06().CallVirtual("Append", null, ps, "  precision highp float;\n");
    $S06().CallVirtual("Append", null, ps, "#endif\n\n");
    var numberOfLights = ((
      (($T14().AllLightResults.get_Count() | 0) > 0)
         ? $T14().AllLightResults.get_Count()
         : 1)
     | 0);
    $S06().CallVirtual("Append", null, ps, JSIL.ConcatString("\n\n #define MAX_LIGHTS ", $T15().$Box(numberOfLights), "\n\n"));
    this.ChannelInputDeclaration(ps, this._hasDiffuse, this._hasDiffuseTexture, "Diffuse");
    this.SpecularInputDeclaration(ps);
    this.ChannelInputDeclaration(ps, this._hasEmissive, this._hasEmissiveTexture, "Emissive");
    this.BumpInputDeclaration(ps);
    if (this._hasSpecular || this._hasDiffuse) {
      $S06().CallVirtual("Append", null, ps, "  uniform vec3 ");
      $S06().CallVirtual("Append", null, ps, $thisType.get_LightColorName());
      $S06().CallVirtual("Append", null, ps, ";\n");
      $S06().CallVirtual("Append", null, ps, "  uniform float ");
      $S06().CallVirtual("Append", null, ps, $thisType.get_LightIntensityName());
      $S06().CallVirtual("Append", null, ps, ";\n");
      $S06().CallVirtual("Append", null, ps, "  uniform vec3 ");
      $S06().CallVirtual("Append", null, ps, $thisType.get_LightDirectionName());
      $S06().CallVirtual("Append", null, ps, ";\n");
    }
    var hasSpecular = this._hasSpecular;
    if (hasSpecular) {
      $S06().CallVirtual("Append", null, ps, "  varying vec3 vViewDir;\n");
    }
    var hasNormals = this._hasNormals;
    if (hasNormals) {
      $S06().CallVirtual("Append", null, ps, "  varying vec3 vNormal;\n");
    }
    var hasUVs = this._hasUVs;
    if (hasUVs) {
      $S06().CallVirtual("Append", null, ps, "  varying vec2 vUV;\n");
    }
  }; 

  function LegacyShaderCodeBuilder_PSBody (ps) {
    $thisType.ParseLights(ps);
    this.CreatePSBodyFromLightningMethod(ps);
  }; 

  function LegacyShaderCodeBuilder_PSCustomBody (ps, mlc) {
    $thisType.ParseLights(ps);
    this.AddApplyLightCalculation(ps, mlc);
    $S06().CallVirtual("Append", null, ps, "\n\n  void main()\n  {\n");
    $S06().CallVirtual("Append", null, ps, "    vec3 result = vec3(0, 0, 0);\n\n");
    this.AddNormalVec(ps);
    this.AddCameraVec(ps);
    $S06().CallVirtual("Append", null, ps, "\n   for(int i = 0; i < 3000; i++) { \n ");
    $S06().CallVirtual("Append", null, ps, "\n   if(i > MAX_LIGHTS) break; \n ");
    $S06().CallVirtual("Append", null, ps, "\n   result += ApplyLight(allLights[i]); \n ");
    $S06().CallVirtual("Append", null, ps, "\n   } \n ");
    $S06().CallVirtual("Append", null, ps, "\n   vec3 gamma = vec3(1.0/2.2);\n ");
    $S06().CallVirtual("Append", null, ps, "\n   vec3 final_light = pow(result, gamma); \n ");
    $S06().CallVirtual("Append", null, ps, "\n   gl_FragColor = vec4(final_light, 1.0);\n");
    $S06().CallVirtual("Append", null, ps, "  }\n\n");
  }; 

  function LegacyShaderCodeBuilder_PSPBRBody (ps, mpbr) {
    $thisType.ParseLights(ps);
    this.AddNormalVec(ps);
    this.AddCameraVec(ps);
    if (!this._hasSpecular) {
      $S06().CallVirtual("Append", null, ps, "  varying vec3 vViewDir;\n");
    }
    this.AddcooktorrancePBRMat(ps, mpbr);
    $S06().CallVirtual("Append", null, ps, "\n\n  void main()\n  {\n");
    $S06().CallVirtual("Append", null, ps, "    vec3 result = vec3(0, 0, 0);\n\n");
    $S06().CallVirtual("Append", null, ps, "\n   for(int i = 0; i < 3000; i++) { \n ");
    $S06().CallVirtual("Append", null, ps, "\n   if(i > MAX_LIGHTS) break; \n ");
    $S06().CallVirtual("Append", null, ps, "\n   result += ApplyLight(allLights[i]); \n ");
    $S06().CallVirtual("Append", null, ps, "\n   vec3 gamma = vec3(1.0/2.2);\n ");
    $S06().CallVirtual("Append", null, ps, "\n   vec3 final_light = pow(result, gamma); \n ");
    $S06().CallVirtual("Append", null, ps, "\n   gl_FragColor = vec4(final_light, 1.0);\n");
    $S06().CallVirtual("Append", null, ps, "  }\n\n");
  }; 

  function LegacyShaderCodeBuilder_SpecularInputDeclaration (ps) {
    if (this._hasSpecular) {
      this.ChannelInputDeclaration(ps, this._hasSpecular, this._hasSpecularTexture, "Specular");
      $S06().CallVirtual("Append", null, ps, "  uniform float SpecularShininess;\n");
      $S06().CallVirtual("Append", null, ps, "  uniform float SpecularIntensity;\n\n");
    }
  }; 

  function LegacyShaderCodeBuilder_VSBody (vs) {
    $S06().CallVirtual("Append", null, vs, "\n\n  varying vec3 oNormal; \n  \n");
    $S06().CallVirtual("Append", null, vs, "\n\n  void main()\n  {\n");
    var hasNormals = this._hasNormals;
    if (hasNormals) {
      var hasWeightMap = this._hasWeightMap;
      if (hasWeightMap) {
        $S06().CallVirtual("Append", null, vs, "    vec4 newVertex;\n");
        $S06().CallVirtual("Append", null, vs, "    vec4 newNormal;\n");
        $S06().CallVirtual("Append", null, vs, "    newVertex = (FUSEE_BONES[int(fuBoneIndex.x)] * vec4(fuVertex, 1.0) ) * fuBoneWeight.x ;\n");
        $S06().CallVirtual("Append", null, vs, "    newNormal = (FUSEE_BONES[int(fuBoneIndex.x)] * vec4(fuNormal, 0.0)) * fuBoneWeight.x;\n");
        $S06().CallVirtual("Append", null, vs, "    newVertex = (FUSEE_BONES[int(fuBoneIndex.y)] * vec4(fuVertex, 1.0)) * fuBoneWeight.y + newVertex;\n");
        $S06().CallVirtual("Append", null, vs, "    newNormal = (FUSEE_BONES[int(fuBoneIndex.y)] * vec4(fuNormal, 0.0)) * fuBoneWeight.y + newNormal;\n");
        $S06().CallVirtual("Append", null, vs, "    newVertex = (FUSEE_BONES[int(fuBoneIndex.z)] * vec4(fuVertex, 1.0)) * fuBoneWeight.z + newVertex;\n");
        $S06().CallVirtual("Append", null, vs, "    newNormal = (FUSEE_BONES[int(fuBoneIndex.z)] * vec4(fuNormal, 0.0)) * fuBoneWeight.z + newNormal;\n");
        $S06().CallVirtual("Append", null, vs, "    newVertex = (FUSEE_BONES[int(fuBoneIndex.w)] * vec4(fuVertex, 1.0)) * fuBoneWeight.w + newVertex;\n");
        $S06().CallVirtual("Append", null, vs, "    newNormal = (FUSEE_BONES[int(fuBoneIndex.w)] * vec4(fuNormal, 0.0)) * fuBoneWeight.w + newNormal;\n");
        $S06().CallVirtual("Append", null, vs, "    vNormal = mat3(FUSEE_IMV) * newNormal.xyz;\n");
        var normalizeNormals = this._normalizeNormals;
        if (normalizeNormals) {
          $S06().CallVirtual("Append", null, vs, "    vNormal = normalize(vNormal);\n");
        }
      } else {
        var normalizeNormals2 = this._normalizeNormals;
        if (normalizeNormals2) {
          $S06().CallVirtual("Append", null, vs, "    vNormal = normalize(fuNormal);\n");
        } else {
          $S06().CallVirtual("Append", null, vs, "    vNormal = fuNormal;\n");
        }
      }
    }
    var hasSpecular = this._hasSpecular;
    if (hasSpecular) {
      $S06().CallVirtual("Append", null, vs, "    vec3 viewPos = FUSEE_IMV[3].xyz;\n");
      var hasWeightMap2 = this._hasWeightMap;
      if (hasWeightMap2) {
        $S06().CallVirtual("Append", null, vs, "    vViewDir = normalize(viewPos - vec3(newVertex));\n");
      } else {
        $S06().CallVirtual("Append", null, vs, "    vViewDir = normalize(viewPos - fuVertex);\n");
      }
    }
    var hasWeightMap3 = this._hasWeightMap;
    if (hasWeightMap3) {
      $S06().CallVirtual("Append", null, vs, "    gl_Position = FUSEE_P * FUSEE_V * vec4(vec3(newVertex), 1.0);\n ");
    } else {
      $S06().CallVirtual("Append", null, vs, "    gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\n");
    }
    var hasUVs = this._hasUVs;
    if (hasUVs) {
      $S06().CallVirtual("Append", null, vs, "    vUV = fuUV;\n");
    }
    $S06().CallVirtual("Append", null, vs, " surfacePos =  vec4(fuVertex, 1.0); \n");
    $S06().CallVirtual("Append", null, vs, " oNormal = fuNormal; \n");
    $S06().CallVirtual("Append", null, vs, "  }\n\n");
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.LegacyShaderCodeBuilder", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("Fusee.Serialization.MaterialPBRComponent"), $asm0A.TypeRef("Fusee.Serialization.MeshComponent"), 
          $asm0A.TypeRef("Fusee.Serialization.WeightComponent")
        ]), 
      LegacyShaderCodeBuilder__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("Fusee.Serialization.MaterialLightComponent"), $asm0A.TypeRef("Fusee.Serialization.MeshComponent"), 
          $asm0A.TypeRef("Fusee.Serialization.WeightComponent")
        ]), 
      LegacyShaderCodeBuilder__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("Fusee.Serialization.MaterialComponent"), $asm0A.TypeRef("Fusee.Serialization.MeshComponent"), 
          $asm0A.TypeRef("Fusee.Serialization.WeightComponent")
        ]), 
      LegacyShaderCodeBuilder__ctor$02
    );

    $.Method({Static:false, Public:false}, "AddApplyLightCalculation", 
      new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.Text.StringBuilder"), $asm0A.TypeRef("Fusee.Serialization.MaterialLightComponent")]), 
      LegacyShaderCodeBuilder_AddApplyLightCalculation
    );

    $.Method({Static:false, Public:false}, "AddBlinnphongLightning", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_AddBlinnphongLightning
    );

    $.Method({Static:false, Public:false}, "AddCameraVec", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_AddCameraVec
    );

    $.Method({Static:false, Public:false}, "AddChannelBaseColorCalculation", 
      new JSIL.MethodSignature(null, [
          $asm0E.TypeRef("System.Text.StringBuilder"), $.Boolean, 
          $.String
        ]), 
      LegacyShaderCodeBuilder_AddChannelBaseColorCalculation
    );

    $.Method({Static:true , Public:false}, "AddcooktorranceLightning", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_AddcooktorranceLightning
    );

    $.Method({Static:false, Public:false}, "AddcooktorrancePBRMat", 
      new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.Text.StringBuilder"), $asm0A.TypeRef("Fusee.Serialization.MaterialPBRComponent")]), 
      LegacyShaderCodeBuilder_AddcooktorrancePBRMat
    );

    $.Method({Static:false, Public:false}, "AddDiffuseChannel", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_AddDiffuseChannel
    );

    $.Method({Static:false, Public:false}, "AddEmissiveChannel", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_AddEmissiveChannel
    );

    $.Method({Static:false, Public:false}, "AddLightVec", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_AddLightVec
    );

    $.Method({Static:false, Public:false}, "AddNormalVec", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_AddNormalVec
    );

    $.Method({Static:false, Public:false}, "AddSpecularChannel", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_AddSpecularChannel
    );

    $.Method({Static:false, Public:false}, "AddStandardLightningCalculation", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_AddStandardLightningCalculation
    );

    $.Method({Static:false, Public:false}, "AnalyzeMaterial", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialComponent")), 
      LegacyShaderCodeBuilder_AnalyzeMaterial$03
    );

    $.Method({Static:false, Public:false}, "AnalyzeMaterial", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialLightComponent")), 
      LegacyShaderCodeBuilder_AnalyzeMaterial$04
    );

    $.Method({Static:false, Public:false}, "AnalyzeMaterial", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MaterialPBRComponent")), 
      LegacyShaderCodeBuilder_AnalyzeMaterial$05
    );

    $.Method({Static:false, Public:false}, "AnalyzeMesh", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("Fusee.Serialization.MeshComponent")), 
      LegacyShaderCodeBuilder_AnalyzeMesh
    );

    $.Method({Static:false, Public:false}, "BumpInputDeclaration", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_BumpInputDeclaration
    );

    $.Method({Static:false, Public:false}, "ChannelInputDeclaration", 
      new JSIL.MethodSignature(null, [
          $asm0E.TypeRef("System.Text.StringBuilder"), $.Boolean, 
          $.Boolean, $.String
        ]), 
      LegacyShaderCodeBuilder_ChannelInputDeclaration
    );

    $.Method({Static:true , Public:false}, "CheckApplyLightStringForErrors", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      LegacyShaderCodeBuilder_CheckApplyLightStringForErrors
    );

    $.Method({Static:false, Public:false}, "CreatePSBodyFromLightningMethod", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_CreatePSBodyFromLightningMethod
    );

    $.Method({Static:false, Public:true }, "get_BumpIntensityName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_BumpIntensityName
    );

    $.Method({Static:false, Public:true }, "get_BumpTextureName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_BumpTextureName
    );

    $.Method({Static:false, Public:true }, "get_DiffuseColorName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_DiffuseColorName
    );

    $.Method({Static:false, Public:true }, "get_DiffuseMixName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_DiffuseMixName
    );

    $.Method({Static:false, Public:true }, "get_DiffuseTextureName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_DiffuseTextureName
    );

    $.Method({Static:false, Public:true }, "get_EmissiveColorName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_EmissiveColorName
    );

    $.Method({Static:false, Public:true }, "get_EmissiveMixName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_EmissiveMixName
    );

    $.Method({Static:false, Public:true }, "get_EmissiveTextureName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_EmissiveTextureName
    );

    $.Method({Static:true , Public:true }, "get_LightColorName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_LightColorName
    );

    $.Method({Static:true , Public:true }, "get_LightDirectionName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_LightDirectionName
    );

    $.Method({Static:true , Public:true }, "get_LightIntensityName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_LightIntensityName
    );

    $.Method({Static:false, Public:true }, "get_PS", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_PS
    );

    $.Method({Static:false, Public:true }, "get_SpecularColorName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_SpecularColorName
    );

    $.Method({Static:false, Public:true }, "get_SpecularIntensityName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_SpecularIntensityName
    );

    $.Method({Static:false, Public:true }, "get_SpecularMixName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_SpecularMixName
    );

    $.Method({Static:false, Public:true }, "get_SpecularShininessName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_SpecularShininessName
    );

    $.Method({Static:false, Public:true }, "get_SpecularTextureName", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_SpecularTextureName
    );

    $.Method({Static:false, Public:true }, "get_VS", 
      JSIL.MethodSignature.Return($.String), 
      LegacyShaderCodeBuilder_get_VS
    );

    $.Method({Static:false, Public:false}, "MatrixDeclarations", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_MatrixDeclarations
    );

    $.Method({Static:false, Public:false}, "MeshInputDeclarations", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_MeshInputDeclarations
    );

    $.Method({Static:true , Public:false}, "ParseLights", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_ParseLights
    );

    $.Method({Static:false, Public:false}, "PixelInputDeclarations", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_PixelInputDeclarations
    );

    $.Method({Static:false, Public:false}, "PSBody", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_PSBody
    );

    $.Method({Static:false, Public:false}, "PSCustomBody", 
      new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.Text.StringBuilder"), $asm0A.TypeRef("Fusee.Serialization.MaterialLightComponent")]), 
      LegacyShaderCodeBuilder_PSCustomBody
    );

    $.Method({Static:false, Public:false}, "PSPBRBody", 
      new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.Text.StringBuilder"), $asm0A.TypeRef("Fusee.Serialization.MaterialPBRComponent")]), 
      LegacyShaderCodeBuilder_PSPBRBody
    );

    $.Method({Static:false, Public:false}, "SpecularInputDeclaration", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_SpecularInputDeclaration
    );

    $.Method({Static:false, Public:false}, "VSBody", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Text.StringBuilder")), 
      LegacyShaderCodeBuilder_VSBody
    );

    $.Field({Static:true , Public:true }, "_allLights", $asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm04.TypeRef("Fusee.Engine.Core.LightResult")]));

    $.Field({Static:false, Public:false}, "_hasVertices", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasNormals", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasUVs", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasColors", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasDiffuse", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasSpecular", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasEmissive", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasBump", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasDiffuseTexture", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasSpecularTexture", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasEmissiveTexture", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasWeightMap", $.Boolean);

    $.Field({Static:false, Public:false}, "_nBones", $.Int32);

    $.Field({Static:false, Public:false}, "_normalizeNormals", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasApplyLightString", $.Boolean);

    $.Field({Static:false, Public:false}, "_hasFragmentString", $.Boolean);

    $.Field({Static:false, Public:false}, "_lightingCalculationMethod", $asm04.TypeRef("Fusee.Engine.Core.LightingCalculationMethod"));

    $.Field({Static:false, Public:false}, "_vs", $.String);

    $.Field({Static:false, Public:false}, "_ps", $.String);


    function LegacyShaderCodeBuilder__cctor () {
      $thisType._allLights = $S00().Construct();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      LegacyShaderCodeBuilder__cctor
    );

    $.Property({Static:false, Public:true }, "VS", $.String);

    $.Property({Static:false, Public:true }, "PS", $.String);

    $.Property({Static:false, Public:true }, "DiffuseColorName", $.String);

    $.Property({Static:false, Public:true }, "SpecularColorName", $.String);

    $.Property({Static:false, Public:true }, "EmissiveColorName", $.String);

    $.Property({Static:false, Public:true }, "DiffuseTextureName", $.String);

    $.Property({Static:false, Public:true }, "SpecularTextureName", $.String);

    $.Property({Static:false, Public:true }, "EmissiveTextureName", $.String);

    $.Property({Static:false, Public:true }, "BumpTextureName", $.String);

    $.Property({Static:false, Public:true }, "DiffuseMixName", $.String);

    $.Property({Static:false, Public:true }, "SpecularMixName", $.String);

    $.Property({Static:false, Public:true }, "EmissiveMixName", $.String);

    $.Property({Static:false, Public:true }, "SpecularShininessName", $.String);

    $.Property({Static:false, Public:true }, "SpecularIntensityName", $.String);

    $.Property({Static:false, Public:true }, "BumpIntensityName", $.String);

    $.Property({Static:true , Public:true }, "LightDirectionName", $.String);

    $.Property({Static:true , Public:true }, "LightColorName", $.String);

    $.Property({Static:true , Public:true }, "LightIntensityName", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ShaderMaterial */ 

(function ShaderMaterial$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderProgram)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };


  function ShaderMaterial__ctor (program) {
    this._sp = program;
  }; 

  function ShaderMaterial_GetShader () {
    return this._sp;
  }; 

  function ShaderMaterial_UpdateMaterial (rc) {
    rc.SetShader(this._sp);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.ShaderMaterial", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram")), 
      ShaderMaterial__ctor
    );

    $.Method({Static:false, Public:true }, "GetShader", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram")), 
      ShaderMaterial_GetShader
    );

    $.Method({Static:false, Public:true }, "UpdateMaterial", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      ShaderMaterial_UpdateMaterial
    );

    $.Field({Static:false, Public:false}, "_sp", $asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ShaderProgram */ 

(function ShaderProgram$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IShaderProgramImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm03.Fusee.Engine.Common.ShaderParamInfo))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.ShaderParamInfo))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.ShaderParamInfo))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Collections.IEnumerator)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm03.Fusee.Engine.Common.ShaderParamInfo)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.IDisposable)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm03.Fusee.Engine.Common.ShaderParamInfo), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.ShaderParamInfo).GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.GetShaderParamList)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0E.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.ShaderParamInfo).get_Current)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm0E.System.IDisposable.Dispose)) ();
  };


  function ShaderProgram__ctor (renderContextImp, shaderProgramImp) {
    this._spi = shaderProgramImp;
    this._rci = renderContextImp;
    this._paramsByName = $S00().Construct();
    var enumerator = $IM00().Call($IM01().Call(this._rci, null, this._spi), null);
    try {

      while ($IM02().Call(enumerator, null)) {
        var info = $IM03().Call(enumerator, null).MemberwiseClone();
        (this._paramsByName).Add(info.Name, info.MemberwiseClone());
      }
    } finally {
      if (enumerator !== null) {
        $IM04().Call(enumerator, null);
      }
    }
  }; 

  function ShaderProgram_GetShaderParam (paramName) {
    return this.GetShaderParamInfo(paramName).Handle;
  }; 

  function ShaderProgram_GetShaderParamInfo (paramName) {
    var ret = new JSIL.BoxedVariable(new ($T06())());
    (this._paramsByName).TryGetValue(paramName, /* ref */ ret);
    return ret.get();
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.ShaderProgram", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IRenderContextImp"), $asm03.TypeRef("Fusee.Engine.Common.IShaderProgramImp")]), 
      ShaderProgram__ctor
    );

    $.Method({Static:false, Public:true }, "GetShaderParam", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), [$.String]), 
      ShaderProgram_GetShaderParam
    );

    $.Method({Static:false, Public:true }, "GetShaderParamInfo", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.ShaderParamInfo"), [$.String]), 
      ShaderProgram_GetShaderParamInfo
    );

    $.Field({Static:false, Public:false}, "_spi", $asm03.TypeRef("Fusee.Engine.Common.IShaderProgramImp"));

    $.Field({Static:false, Public:false}, "_rci", $asm03.TypeRef("Fusee.Engine.Common.IRenderContextImp"));

    $.Field({Static:false, Public:false}, "_paramsByName", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $asm03.TypeRef("Fusee.Engine.Common.ShaderParamInfo")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Shaders */ 

(function Shaders$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };


  function Shaders_GetBumpDiffuseShader (rc) {
    return rc.CreateShader("\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;\r\n                  \r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n    \r\n            uniform mat4 FUSEE_MV; \r\n            uniform mat4 FUSEE_MVP;\r\n\r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n\r\n                vec4 vViewTemp = FUSEE_MV * vec4(fuVertex, 1);\r\n                vViewPos = vec3(vViewTemp) / vViewTemp.w;\r\n\r\n                vNormal = normalize(mat3(FUSEE_MV[0].xyz, FUSEE_MV[1].xyz, FUSEE_MV[2].xyz) * fuNormal);\r\n\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n            }", "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            #define LIGHT_COUNT 8\r\n\r\n            struct FUSEE_LIGHT\r\n            {\r\n                float active;\r\n                vec4 diffuse;\r\n                vec4 ambient;\r\n                vec4 specular;\r\n                vec3 position;\r\n                vec3 direction;\r\n                float spotAngle;\r\n            } uniform FUSEE_LIGHTS[LIGHT_COUNT];\r\n    \r\n            uniform mat4 FUSEE_V;\r\n            uniform mat4 FUSEE_MV;\r\n         \r\n            uniform sampler2D texture1;\r\n            uniform sampler2D normalTex;\r\n            uniform float shininess;\r\n            uniform float specularLevel;\r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n\r\n            void CalcDirectLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 direction, inout vec4 intensity) {\r\n                float maxVariance = 100.0; // Parameter for Bump Intensity\r\n                float minVariance = maxVariance / 2.0;\r\n\r\n                vec3 bumpNormal = vNormal + normalize(texture2D(normalTex, vUV).rgb * maxVariance - minVariance);\r\n\r\n                intensity += ambColor;\r\n                intensity += max(dot(-normalize(direction), normalize(bumpNormal)), 0.0) * difColor;\r\n\r\n                if (specularLevel != 0.0){\r\n                    vec3 lightVector = normalize(direction);\r\n                    vec3 r = normalize(reflect(lightVector, normalize(bumpNormal)));\r\n                    float s = pow(max(dot(r, vec3(0, 0, 1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                    intensity += specColor * s;\r\n                }\r\n            }\r\n\r\n            void CalcPointLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 position, inout vec4 intensity) {\r\n                float maxVariance = 100.0; // Parameter for Bump Intensity\r\n                float minVariance = maxVariance / 2.0;\r\n\r\n                vec3 bumpNormal = vNormal + normalize(texture2D(normalTex, vUV).rgb * maxVariance - minVariance);\r\n\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                intensity += max(dot(normalize(pos), normalize(bumpNormal)), 0.0) * difColor;\r\n\r\n                if (specularLevel != 0.0){\r\n                    vec3 lightVector = normalize(-pos);  \r\n                    vec3 r = normalize(reflect(lightVector, normalize(bumpNormal)));\r\n                    float s = pow(max(dot(r, vec3(0, 0, 1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                    intensity += specColor * s;\r\n                }\r\n            }\r\n\r\n            void CalcSpotLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 position, vec3 direction, float angle, inout vec4 intensity){\r\n                float maxVariance = 100.0; // Parameter for Bump Intensity\r\n                float minVariance = maxVariance / 2.0;\r\n\r\n                vec3 bumpNormal = vNormal + normalize(texture2D(normalTex, vUV).rgb * maxVariance - minVariance);\r\n\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                float alpha = acos(dot(normalize(pos), normalize(-direction)));\r\n\r\n                if (alpha < angle){\r\n                    intensity += max(dot(normalize(pos), normalize(bumpNormal)), 0.0) * difColor;\r\n\r\n                    if (specularLevel != 0.0){\r\n                        vec3 lightVector = normalize(-pos);  \r\n                        vec3 r = normalize(reflect(lightVector, normalize(bumpNormal)));\r\n                        float s = pow(max(dot(r, vec3(0, 0, 1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                        intensity += specColor * s;\r\n                    }\r\n                }\r\n            }\r\n\r\n            void main()\r\n            {\r\n                vec4 endInt = vec4(0, 0, 0, 0);\r\n\r\n                 for (int i = 0; i < LIGHT_COUNT; i++) {\r\n                    vec4 diffuse = FUSEE_LIGHTS[i].diffuse;\r\n                    vec4 ambient = FUSEE_LIGHTS[i].ambient;\r\n                    vec4 specular = FUSEE_LIGHTS[i].specular;\r\n                    vec3 position = FUSEE_LIGHTS[i].position;\r\n                    vec3 direction = FUSEE_LIGHTS[i].direction;\r\n                    float spotAngle = FUSEE_LIGHTS[i].spotAngle;\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 1.0)\r\n                        CalcDirectLight(diffuse, ambient, specular, direction, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 2.0)\r\n                        CalcPointLight(diffuse, ambient, specular, position, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 3.0)\r\n                        CalcSpotLight(diffuse, ambient, specular, position, direction, spotAngle, endInt);\r\n                }\r\n\r\n                gl_FragColor = texture2D(texture1, vUV) * endInt; \r\n            }");
  }; 

  function Shaders_GetColorShader (rc) {
    return rc.CreateShader("\r\n            attribute vec3 fuVertex;\r\n            uniform mat4 FUSEE_MVP;\r\n\r\n            void main()\r\n            {\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n            }", "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            uniform vec4 color;\r\n\r\n            void main()\r\n            {\r\n                gl_FragColor = color;\r\n            }");
  }; 

  function Shaders_GetDiffuseColorShader (rc) {
    return rc.CreateShader("\r\n            attribute vec3 fuVertex;\r\n            uniform mat4 FUSEE_MVP;\r\n\r\n            void main()\r\n            {\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n            }", "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            uniform vec4 color;\r\n\r\n            void main()\r\n            {\r\n                gl_FragColor = color;\r\n            }");
  }; 

  function Shaders_GetDiffuseTextureShader (rc) {
    return rc.CreateShader("\r\n            attribute vec4 fuColor;\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;\r\n       \r\n            uniform mat4 FUSEE_MVP;\r\n            uniform mat4 FUSEE_MV;\r\n\r\n            varying vec2 vUV;\r\n            varying vec3 vNormal;\r\n            varying vec3 vViewPos;\r\n\r\n            vec3 vPos;\r\n \r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n\r\n                vec4 vViewPosTemp = FUSEE_MV * vec4(fuVertex, 1);\r\n                vViewPos = vec3(vViewPosTemp)/vViewPosTemp.w;      \r\n\r\n                vNormal = normalize(mat3(FUSEE_MV[0].xyz, FUSEE_MV[1].xyz, FUSEE_MV[2].xyz) * fuNormal);\r\n\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n            }", "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            #define LIGHT_COUNT 8\r\n\r\n            struct FUSEE_LIGHT\r\n            {\r\n                float active;\r\n                vec4 diffuse;\r\n                vec4 ambient;\r\n                vec3 position;\r\n                vec3 direction;\r\n                float spotAngle;\r\n            } uniform FUSEE_LIGHTS[LIGHT_COUNT];\r\n\r\n            uniform mat4 FUSEE_V;\r\n            uniform sampler2D texture1;\r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n\r\n            void CalcDirectLight(vec4 difColor, vec4 ambColor, vec3 direction, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n                intensity += max(dot(-normalize(direction), normalize(vNormal)), 0.0) * difColor;\r\n            }\r\n\r\n            void CalcPointLight(vec4 difColor, vec4 ambColor, vec3 position, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                intensity += max(dot(normalize(pos), normalize(vNormal)), 0.0) * difColor;   \r\n            }\r\n\r\n            void CalcSpotLight(vec4 difColor, vec4 ambColor, vec3 position, vec3 direction, float angle, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                float alpha = acos(dot(normalize(pos), normalize(-direction)));\r\n\r\n                if (alpha < angle)\r\n                    intensity += max(dot(normalize(pos), normalize(vNormal)), 0.0) * difColor;   \r\n            }\r\n \r\n            void main()\r\n            {\r\n                vec4 endInt = vec4(0, 0, 0, 0);\r\n\r\n                for (int i = 0; i < LIGHT_COUNT; i++) {\r\n                    vec4 diffuse = FUSEE_LIGHTS[i].diffuse;\r\n                    vec4 ambient = FUSEE_LIGHTS[i].ambient;\r\n                    vec3 position = FUSEE_LIGHTS[i].position;\r\n                    vec3 direction = FUSEE_LIGHTS[i].direction;\r\n                    float spotAngle = FUSEE_LIGHTS[i].spotAngle;\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 1.0)\r\n                        CalcDirectLight(diffuse, ambient, direction, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 2.0)\r\n                        CalcPointLight(diffuse, ambient, position, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 3.0)\r\n                        CalcSpotLight(diffuse, ambient, position, direction, spotAngle, endInt);\r\n                }\r\n\r\n                gl_FragColor = texture2D(texture1, vUV) * endInt; \r\n            }");
  }; 

  function Shaders_GetSpecularShader (rc) {
    return rc.CreateShader("\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;\r\n                  \r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n\r\n            uniform mat4 FUSEE_MV; \r\n            uniform mat4 FUSEE_MVP;\r\n\r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n\r\n                vec4 vViewTemp = FUSEE_MV * vec4(fuVertex, 1);\r\n                vViewPos = vec3(vViewTemp)/vViewTemp.w;\r\n\r\n                vNormal = normalize(mat3(FUSEE_MV[0].xyz, FUSEE_MV[1].xyz, FUSEE_MV[2].xyz) * fuNormal);\r\n\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n            }", "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            #define LIGHT_COUNT 8\r\n\r\n            struct FUSEE_LIGHT\r\n            {\r\n                float active;\r\n                vec4 diffuse;\r\n                vec4 ambient;\r\n                vec4 specular;\r\n                vec3 position;\r\n                vec3 direction;\r\n                float spotAngle;\r\n            } uniform FUSEE_LIGHTS[LIGHT_COUNT];\r\n\r\n            uniform mat4 FUSEE_V;\r\n            uniform sampler2D texture1;\r\n            uniform float specularLevel;\r\n            uniform float shininess;\r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n\r\n            void CalcDirectLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 direction, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n                intensity += max(dot(-normalize(direction), normalize(vNormal)), 0.0) * difColor;\r\n\r\n                if (specularLevel != 0.0){\r\n                    vec3 lightVector = normalize(direction);\r\n                    vec3 r = normalize(reflect(lightVector, normalize(vNormal)));\r\n                    float s = pow(max(dot(r, vec3(0, 0, 1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                    intensity += specColor * s;\r\n                }\r\n            }\r\n\r\n            void CalcPointLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 position, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                intensity += max(dot(normalize(pos), normalize(vNormal)), 0.0) * difColor;\r\n\r\n                if (specularLevel != 0.0){\r\n                    vec3 lightVector = normalize(-pos);\r\n                    vec3 r = normalize(reflect(lightVector, normalize(vNormal)));\r\n                    float s = pow(max(dot(r, vec3(0,0,1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                    intensity += specColor * s;\r\n                }\r\n            }\r\n\r\n            void CalcSpotLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 position, vec3 direction, float angle, inout vec4 intensity){\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                float alpha = dot(normalize(pos), normalize(-direction));\r\n\r\n                if (alpha > angle){\r\n                    intensity += max(dot(normalize(pos), normalize(vNormal)), 0.0) * difColor;\r\n\r\n                    if (specularLevel != 0.0){\r\n                        vec3 lightVector = normalize(-pos);  \r\n                        vec3 r = normalize(reflect(lightVector, normalize(vNormal)));\r\n\r\n                        float s = pow(max(dot(r, vec3(0,0,1.0)), 0.0), specularLevel) * shininess;\r\n                        intensity += specColor * s; \r\n                    }\r\n                }\r\n            }\r\n\r\n            void main()\r\n            {              \r\n                vec4 endInt = vec4(0, 0, 0, 0);\r\n\r\n                for (int i = 0; i < LIGHT_COUNT; i++) {\r\n                    vec4 diffuse = FUSEE_LIGHTS[i].diffuse;\r\n                    vec4 ambient = FUSEE_LIGHTS[i].ambient;\r\n                    vec4 specular = FUSEE_LIGHTS[i].specular;\r\n                    vec3 position = FUSEE_LIGHTS[i].position;\r\n                    vec3 direction = FUSEE_LIGHTS[i].direction;\r\n                    float spotAngle = FUSEE_LIGHTS[i].spotAngle;\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 1.0)\r\n                        CalcDirectLight(diffuse, ambient, specular, direction, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 2.0)\r\n                        CalcPointLight(diffuse, ambient, specular, position, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 3.0)\r\n                        CalcSpotLight(diffuse, ambient, specular, position, direction, spotAngle, endInt);\r\n                }\r\n\r\n                gl_FragColor = texture2D(texture1, vUV) * endInt;\r\n            }");
  }; 

  function Shaders_GetTextureShader (rc) {
    return rc.CreateShader("\r\n            #ifdef GL_ES\r\n                precision mediump float;\r\n            #endif\r\n\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;\r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n\r\n            uniform mat4 FUSEE_MVP;\r\n            uniform mat4 FUSEE_ITMV;\r\n\r\n            void main() {\r\n                vUV = fuUV;\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n                vNormal = mat3(FUSEE_ITMV[0].xyz, FUSEE_ITMV[1].xyz, FUSEE_ITMV[2].xyz) * fuNormal;\r\n            }", "\r\n            #ifdef GL_ES\r\n                precision mediump float;\r\n            #endif\r\n\r\n            uniform sampler2D texture1;\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n\r\n            void main() {\r\n                gl_FragColor = max(dot(vec3(0,0,-1),normalize(vNormal)), 0.2) * texture2D(texture1, vUV);\r\n            }");
  }; 

  JSIL.MakeStaticClass("Fusee.Engine.Core.Shaders", true, [], function ($ib) {
    $ = $ib;

    $.Method({Static:true , Public:true }, "GetBumpDiffuseShader", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"), [$asm04.TypeRef("Fusee.Engine.Core.RenderContext")]), 
      Shaders_GetBumpDiffuseShader
    );

    $.Method({Static:true , Public:true }, "GetColorShader", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"), [$asm04.TypeRef("Fusee.Engine.Core.RenderContext")]), 
      Shaders_GetColorShader
    );

    $.Method({Static:true , Public:true }, "GetDiffuseColorShader", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"), [$asm04.TypeRef("Fusee.Engine.Core.RenderContext")]), 
      Shaders_GetDiffuseColorShader
    );

    $.Method({Static:true , Public:true }, "GetDiffuseTextureShader", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"), [$asm04.TypeRef("Fusee.Engine.Core.RenderContext")]), 
      Shaders_GetDiffuseTextureShader
    );

    $.Method({Static:true , Public:true }, "GetSpecularShader", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"), [$asm04.TypeRef("Fusee.Engine.Core.RenderContext")]), 
      Shaders_GetSpecularShader
    );

    $.Method({Static:true , Public:true }, "GetTextureShader", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"), [$asm04.TypeRef("Fusee.Engine.Core.RenderContext")]), 
      Shaders_GetTextureShader
    );

    $.Constant({Static:true , Public:false}, "_vsSimpleColor", $.String, "\r\n            attribute vec3 fuVertex;\r\n            uniform mat4 FUSEE_MVP;\r\n\r\n            void main()\r\n            {\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n            }");

    $.Constant({Static:true , Public:false}, "_psSimpleColor", $.String, "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            uniform vec4 color;\r\n\r\n            void main()\r\n            {\r\n                gl_FragColor = color;\r\n            }");

    $.Constant({Static:true , Public:false}, "_vsSimpleTexture", $.String, "\r\n            #ifdef GL_ES\r\n                precision mediump float;\r\n            #endif\r\n\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;\r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n\r\n            uniform mat4 FUSEE_MVP;\r\n            uniform mat4 FUSEE_ITMV;\r\n\r\n            void main() {\r\n                vUV = fuUV;\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n                vNormal = mat3(FUSEE_ITMV[0].xyz, FUSEE_ITMV[1].xyz, FUSEE_ITMV[2].xyz) * fuNormal;\r\n            }");

    $.Constant({Static:true , Public:false}, "_psSimpleTexture", $.String, "\r\n            #ifdef GL_ES\r\n                precision mediump float;\r\n            #endif\r\n\r\n            uniform sampler2D texture1;\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n\r\n            void main() {\r\n                gl_FragColor = max(dot(vec3(0,0,-1),normalize(vNormal)), 0.2) * texture2D(texture1, vUV);\r\n            }");

    $.Constant({Static:true , Public:false}, "_vsDiffuse", $.String, "\r\n            attribute vec4 fuColor;\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;\r\n       \r\n            uniform mat4 FUSEE_MVP;\r\n            uniform mat4 FUSEE_MV;\r\n\r\n            varying vec2 vUV;\r\n            varying vec3 vNormal;\r\n            varying vec3 vViewPos;\r\n\r\n            vec3 vPos;\r\n \r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n\r\n                vec4 vViewPosTemp = FUSEE_MV * vec4(fuVertex, 1);\r\n                vViewPos = vec3(vViewPosTemp)/vViewPosTemp.w;      \r\n\r\n                vNormal = normalize(mat3(FUSEE_MV[0].xyz, FUSEE_MV[1].xyz, FUSEE_MV[2].xyz) * fuNormal);\r\n\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n            }");

    $.Constant({Static:true , Public:false}, "_psDiffuse", $.String, "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            #define LIGHT_COUNT 8\r\n\r\n            struct FUSEE_LIGHT\r\n            {\r\n                float active;\r\n                vec4 diffuse;\r\n                vec4 ambient;\r\n                vec3 position;\r\n                vec3 direction;\r\n                float spotAngle;\r\n            } uniform FUSEE_LIGHTS[LIGHT_COUNT];\r\n\r\n            uniform mat4 FUSEE_V;\r\n            uniform sampler2D texture1;\r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n\r\n            void CalcDirectLight(vec4 difColor, vec4 ambColor, vec3 direction, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n                intensity += max(dot(-normalize(direction), normalize(vNormal)), 0.0) * difColor;\r\n            }\r\n\r\n            void CalcPointLight(vec4 difColor, vec4 ambColor, vec3 position, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                intensity += max(dot(normalize(pos), normalize(vNormal)), 0.0) * difColor;   \r\n            }\r\n\r\n            void CalcSpotLight(vec4 difColor, vec4 ambColor, vec3 position, vec3 direction, float angle, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                float alpha = acos(dot(normalize(pos), normalize(-direction)));\r\n\r\n                if (alpha < angle)\r\n                    intensity += max(dot(normalize(pos), normalize(vNormal)), 0.0) * difColor;   \r\n            }\r\n \r\n            void main()\r\n            {\r\n                vec4 endInt = vec4(0, 0, 0, 0);\r\n\r\n                for (int i = 0; i < LIGHT_COUNT; i++) {\r\n                    vec4 diffuse = FUSEE_LIGHTS[i].diffuse;\r\n                    vec4 ambient = FUSEE_LIGHTS[i].ambient;\r\n                    vec3 position = FUSEE_LIGHTS[i].position;\r\n                    vec3 direction = FUSEE_LIGHTS[i].direction;\r\n                    float spotAngle = FUSEE_LIGHTS[i].spotAngle;\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 1.0)\r\n                        CalcDirectLight(diffuse, ambient, direction, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 2.0)\r\n                        CalcPointLight(diffuse, ambient, position, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 3.0)\r\n                        CalcSpotLight(diffuse, ambient, position, direction, spotAngle, endInt);\r\n                }\r\n\r\n                gl_FragColor = texture2D(texture1, vUV) * endInt; \r\n            }");

    $.Constant({Static:true , Public:false}, "_vsSpecular", $.String, "\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;\r\n                  \r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n\r\n            uniform mat4 FUSEE_MV; \r\n            uniform mat4 FUSEE_MVP;\r\n\r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n\r\n                vec4 vViewTemp = FUSEE_MV * vec4(fuVertex, 1);\r\n                vViewPos = vec3(vViewTemp)/vViewTemp.w;\r\n\r\n                vNormal = normalize(mat3(FUSEE_MV[0].xyz, FUSEE_MV[1].xyz, FUSEE_MV[2].xyz) * fuNormal);\r\n\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n            }");

    $.Constant({Static:true , Public:false}, "_psSpecular", $.String, "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            #define LIGHT_COUNT 8\r\n\r\n            struct FUSEE_LIGHT\r\n            {\r\n                float active;\r\n                vec4 diffuse;\r\n                vec4 ambient;\r\n                vec4 specular;\r\n                vec3 position;\r\n                vec3 direction;\r\n                float spotAngle;\r\n            } uniform FUSEE_LIGHTS[LIGHT_COUNT];\r\n\r\n            uniform mat4 FUSEE_V;\r\n            uniform sampler2D texture1;\r\n            uniform float specularLevel;\r\n            uniform float shininess;\r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n\r\n            void CalcDirectLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 direction, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n                intensity += max(dot(-normalize(direction), normalize(vNormal)), 0.0) * difColor;\r\n\r\n                if (specularLevel != 0.0){\r\n                    vec3 lightVector = normalize(direction);\r\n                    vec3 r = normalize(reflect(lightVector, normalize(vNormal)));\r\n                    float s = pow(max(dot(r, vec3(0, 0, 1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                    intensity += specColor * s;\r\n                }\r\n            }\r\n\r\n            void CalcPointLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 position, inout vec4 intensity) {\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                intensity += max(dot(normalize(pos), normalize(vNormal)), 0.0) * difColor;\r\n\r\n                if (specularLevel != 0.0){\r\n                    vec3 lightVector = normalize(-pos);\r\n                    vec3 r = normalize(reflect(lightVector, normalize(vNormal)));\r\n                    float s = pow(max(dot(r, vec3(0,0,1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                    intensity += specColor * s;\r\n                }\r\n            }\r\n\r\n            void CalcSpotLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 position, vec3 direction, float angle, inout vec4 intensity){\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                float alpha = dot(normalize(pos), normalize(-direction));\r\n\r\n                if (alpha > angle){\r\n                    intensity += max(dot(normalize(pos), normalize(vNormal)), 0.0) * difColor;\r\n\r\n                    if (specularLevel != 0.0){\r\n                        vec3 lightVector = normalize(-pos);  \r\n                        vec3 r = normalize(reflect(lightVector, normalize(vNormal)));\r\n\r\n                        float s = pow(max(dot(r, vec3(0,0,1.0)), 0.0), specularLevel) * shininess;\r\n                        intensity += specColor * s; \r\n                    }\r\n                }\r\n            }\r\n\r\n            void main()\r\n            {              \r\n                vec4 endInt = vec4(0, 0, 0, 0);\r\n\r\n                for (int i = 0; i < LIGHT_COUNT; i++) {\r\n                    vec4 diffuse = FUSEE_LIGHTS[i].diffuse;\r\n                    vec4 ambient = FUSEE_LIGHTS[i].ambient;\r\n                    vec4 specular = FUSEE_LIGHTS[i].specular;\r\n                    vec3 position = FUSEE_LIGHTS[i].position;\r\n                    vec3 direction = FUSEE_LIGHTS[i].direction;\r\n                    float spotAngle = FUSEE_LIGHTS[i].spotAngle;\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 1.0)\r\n                        CalcDirectLight(diffuse, ambient, specular, direction, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 2.0)\r\n                        CalcPointLight(diffuse, ambient, specular, position, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 3.0)\r\n                        CalcSpotLight(diffuse, ambient, specular, position, direction, spotAngle, endInt);\r\n                }\r\n\r\n                gl_FragColor = texture2D(texture1, vUV) * endInt;\r\n            }");

    $.Constant({Static:true , Public:false}, "_vsBump", $.String, "\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;\r\n                  \r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n    \r\n            uniform mat4 FUSEE_MV; \r\n            uniform mat4 FUSEE_MVP;\r\n\r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n\r\n                vec4 vViewTemp = FUSEE_MV * vec4(fuVertex, 1);\r\n                vViewPos = vec3(vViewTemp) / vViewTemp.w;\r\n\r\n                vNormal = normalize(mat3(FUSEE_MV[0].xyz, FUSEE_MV[1].xyz, FUSEE_MV[2].xyz) * fuNormal);\r\n\r\n                gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\r\n            }");

    $.Constant({Static:true , Public:false}, "_psBump", $.String, "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            #define LIGHT_COUNT 8\r\n\r\n            struct FUSEE_LIGHT\r\n            {\r\n                float active;\r\n                vec4 diffuse;\r\n                vec4 ambient;\r\n                vec4 specular;\r\n                vec3 position;\r\n                vec3 direction;\r\n                float spotAngle;\r\n            } uniform FUSEE_LIGHTS[LIGHT_COUNT];\r\n    \r\n            uniform mat4 FUSEE_V;\r\n            uniform mat4 FUSEE_MV;\r\n         \r\n            uniform sampler2D texture1;\r\n            uniform sampler2D normalTex;\r\n            uniform float shininess;\r\n            uniform float specularLevel;\r\n\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying vec3 vViewPos;\r\n\r\n            void CalcDirectLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 direction, inout vec4 intensity) {\r\n                float maxVariance = 100.0; // Parameter for Bump Intensity\r\n                float minVariance = maxVariance / 2.0;\r\n\r\n                vec3 bumpNormal = vNormal + normalize(texture2D(normalTex, vUV).rgb * maxVariance - minVariance);\r\n\r\n                intensity += ambColor;\r\n                intensity += max(dot(-normalize(direction), normalize(bumpNormal)), 0.0) * difColor;\r\n\r\n                if (specularLevel != 0.0){\r\n                    vec3 lightVector = normalize(direction);\r\n                    vec3 r = normalize(reflect(lightVector, normalize(bumpNormal)));\r\n                    float s = pow(max(dot(r, vec3(0, 0, 1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                    intensity += specColor * s;\r\n                }\r\n            }\r\n\r\n            void CalcPointLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 position, inout vec4 intensity) {\r\n                float maxVariance = 100.0; // Parameter for Bump Intensity\r\n                float minVariance = maxVariance / 2.0;\r\n\r\n                vec3 bumpNormal = vNormal + normalize(texture2D(normalTex, vUV).rgb * maxVariance - minVariance);\r\n\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                intensity += max(dot(normalize(pos), normalize(bumpNormal)), 0.0) * difColor;\r\n\r\n                if (specularLevel != 0.0){\r\n                    vec3 lightVector = normalize(-pos);  \r\n                    vec3 r = normalize(reflect(lightVector, normalize(bumpNormal)));\r\n                    float s = pow(max(dot(r, vec3(0, 0, 1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                    intensity += specColor * s;\r\n                }\r\n            }\r\n\r\n            void CalcSpotLight(vec4 difColor, vec4 ambColor, vec4 specColor, vec3 position, vec3 direction, float angle, inout vec4 intensity){\r\n                float maxVariance = 100.0; // Parameter for Bump Intensity\r\n                float minVariance = maxVariance / 2.0;\r\n\r\n                vec3 bumpNormal = vNormal + normalize(texture2D(normalTex, vUV).rgb * maxVariance - minVariance);\r\n\r\n                intensity += ambColor;\r\n\r\n                vec3 pos = position - vViewPos;\r\n                float alpha = acos(dot(normalize(pos), normalize(-direction)));\r\n\r\n                if (alpha < angle){\r\n                    intensity += max(dot(normalize(pos), normalize(bumpNormal)), 0.0) * difColor;\r\n\r\n                    if (specularLevel != 0.0){\r\n                        vec3 lightVector = normalize(-pos);  \r\n                        vec3 r = normalize(reflect(lightVector, normalize(bumpNormal)));\r\n                        float s = pow(max(dot(r, vec3(0, 0, 1.0)), 0.0), specularLevel) * shininess;\r\n\r\n                        intensity += specColor * s;\r\n                    }\r\n                }\r\n            }\r\n\r\n            void main()\r\n            {\r\n                vec4 endInt = vec4(0, 0, 0, 0);\r\n\r\n                 for (int i = 0; i < LIGHT_COUNT; i++) {\r\n                    vec4 diffuse = FUSEE_LIGHTS[i].diffuse;\r\n                    vec4 ambient = FUSEE_LIGHTS[i].ambient;\r\n                    vec4 specular = FUSEE_LIGHTS[i].specular;\r\n                    vec3 position = FUSEE_LIGHTS[i].position;\r\n                    vec3 direction = FUSEE_LIGHTS[i].direction;\r\n                    float spotAngle = FUSEE_LIGHTS[i].spotAngle;\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 1.0)\r\n                        CalcDirectLight(diffuse, ambient, specular, direction, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 2.0)\r\n                        CalcPointLight(diffuse, ambient, specular, position, endInt);\r\n\r\n                    if (FUSEE_LIGHTS[i].active == 3.0)\r\n                        CalcSpotLight(diffuse, ambient, specular, position, direction, spotAngle, endInt);\r\n                }\r\n\r\n                gl_FragColor = texture2D(texture1, vUV) * endInt; \r\n            }");


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.SliderConstraint */ 

(function SliderConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.RigidBody)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.CalculateTransforms)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_AnchorInA)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_AnchorInB)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_AngularDepth)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_AngularPos)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_CalculatedTransformA)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_CalculatedTransformB)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_DampingDirAngular)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_DampingDirLin)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_DampingLimAngular)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_DampingLimLin)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_DampingOrthoAngular)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_DampingOrthoLin)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_FrameOffsetA)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_FrameOffsetB)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_LinDepth)) ();
  };
  var $IM10 = function () {
    return ($IM10 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_LinPos)) ();
  };
  var $IM11 = function () {
    return ($IM11 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_LowerAngularLimit)) ();
  };
  var $IM12 = function () {
    return ($IM12 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_LowerLinLimit)) ();
  };
  var $IM13 = function () {
    return ($IM13 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_MaxAngularMotorForce)) ();
  };
  var $IM14 = function () {
    return ($IM14 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_MaxLinMotorForce)) ();
  };
  var $IM15 = function () {
    return ($IM15 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_PoweredAngularMotor)) ();
  };
  var $IM16 = function () {
    return ($IM16 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_PoweredLinMotor)) ();
  };
  var $IM17 = function () {
    return ($IM17 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_RestitutionDirAngular)) ();
  };
  var $IM18 = function () {
    return ($IM18 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_RestitutionDirLin)) ();
  };
  var $IM19 = function () {
    return ($IM19 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_RestitutionLimAngular)) ();
  };
  var $IM1A = function () {
    return ($IM1A = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_RestitutionLimLin)) ();
  };
  var $IM1B = function () {
    return ($IM1B = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_RestitutionOrthoAngular)) ();
  };
  var $IM1C = function () {
    return ($IM1C = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_RestitutionOrthoLin)) ();
  };
  var $IM1D = function () {
    return ($IM1D = JSIL.Memoize($asm03.Fusee.Engine.Common.IRigidBodyImp.get_UserObject)) ();
  };
  var $IM1E = function () {
    return ($IM1E = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyA)) ();
  };
  var $IM1F = function () {
    return ($IM1F = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_RigidBodyB)) ();
  };
  var $IM20 = function () {
    return ($IM20 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_SoftnessDirAngular)) ();
  };
  var $IM21 = function () {
    return ($IM21 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_SoftnessDirLin)) ();
  };
  var $IM22 = function () {
    return ($IM22 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_SoftnessLimAngular)) ();
  };
  var $IM23 = function () {
    return ($IM23 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_SoftnessLimLin)) ();
  };
  var $IM24 = function () {
    return ($IM24 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_SoftnessOrthoAngular)) ();
  };
  var $IM25 = function () {
    return ($IM25 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_SoftnessOrthoLin)) ();
  };
  var $IM26 = function () {
    return ($IM26 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_SolveAngularLimit)) ();
  };
  var $IM27 = function () {
    return ($IM27 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_SolveLinLimit)) ();
  };
  var $IM28 = function () {
    return ($IM28 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_TargetAngularMotorVelocity)) ();
  };
  var $IM29 = function () {
    return ($IM29 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_TargetLinMotorVelocity)) ();
  };
  var $IM2A = function () {
    return ($IM2A = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_UpperAngularLimit)) ();
  };
  var $IM2B = function () {
    return ($IM2B = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_UpperLinLimit)) ();
  };
  var $IM2C = function () {
    return ($IM2C = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_UseFrameOffset)) ();
  };
  var $IM2D = function () {
    return ($IM2D = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.get_UseLinearReferenceFrameA)) ();
  };
  var $IM2E = function () {
    return ($IM2E = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.GetUid)) ();
  };
  var $IM2F = function () {
    return ($IM2F = JSIL.Memoize($asm03.Fusee.Engine.Common.IConstraintImp.get_UserObject)) ();
  };
  var $IM30 = function () {
    return ($IM30 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_DampingDirAngular)) ();
  };
  var $IM31 = function () {
    return ($IM31 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_DampingDirLin)) ();
  };
  var $IM32 = function () {
    return ($IM32 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_DampingLimAngular)) ();
  };
  var $IM33 = function () {
    return ($IM33 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_DampingLimLin)) ();
  };
  var $IM34 = function () {
    return ($IM34 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_DampingOrthoAngular)) ();
  };
  var $IM35 = function () {
    return ($IM35 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_DampingOrthoLin)) ();
  };
  var $IM36 = function () {
    return ($IM36 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_LowerAngularLimit)) ();
  };
  var $IM37 = function () {
    return ($IM37 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_LowerLinLimit)) ();
  };
  var $IM38 = function () {
    return ($IM38 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_MaxAngularMotorForce)) ();
  };
  var $IM39 = function () {
    return ($IM39 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_MaxLinMotorForce)) ();
  };
  var $IM3A = function () {
    return ($IM3A = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_PoweredAngularMotor)) ();
  };
  var $IM3B = function () {
    return ($IM3B = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_PoweredLinMotor)) ();
  };
  var $IM3C = function () {
    return ($IM3C = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_RestitutionDirAngular)) ();
  };
  var $IM3D = function () {
    return ($IM3D = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_RestitutionDirLin)) ();
  };
  var $IM3E = function () {
    return ($IM3E = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_RestitutionLimAngular)) ();
  };
  var $IM3F = function () {
    return ($IM3F = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_RestitutionLimLin)) ();
  };
  var $IM40 = function () {
    return ($IM40 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_RestitutionOrthoAngular)) ();
  };
  var $IM41 = function () {
    return ($IM41 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_RestitutionOrthoLin)) ();
  };
  var $IM42 = function () {
    return ($IM42 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_SoftnessDirAngular)) ();
  };
  var $IM43 = function () {
    return ($IM43 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_SoftnessDirLin)) ();
  };
  var $IM44 = function () {
    return ($IM44 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_SoftnessLimAngular)) ();
  };
  var $IM45 = function () {
    return ($IM45 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_SoftnessLimLin)) ();
  };
  var $IM46 = function () {
    return ($IM46 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_SoftnessOrthoAngular)) ();
  };
  var $IM47 = function () {
    return ($IM47 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_SoftnessOrthoLin)) ();
  };
  var $IM48 = function () {
    return ($IM48 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_TargetAngularMotorVelocity)) ();
  };
  var $IM49 = function () {
    return ($IM49 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_TargetLinMotorVelocity)) ();
  };
  var $IM4A = function () {
    return ($IM4A = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_UpperAngularLimit)) ();
  };
  var $IM4B = function () {
    return ($IM4B = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_UpperLinLimit)) ();
  };
  var $IM4C = function () {
    return ($IM4C = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.set_UseFrameOffset)) ();
  };
  var $IM4D = function () {
    return ($IM4D = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.SetFrames)) ();
  };
  var $IM4E = function () {
    return ($IM4E = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.TestAngularLimits)) ();
  };
  var $IM4F = function () {
    return ($IM4F = JSIL.Memoize($asm03.Fusee.Engine.Common.ISliderConstraintImp.TestLinLimits)) ();
  };


  function SliderConstraint__ctor () {
  }; 

  function SliderConstraint_CalculateTransforms (transA, transB) {
    $IM00().Call(this._iSliderConstraintImp, null, transA.MemberwiseClone(), transB.MemberwiseClone());
  }; 

  function SliderConstraint_get_AnchorInA () {
    return $IM01().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_AnchorInB () {
    return $IM02().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_AngularDepth () {
    return $IM03().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_AngularPos () {
    return $IM04().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_CalculatedTransformA () {
    return $IM05().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_CalculatedTransformB () {
    return $IM06().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_DampingDirAngular () {
    return $IM07().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_DampingDirLin () {
    return $IM08().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_DampingLimAngular () {
    return $IM09().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_DampingLimLin () {
    return $IM0A().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_DampingOrthoAngular () {
    return $IM0B().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_DampingOrthoLin () {
    return $IM0C().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_FrameOffsetA () {
    return $IM0D().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_FrameOffsetB () {
    return $IM0E().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_LinDepth () {
    return $IM0F().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_LinPos () {
    return $IM10().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_LowerAngularLimit () {
    return $IM11().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_LowerLinLimit () {
    return $IM12().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_MaxAngularMotorForce () {
    return $IM13().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_MaxLinMotorForce () {
    return $IM14().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_PoweredAngularMotor () {
    return $IM15().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_PoweredLinMotor () {
    return $IM16().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_RestitutionDirAngular () {
    return $IM17().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_RestitutionDirLin () {
    return $IM18().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_RestitutionLimAngular () {
    return $IM19().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_RestitutionLimLin () {
    return $IM1A().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_RestitutionOrthoAngular () {
    return $IM1B().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_RestitutionOrthoLin () {
    return $IM1C().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_RigidBodyA () {
    var retval = $IM1D().Call($IM1E().Call(this._iSliderConstraintImp, null), null);
    return $T05().$Cast(retval);
  }; 

  function SliderConstraint_get_RigidBodyB () {
    var retval = $IM1D().Call($IM1F().Call(this._iSliderConstraintImp, null), null);
    return $T05().$Cast(retval);
  }; 

  function SliderConstraint_get_SoftnessDirAngular () {
    return $IM20().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_SoftnessDirLin () {
    return $IM21().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_SoftnessLimAngular () {
    return $IM22().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_SoftnessLimLin () {
    return $IM23().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_SoftnessOrthoAngular () {
    return $IM24().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_SoftnessOrthoLin () {
    return $IM25().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_SolveAngularLimit () {
    return $IM26().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_SolveLinLimit () {
    return $IM27().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_TargetAngularMotorVelocity () {
    return $IM28().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_TargetLinMotorVelocity () {
    return $IM29().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_UpperAngularLimit () {
    return $IM2A().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_UpperLinLimit () {
    return $IM2B().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_UseFrameOffset () {
    return $IM2C().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_get_UseLinearReferenceFrameA () {
    return $IM2D().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_GetUid () {
    return $IM2E().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_set_DampingDirAngular (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM30().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_DampingDirLin (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM31().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_DampingLimAngular (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM32().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_DampingLimLin (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM33().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_DampingOrthoAngular (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM34().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_DampingOrthoLin (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM35().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_LowerAngularLimit (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM36().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_LowerLinLimit (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM37().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_MaxAngularMotorForce (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM38().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_MaxLinMotorForce (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM39().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_PoweredAngularMotor (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM3A().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_PoweredLinMotor (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM3B().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_RestitutionDirAngular (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM3C().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_RestitutionDirLin (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM3D().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_RestitutionLimAngular (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM3E().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_RestitutionLimLin (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM3F().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_RestitutionOrthoAngular (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM40().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_RestitutionOrthoLin (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM41().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_SoftnessDirAngular (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM42().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_SoftnessDirLin (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM43().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_SoftnessLimAngular (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM44().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_SoftnessLimLin (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM45().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_SoftnessOrthoAngular (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM46().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_SoftnessOrthoLin (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM47().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_TargetAngularMotorVelocity (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM48().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_TargetLinMotorVelocity (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM49().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_UpperAngularLimit (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM4A().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_UpperLinLimit (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM4B().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_set_UseFrameOffset (value) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM4C().Call(o._iSliderConstraintImp, null, value);
  }; 

  function SliderConstraint_SetFrames (frameA, frameB) {
    var o = $thisType.$Cast($IM2F().Call(this._iSliderConstraintImp, null));
    $IM4D().Call(o._iSliderConstraintImp, null, frameA.MemberwiseClone(), frameB.MemberwiseClone());
  }; 

  function SliderConstraint_TestAngularLimits () {
    $IM4E().Call(this._iSliderConstraintImp, null);
  }; 

  function SliderConstraint_TestLinLimits () {
    $IM4F().Call(this._iSliderConstraintImp, null);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.SliderConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      SliderConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "CalculateTransforms", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4")]), 
      SliderConstraint_CalculateTransforms
    );

    $.Method({Static:false, Public:true }, "get_AnchorInA", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      SliderConstraint_get_AnchorInA
    );

    $.Method({Static:false, Public:true }, "get_AnchorInB", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      SliderConstraint_get_AnchorInB
    );

    $.Method({Static:false, Public:true }, "get_AngularDepth", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_AngularDepth
    );

    $.Method({Static:false, Public:true }, "get_AngularPos", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_AngularPos
    );

    $.Method({Static:false, Public:true }, "get_CalculatedTransformA", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      SliderConstraint_get_CalculatedTransformA
    );

    $.Method({Static:false, Public:true }, "get_CalculatedTransformB", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      SliderConstraint_get_CalculatedTransformB
    );

    $.Method({Static:false, Public:true }, "get_DampingDirAngular", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_DampingDirAngular
    );

    $.Method({Static:false, Public:true }, "get_DampingDirLin", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_DampingDirLin
    );

    $.Method({Static:false, Public:true }, "get_DampingLimAngular", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_DampingLimAngular
    );

    $.Method({Static:false, Public:true }, "get_DampingLimLin", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_DampingLimLin
    );

    $.Method({Static:false, Public:true }, "get_DampingOrthoAngular", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_DampingOrthoAngular
    );

    $.Method({Static:false, Public:true }, "get_DampingOrthoLin", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_DampingOrthoLin
    );

    $.Method({Static:false, Public:true }, "get_FrameOffsetA", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      SliderConstraint_get_FrameOffsetA
    );

    $.Method({Static:false, Public:true }, "get_FrameOffsetB", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      SliderConstraint_get_FrameOffsetB
    );

    $.Method({Static:false, Public:true }, "get_LinDepth", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_LinDepth
    );

    $.Method({Static:false, Public:true }, "get_LinPos", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_LinPos
    );

    $.Method({Static:false, Public:true }, "get_LowerAngularLimit", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_LowerAngularLimit
    );

    $.Method({Static:false, Public:true }, "get_LowerLinLimit", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_LowerLinLimit
    );

    $.Method({Static:false, Public:true }, "get_MaxAngularMotorForce", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_MaxAngularMotorForce
    );

    $.Method({Static:false, Public:true }, "get_MaxLinMotorForce", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_MaxLinMotorForce
    );

    $.Method({Static:false, Public:true }, "get_PoweredAngularMotor", 
      JSIL.MethodSignature.Return($.Boolean), 
      SliderConstraint_get_PoweredAngularMotor
    );

    $.Method({Static:false, Public:true }, "get_PoweredLinMotor", 
      JSIL.MethodSignature.Return($.Boolean), 
      SliderConstraint_get_PoweredLinMotor
    );

    $.Method({Static:false, Public:true }, "get_RestitutionDirAngular", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_RestitutionDirAngular
    );

    $.Method({Static:false, Public:true }, "get_RestitutionDirLin", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_RestitutionDirLin
    );

    $.Method({Static:false, Public:true }, "get_RestitutionLimAngular", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_RestitutionLimAngular
    );

    $.Method({Static:false, Public:true }, "get_RestitutionLimLin", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_RestitutionLimLin
    );

    $.Method({Static:false, Public:true }, "get_RestitutionOrthoAngular", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_RestitutionOrthoAngular
    );

    $.Method({Static:false, Public:true }, "get_RestitutionOrthoLin", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_RestitutionOrthoLin
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyA", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      SliderConstraint_get_RigidBodyA
    );

    $.Method({Static:false, Public:true }, "get_RigidBodyB", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RigidBody")), 
      SliderConstraint_get_RigidBodyB
    );

    $.Method({Static:false, Public:true }, "get_SoftnessDirAngular", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_SoftnessDirAngular
    );

    $.Method({Static:false, Public:true }, "get_SoftnessDirLin", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_SoftnessDirLin
    );

    $.Method({Static:false, Public:true }, "get_SoftnessLimAngular", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_SoftnessLimAngular
    );

    $.Method({Static:false, Public:true }, "get_SoftnessLimLin", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_SoftnessLimLin
    );

    $.Method({Static:false, Public:true }, "get_SoftnessOrthoAngular", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_SoftnessOrthoAngular
    );

    $.Method({Static:false, Public:true }, "get_SoftnessOrthoLin", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_SoftnessOrthoLin
    );

    $.Method({Static:false, Public:true }, "get_SolveAngularLimit", 
      JSIL.MethodSignature.Return($.Boolean), 
      SliderConstraint_get_SolveAngularLimit
    );

    $.Method({Static:false, Public:true }, "get_SolveLinLimit", 
      JSIL.MethodSignature.Return($.Boolean), 
      SliderConstraint_get_SolveLinLimit
    );

    $.Method({Static:false, Public:true }, "get_TargetAngularMotorVelocity", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_TargetAngularMotorVelocity
    );

    $.Method({Static:false, Public:true }, "get_TargetLinMotorVelocity", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_TargetLinMotorVelocity
    );

    $.Method({Static:false, Public:true }, "get_UpperAngularLimit", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_UpperAngularLimit
    );

    $.Method({Static:false, Public:true }, "get_UpperLinLimit", 
      JSIL.MethodSignature.Return($.Single), 
      SliderConstraint_get_UpperLinLimit
    );

    $.Method({Static:false, Public:true }, "get_UseFrameOffset", 
      JSIL.MethodSignature.Return($.Boolean), 
      SliderConstraint_get_UseFrameOffset
    );

    $.Method({Static:false, Public:true }, "get_UseLinearReferenceFrameA", 
      JSIL.MethodSignature.Return($.Boolean), 
      SliderConstraint_get_UseLinearReferenceFrameA
    );

    $.Method({Static:false, Public:true }, "GetUid", 
      JSIL.MethodSignature.Return($.Int32), 
      SliderConstraint_GetUid
    );

    $.Method({Static:false, Public:true }, "set_DampingDirAngular", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_DampingDirAngular
    );

    $.Method({Static:false, Public:true }, "set_DampingDirLin", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_DampingDirLin
    );

    $.Method({Static:false, Public:true }, "set_DampingLimAngular", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_DampingLimAngular
    );

    $.Method({Static:false, Public:true }, "set_DampingLimLin", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_DampingLimLin
    );

    $.Method({Static:false, Public:true }, "set_DampingOrthoAngular", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_DampingOrthoAngular
    );

    $.Method({Static:false, Public:true }, "set_DampingOrthoLin", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_DampingOrthoLin
    );

    $.Method({Static:false, Public:true }, "set_LowerAngularLimit", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_LowerAngularLimit
    );

    $.Method({Static:false, Public:true }, "set_LowerLinLimit", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_LowerLinLimit
    );

    $.Method({Static:false, Public:true }, "set_MaxAngularMotorForce", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_MaxAngularMotorForce
    );

    $.Method({Static:false, Public:true }, "set_MaxLinMotorForce", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_MaxLinMotorForce
    );

    $.Method({Static:false, Public:true }, "set_PoweredAngularMotor", 
      JSIL.MethodSignature.Action($.Boolean), 
      SliderConstraint_set_PoweredAngularMotor
    );

    $.Method({Static:false, Public:true }, "set_PoweredLinMotor", 
      JSIL.MethodSignature.Action($.Boolean), 
      SliderConstraint_set_PoweredLinMotor
    );

    $.Method({Static:false, Public:true }, "set_RestitutionDirAngular", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_RestitutionDirAngular
    );

    $.Method({Static:false, Public:true }, "set_RestitutionDirLin", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_RestitutionDirLin
    );

    $.Method({Static:false, Public:true }, "set_RestitutionLimAngular", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_RestitutionLimAngular
    );

    $.Method({Static:false, Public:true }, "set_RestitutionLimLin", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_RestitutionLimLin
    );

    $.Method({Static:false, Public:true }, "set_RestitutionOrthoAngular", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_RestitutionOrthoAngular
    );

    $.Method({Static:false, Public:true }, "set_RestitutionOrthoLin", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_RestitutionOrthoLin
    );

    $.Method({Static:false, Public:true }, "set_SoftnessDirAngular", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_SoftnessDirAngular
    );

    $.Method({Static:false, Public:true }, "set_SoftnessDirLin", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_SoftnessDirLin
    );

    $.Method({Static:false, Public:true }, "set_SoftnessLimAngular", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_SoftnessLimAngular
    );

    $.Method({Static:false, Public:true }, "set_SoftnessLimLin", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_SoftnessLimLin
    );

    $.Method({Static:false, Public:true }, "set_SoftnessOrthoAngular", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_SoftnessOrthoAngular
    );

    $.Method({Static:false, Public:true }, "set_SoftnessOrthoLin", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_SoftnessOrthoLin
    );

    $.Method({Static:false, Public:true }, "set_TargetAngularMotorVelocity", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_TargetAngularMotorVelocity
    );

    $.Method({Static:false, Public:true }, "set_TargetLinMotorVelocity", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_TargetLinMotorVelocity
    );

    $.Method({Static:false, Public:true }, "set_UpperAngularLimit", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_UpperAngularLimit
    );

    $.Method({Static:false, Public:true }, "set_UpperLinLimit", 
      JSIL.MethodSignature.Action($.Single), 
      SliderConstraint_set_UpperLinLimit
    );

    $.Method({Static:false, Public:true }, "set_UseFrameOffset", 
      JSIL.MethodSignature.Action($.Boolean), 
      SliderConstraint_set_UseFrameOffset
    );

    $.Method({Static:false, Public:true }, "SetFrames", 
      new JSIL.MethodSignature(null, [$asm09.TypeRef("Fusee.Math.Core.float4x4"), $asm09.TypeRef("Fusee.Math.Core.float4x4")]), 
      SliderConstraint_SetFrames
    );

    $.Method({Static:false, Public:true }, "TestAngularLimits", 
      JSIL.MethodSignature.Void, 
      SliderConstraint_TestAngularLimits
    );

    $.Method({Static:false, Public:true }, "TestLinLimits", 
      JSIL.MethodSignature.Void, 
      SliderConstraint_TestLinLimits
    );

    $.Field({Static:false, Public:false}, "_iSliderConstraintImp", $asm03.TypeRef("Fusee.Engine.Common.ISliderConstraintImp"));

    $.Property({Static:false, Public:true }, "AnchorInA", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "AnchorInB", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "AngularDepth", $.Single);

    $.Property({Static:false, Public:true }, "AngularPos", $.Single);

    $.Property({Static:false, Public:true }, "CalculatedTransformA", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "CalculatedTransformB", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "DampingDirAngular", $.Single);

    $.Property({Static:false, Public:true }, "DampingDirLin", $.Single);

    $.Property({Static:false, Public:true }, "DampingLimAngular", $.Single);

    $.Property({Static:false, Public:true }, "DampingLimLin", $.Single);

    $.Property({Static:false, Public:true }, "DampingOrthoAngular", $.Single);

    $.Property({Static:false, Public:true }, "DampingOrthoLin", $.Single);

    $.Property({Static:false, Public:true }, "FrameOffsetA", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "FrameOffsetB", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "LinDepth", $.Single);

    $.Property({Static:false, Public:true }, "LinPos", $.Single);

    $.Property({Static:false, Public:true }, "LowerAngularLimit", $.Single);

    $.Property({Static:false, Public:true }, "LowerLinLimit", $.Single);

    $.Property({Static:false, Public:true }, "MaxAngularMotorForce", $.Single);

    $.Property({Static:false, Public:true }, "MaxLinMotorForce", $.Single);

    $.Property({Static:false, Public:true }, "PoweredAngularMotor", $.Boolean);

    $.Property({Static:false, Public:true }, "PoweredLinMotor", $.Boolean);

    $.Property({Static:false, Public:true }, "RestitutionDirAngular", $.Single);

    $.Property({Static:false, Public:true }, "RestitutionDirLin", $.Single);

    $.Property({Static:false, Public:true }, "RestitutionLimAngular", $.Single);

    $.Property({Static:false, Public:true }, "RestitutionLimLin", $.Single);

    $.Property({Static:false, Public:true }, "RestitutionOrthoAngular", $.Single);

    $.Property({Static:false, Public:true }, "RestitutionOrthoLin", $.Single);

    $.Property({Static:false, Public:true }, "SoftnessDirAngular", $.Single);

    $.Property({Static:false, Public:true }, "SoftnessDirLin", $.Single);

    $.Property({Static:false, Public:true }, "SoftnessLimAngular", $.Single);

    $.Property({Static:false, Public:true }, "SoftnessLimLin", $.Single);

    $.Property({Static:false, Public:true }, "SoftnessOrthoAngular", $.Single);

    $.Property({Static:false, Public:true }, "SoftnessOrthoLin", $.Single);

    $.Property({Static:false, Public:true }, "SolveAngularLimit", $.Boolean);

    $.Property({Static:false, Public:true }, "SolveLinLimit", $.Boolean);

    $.Property({Static:false, Public:true }, "TargetAngularMotorVelocity", $.Single);

    $.Property({Static:false, Public:true }, "TargetLinMotorVelocity", $.Single);

    $.Property({Static:false, Public:true }, "UpperAngularLimit", $.Single);

    $.Property({Static:false, Public:true }, "UpperLinLimit", $.Single);

    $.Property({Static:false, Public:true }, "UseFrameOffset", $.Boolean);

    $.Property({Static:false, Public:true }, "UseLinearReferenceFrameA", $.Boolean);

    $.Property({Static:false, Public:true }, "RigidBodyA", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));

    $.Property({Static:false, Public:true }, "RigidBodyB", $asm04.TypeRef("Fusee.Engine.Core.RigidBody"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.SphereShape */ 

(function SphereShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISphereShapeImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_LocalScaling)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISphereShapeImp.get_Radius)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.ISphereShapeImp.set_Radius)) ();
  };


  function SphereShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function SphereShape_get_LocalScaling () {
    return $IM00().Call(this._sphereShapeImp, null);
  }; 

  function SphereShape_get_Margin () {
    return $IM01().Call(this._sphereShapeImp, null);
  }; 

  function SphereShape_get_Radius () {
    return $IM02().Call(this._sphereShapeImp, null);
  }; 

  function SphereShape_set_LocalScaling (value) {
    var o = $thisType.$Cast($IM03().Call(this._sphereShapeImp, null));
    (o._sphereShapeImp.LocalScaling = value.MemberwiseClone());
  }; 

  function SphereShape_set_Margin (value) {
    var o = $thisType.$Cast($IM03().Call(this._sphereShapeImp, null));
    $IM04().Call(o._sphereShapeImp, null, value);
  }; 

  function SphereShape_set_Radius (value) {
    var o = $thisType.$Cast($IM03().Call(this._sphereShapeImp, null));
    $IM05().Call(o._sphereShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.SphereShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      SphereShape__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_LocalScaling", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      SphereShape_get_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      SphereShape_get_Margin
    );

    $.Method({Static:false, Public:true }, "get_Radius", 
      JSIL.MethodSignature.Return($.Single), 
      SphereShape_get_Radius
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_LocalScaling", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float3")), 
      SphereShape_set_LocalScaling
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      SphereShape_set_Margin
    );

    $.Method({Static:false, Public:true }, "set_Radius", 
      JSIL.MethodSignature.Action($.Single), 
      SphereShape_set_Radius
    );

    $.Field({Static:false, Public:false}, "_sphereShapeImp", $asm03.TypeRef("Fusee.Engine.Common.ISphereShapeImp"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);

    $.Property({Static:false, Public:true , Virtual:true }, "LocalScaling", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "Radius", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.StaticPlaneShape */ 

(function StaticPlaneShape$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.CollisionShape)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IStaticPlaneShapeImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_Margin)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IStaticPlaneShapeImp.get_PlaneConstant)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IStaticPlaneShapeImp.get_PlaneNormal)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.get_UserObject)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.ICollisionShapeImp.set_Margin)) ();
  };


  function StaticPlaneShape__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function StaticPlaneShape_get_Margin () {
    return $IM00().Call(this._staticPlaneShapeImp, null);
  }; 

  function StaticPlaneShape_get_PlaneConstant () {
    return $IM01().Call(this._staticPlaneShapeImp, null);
  }; 

  function StaticPlaneShape_get_PlaneNormal () {
    return $IM02().Call(this._staticPlaneShapeImp, null);
  }; 

  function StaticPlaneShape_set_Margin (value) {
    var o = $thisType.$Cast($IM03().Call(this._staticPlaneShapeImp, null));
    $IM04().Call(o._staticPlaneShapeImp, null, value);
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.CollisionShape"), 
      Name: "Fusee.Engine.Core.StaticPlaneShape", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      StaticPlaneShape__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Margin", 
      JSIL.MethodSignature.Return($.Single), 
      StaticPlaneShape_get_Margin
    );

    $.Method({Static:false, Public:true }, "get_PlaneConstant", 
      JSIL.MethodSignature.Return($.Single), 
      StaticPlaneShape_get_PlaneConstant
    );

    $.Method({Static:false, Public:true }, "get_PlaneNormal", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float3")), 
      StaticPlaneShape_get_PlaneNormal
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Margin", 
      JSIL.MethodSignature.Action($.Single), 
      StaticPlaneShape_set_Margin
    );

    $.Field({Static:false, Public:false}, "_staticPlaneShapeImp", $asm03.TypeRef("Fusee.Engine.Common.IStaticPlaneShapeImp"));

    $.Property({Static:false, Public:true }, "PlaneConstant", $.Single);

    $.Property({Static:false, Public:true }, "PlaneNormal", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true , Virtual:true }, "Margin", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Network */ 

(function Network$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ConnectionUpdateEvent)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Collections.ObjectModel.Collection$b1.Of($asm03.Fusee.Engine.Common.INetworkConnection))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkMsg)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm03.Fusee.Engine.Common.INetworkMsg))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm0E.System.Byte))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm03.Fusee.Engine.Common.MessageDelivery)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm03.Fusee.Engine.Common.NetConfigValues)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm01.Fusee.Base.Core.Diagnostics)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm04.Fusee.Engine.Core.DummyNetworkImp)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm03.Fusee.Engine.Common.NetStatusValues)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.ObjectModel.Collection$b1.Of($asm03.Fusee.Engine.Common.INetworkConnection), [$asm0E.TypeRef("System.Collections.Generic.IList`1", [$asm03.TypeRef("Fusee.Engine.Common.INetworkConnection")])]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.add_ConnectionUpdate)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.CloseConnection)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.CloseDevices)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.get_Config)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.get_Connections)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.get_IncomingMsg)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.GetLocalIp)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.get_Status)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.OnUpdateFrame)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.OpenConnection)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.remove_ConnectionUpdate)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.SendDiscoveryMessage)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.SendMessage)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.set_Config)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.set_Status)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp.StartPeer)) ();
  };


  function Network__ctor () {
  }; 

  function Network_add_OnConnectionUpdate (value) {
    $IM00().Call(this._networkImp, null, value);
  }; 

  function Network_CloseConnection () {
    $IM01().Call(this._networkImp, null);
  }; 

  function Network_CloseDevice () {
    $IM02().Call(this._networkImp, null);
  }; 

  function Network_Dispose () {
    $thisType._instance = null;
  }; 


  function Network_get_Config () {
    return $IM03().Call(this._networkImp, null);
  }; 

  function Network_get_Connections () {
    return $S00().Construct($IM04().Call(this._networkImp, null));
  }; 

  function Network_get_IncomingMsg () {
    var msg = this.FirstMessage();
    var flag = msg !== null;
    if (flag) {
      ($IM05().Call(this._networkImp, null)).Remove(msg);
    }
    return msg;
  }; 

  function Network_get_IncomingMsgCount () {
    return ($IM05().Call(this._networkImp, null)).get_Count();
  }; 

  function Network_get_Instance () {
    var arg_15_0 = null;
    if ((arg_15_0 = $thisType._instance) === null) {
      arg_15_0 = $thisType._instance = new $thisType();
    }
    return arg_15_0;
  }; 

  function Network_get_LocalIP () {
    return $IM06().Call(this._networkImp, null);
  }; 

  function Network_get_Status () {
    return $IM07().Call(this._networkImp, null);
  }; 

  function Network_OnUpdateFrame () {
    $IM08().Call(this._networkImp, null);
  }; 

  function Network_OpenConnection$00 (host) {
    this.OpenConnection(host, this.get_Config().DefaultPort);
  }; 

  function Network_OpenConnection$01 (port) {
    this.OpenConnection($T06().Empty, port);
  }; 

  function Network_OpenConnection$02 (host, port) {
    $IM09().Call(this._networkImp, null, this.get_Config().SysType, host, port);
  }; 

  function Network_remove_OnConnectionUpdate (value) {
    $IM0A().Call(this._networkImp, null, value);
  }; 

  function Network_SendDiscoveryMessage$03 () {
    $IM0B().Call(this._networkImp, null, this.get_Config().DefaultPort);
  }; 

  function Network_SendDiscoveryMessage$04 (port) {
    $IM0B().Call(this._networkImp, null, port);
  }; 

  function Network_SendMessage$05 (msg) {
    return this.SendMessage(msg, $T09().ReliableOrdered, 0);
  }; 

  function Network_SendMessage$06 (msg, msgDelivery, channelID) {
    return $IM0C().Call(this._networkImp, null, msg, msgDelivery, channelID);
  }; 

  function Network_set_Config (value) {
    $IM0D().Call(this._networkImp, null, value);
  }; 

  function Network_set_NetworkImp (value) {
    if (value === null) {
      $T0B().Log("WARNING: No Network implementation set. To enable Network functionality inject an appropriate implementation of INetworkImp in your platform specific application main module.");
      this._networkImp = new ($T0C())();
    } else {
      this._networkImp = value;
    }
  }; 

  function Network_set_Status (value) {
    $IM0E().Call(this._networkImp, null, value);
  }; 

  function Network_StartPeer$07 () {
    this.StartPeer(this.get_Config().DefaultPort);
  }; 

  function Network_StartPeer$08 (port) {
    $IM0F().Call(this._networkImp, null, port);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Network", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Network__ctor
    );

    $.Method({Static:false, Public:true }, "add_OnConnectionUpdate", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.ConnectionUpdateEvent")), 
      Network_add_OnConnectionUpdate
    );

    $.Method({Static:false, Public:true }, "CloseConnection", 
      JSIL.MethodSignature.Void, 
      Network_CloseConnection
    );

    $.Method({Static:false, Public:true }, "CloseDevice", 
      JSIL.MethodSignature.Void, 
      Network_CloseDevice
    );

    $.Method({Static:false, Public:false}, "Dispose", 
      JSIL.MethodSignature.Void, 
      Network_Dispose
    );

    $.ExternalMethod({Static:false, Public:false}, "FirstMessage", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.INetworkMsg"))
    );

    $.Method({Static:false, Public:true }, "get_Config", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.NetConfigValues")), 
      Network_get_Config
    );

    $.Method({Static:false, Public:true }, "get_Connections", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.ObjectModel.Collection`1", [$asm03.TypeRef("Fusee.Engine.Common.INetworkConnection")])), 
      Network_get_Connections
    );

    $.Method({Static:false, Public:true }, "get_IncomingMsg", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.INetworkMsg")), 
      Network_get_IncomingMsg
    );

    $.Method({Static:false, Public:true }, "get_IncomingMsgCount", 
      JSIL.MethodSignature.Return($.Int32), 
      Network_get_IncomingMsgCount
    );

    $.Method({Static:true , Public:true }, "get_Instance", 
      JSIL.MethodSignature.Return($.Type), 
      Network_get_Instance
    );

    $.Method({Static:false, Public:true }, "get_LocalIP", 
      JSIL.MethodSignature.Return($.String), 
      Network_get_LocalIP
    );

    $.Method({Static:false, Public:true }, "get_Status", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.NetStatusValues")), 
      Network_get_Status
    );

    $.Method({Static:false, Public:false}, "OnUpdateFrame", 
      JSIL.MethodSignature.Void, 
      Network_OnUpdateFrame
    );

    $.Method({Static:false, Public:true }, "OpenConnection", 
      JSIL.MethodSignature.Action($.String), 
      Network_OpenConnection$00
    );

    $.Method({Static:false, Public:true }, "OpenConnection", 
      JSIL.MethodSignature.Action($.Int32), 
      Network_OpenConnection$01
    );

    $.Method({Static:false, Public:true }, "OpenConnection", 
      new JSIL.MethodSignature(null, [$.String, $.Int32]), 
      Network_OpenConnection$02
    );

    $.Method({Static:false, Public:true }, "remove_OnConnectionUpdate", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.ConnectionUpdateEvent")), 
      Network_remove_OnConnectionUpdate
    );

    $.Method({Static:false, Public:true }, "SendDiscoveryMessage", 
      JSIL.MethodSignature.Void, 
      Network_SendDiscoveryMessage$03
    );

    $.Method({Static:false, Public:true }, "SendDiscoveryMessage", 
      JSIL.MethodSignature.Action($.Int32), 
      Network_SendDiscoveryMessage$04
    );

    $.Method({Static:false, Public:true }, "SendMessage", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("System.Array", [$.Byte])]), 
      Network_SendMessage$05
    );

    $.Method({Static:false, Public:true }, "SendMessage", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $asm03.TypeRef("Fusee.Engine.Common.MessageDelivery"), 
          $.Int32
        ]), 
      Network_SendMessage$06
    );

    $.Method({Static:false, Public:true }, "set_Config", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.NetConfigValues")), 
      Network_set_Config
    );

    $.Method({Static:false, Public:false}, "set_NetworkImp", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.INetworkImp")), 
      Network_set_NetworkImp
    );

    $.Method({Static:false, Public:true }, "set_Status", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.NetStatusValues")), 
      Network_set_Status
    );

    $.Method({Static:false, Public:true }, "StartPeer", 
      JSIL.MethodSignature.Void, 
      Network_StartPeer$07
    );

    $.Method({Static:false, Public:true }, "StartPeer", 
      JSIL.MethodSignature.Action($.Int32), 
      Network_StartPeer$08
    );

    $.Field({Static:true , Public:false}, "_instance", $.Type);

    $.Field({Static:false, Public:false}, "_networkImp", $asm03.TypeRef("Fusee.Engine.Common.INetworkImp"));

    $.Property({Static:false, Public:false}, "NetworkImp", $asm03.TypeRef("Fusee.Engine.Common.INetworkImp"));

    $.Property({Static:false, Public:true }, "Status", $asm03.TypeRef("Fusee.Engine.Common.NetStatusValues"));

    $.Property({Static:false, Public:true }, "Config", $asm03.TypeRef("Fusee.Engine.Common.NetConfigValues"));

    $.Property({Static:false, Public:true }, "Connections", $asm0E.TypeRef("System.Collections.ObjectModel.Collection`1", [$asm03.TypeRef("Fusee.Engine.Common.INetworkConnection")]));

    $.Property({Static:false, Public:true }, "LocalIP", $.String);

    $.Property({Static:false, Public:true }, "IncomingMsgCount", $.Int32);

    $.Property({Static:false, Public:true }, "IncomingMsg", $asm03.TypeRef("Fusee.Engine.Common.INetworkMsg"));

    $.Property({Static:true , Public:true }, "Instance", $.Type);

    $.Event({Static:false, Public:true }, "OnConnectionUpdate", $asm03.TypeRef("Fusee.Engine.Common.ConnectionUpdateEvent"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.DummyNetworkImp */ 

(function DummyNetworkImp$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.ConnectionUpdateEvent)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Delegate)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Threading.Interlocked)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.SysType)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize(System.Array.Of($asm0E.System.Byte))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm03.Fusee.Engine.Common.MessageDelivery)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm03.Fusee.Engine.Common.NetConfigValues)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm03.Fusee.Engine.Common.NetStatusValues)) ();
  };


  function DummyNetworkImp__ctor () {
  }; 

  function DummyNetworkImp_add_ConnectionUpdate (value) {
    var connectionUpdateEvent = this.ConnectionUpdate;

    do {
      var connectionUpdateEvent2 = connectionUpdateEvent;
      var value2 = $T01().Combine(connectionUpdateEvent2, value);
      connectionUpdateEvent = $T02().CompareExchange$b1($T00())(/* ref */ new JSIL.MemberReference(this, "ConnectionUpdate"), value2, connectionUpdateEvent2);
    } while (connectionUpdateEvent !== connectionUpdateEvent2);
  }; 

  function DummyNetworkImp_CloseConnection () {
  }; 

  function DummyNetworkImp_CloseDevices () {
  }; 

  function DummyNetworkImp_get_Config () {
    return this.DummyNetworkImp$Config$value;
  }; 

  function DummyNetworkImp_get_Connections () {
    return this.DummyNetworkImp$Connections$value;
  }; 

  function DummyNetworkImp_get_IncomingMsg () {
    return this.DummyNetworkImp$IncomingMsg$value;
  }; 

  function DummyNetworkImp_get_Status () {
    return this.DummyNetworkImp$Status$value;
  }; 

  function DummyNetworkImp_GetLocalIp () {
    return "";
  }; 

  function DummyNetworkImp_OnUpdateFrame () {
  }; 

  function DummyNetworkImp_OpenConnection (type, host, port) {
    return false;
  }; 

  function DummyNetworkImp_remove_ConnectionUpdate (value) {
    var connectionUpdateEvent = this.ConnectionUpdate;

    do {
      var connectionUpdateEvent2 = connectionUpdateEvent;
      var value2 = $T01().Remove(connectionUpdateEvent2, value);
      connectionUpdateEvent = $T02().CompareExchange$b1($T00())(/* ref */ new JSIL.MemberReference(this, "ConnectionUpdate"), value2, connectionUpdateEvent2);
    } while (connectionUpdateEvent !== connectionUpdateEvent2);
  }; 

  function DummyNetworkImp_SendDiscoveryMessage (port) {
  }; 

  function DummyNetworkImp_SendMessage (msg, msgDelivery, msgChannel) {
    return false;
  }; 

  function DummyNetworkImp_set_Config (value) {
    this.DummyNetworkImp$Config$value = value;
  }; 

  function DummyNetworkImp_set_Status (value) {
    this.DummyNetworkImp$Status$value = value;
  }; 

  function DummyNetworkImp_StartPeer (port) {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.DummyNetworkImp", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      DummyNetworkImp__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "add_ConnectionUpdate", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.ConnectionUpdateEvent")), 
      DummyNetworkImp_add_ConnectionUpdate
    );

    $.Method({Static:false, Public:true , Virtual:true }, "CloseConnection", 
      JSIL.MethodSignature.Void, 
      DummyNetworkImp_CloseConnection
    );

    $.Method({Static:false, Public:true , Virtual:true }, "CloseDevices", 
      JSIL.MethodSignature.Void, 
      DummyNetworkImp_CloseDevices
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Config", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.NetConfigValues")), 
      DummyNetworkImp_get_Config
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Connections", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.List`1", [$asm03.TypeRef("Fusee.Engine.Common.INetworkConnection")])), 
      DummyNetworkImp_get_Connections
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_IncomingMsg", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.List`1", [$asm03.TypeRef("Fusee.Engine.Common.INetworkMsg")])), 
      DummyNetworkImp_get_IncomingMsg
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Status", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.NetStatusValues")), 
      DummyNetworkImp_get_Status
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetLocalIp", 
      JSIL.MethodSignature.Return($.String), 
      DummyNetworkImp_GetLocalIp
    );

    $.Method({Static:false, Public:true , Virtual:true }, "OnUpdateFrame", 
      JSIL.MethodSignature.Void, 
      DummyNetworkImp_OnUpdateFrame
    );

    $.Method({Static:false, Public:true , Virtual:true }, "OpenConnection", 
      new JSIL.MethodSignature($.Boolean, [
          $asm03.TypeRef("Fusee.Engine.Common.SysType"), $.String, 
          $.Int32
        ]), 
      DummyNetworkImp_OpenConnection
    );

    $.Method({Static:false, Public:true , Virtual:true }, "remove_ConnectionUpdate", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.ConnectionUpdateEvent")), 
      DummyNetworkImp_remove_ConnectionUpdate
    );

    $.Method({Static:false, Public:true , Virtual:true }, "SendDiscoveryMessage", 
      JSIL.MethodSignature.Action($.Int32), 
      DummyNetworkImp_SendDiscoveryMessage
    );

    $.Method({Static:false, Public:true , Virtual:true }, "SendMessage", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $asm03.TypeRef("Fusee.Engine.Common.MessageDelivery"), 
          $.Int32
        ]), 
      DummyNetworkImp_SendMessage
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Config", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.NetConfigValues")), 
      DummyNetworkImp_set_Config
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_Status", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.NetStatusValues")), 
      DummyNetworkImp_set_Status
    );

    $.Method({Static:false, Public:true , Virtual:true }, "StartPeer", 
      JSIL.MethodSignature.Action($.Int32), 
      DummyNetworkImp_StartPeer
    );

    $.Field({Static:false, Public:false}, "DummyNetworkImp$Config$value", $asm03.TypeRef("Fusee.Engine.Common.NetConfigValues"));

    $.Field({Static:false, Public:false}, "DummyNetworkImp$Status$value", $asm03.TypeRef("Fusee.Engine.Common.NetStatusValues"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "DummyNetworkImp$Connections$value", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm03.TypeRef("Fusee.Engine.Common.INetworkConnection")]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "DummyNetworkImp$IncomingMsg$value", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm03.TypeRef("Fusee.Engine.Common.INetworkMsg")]));

    $.Field({Static:false, Public:false}, "ConnectionUpdate", $asm03.TypeRef("Fusee.Engine.Common.ConnectionUpdateEvent"));

    $.Property({Static:false, Public:true , Virtual:true }, "Config", $asm03.TypeRef("Fusee.Engine.Common.NetConfigValues"));

    $.Property({Static:false, Public:true , Virtual:true }, "Status", $asm03.TypeRef("Fusee.Engine.Common.NetStatusValues"));

    $.Property({Static:false, Public:true , Virtual:true }, "Connections", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm03.TypeRef("Fusee.Engine.Common.INetworkConnection")]));

    $.Property({Static:false, Public:true , Virtual:true }, "IncomingMsg", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm03.TypeRef("Fusee.Engine.Common.INetworkMsg")]));

    $.Event({Static:false, Public:true , Virtual:true }, "ConnectionUpdate", $asm03.TypeRef("Fusee.Engine.Common.ConnectionUpdateEvent"));

    $.ImplementInterfaces(
      /* 0 */ $asm03.TypeRef("Fusee.Engine.Common.INetworkImp")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ParticleData */ 

(function ParticleData$Members () {
  var $, $thisType;

  function ParticleData__ctor () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.ParticleData", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ParticleData__ctor
    );

    $.Field({Static:false, Public:true }, "Position", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "Velocity", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "Gravity", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "Life", $.Int32);

    $.Field({Static:false, Public:true }, "MaxSize", $.Single);

    $.Field({Static:false, Public:true }, "MinSize", $.Single);

    $.Field({Static:false, Public:true }, "Rotation", $.Single);

    $.Field({Static:false, Public:true }, "Transparency", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ParticleEmitter */ 

(function ParticleEmitter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Double)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.ParticleData))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Random)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt16))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.UInt16)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm04.Fusee.Engine.Core.ParticleData)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.ParticleData), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Random, null))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float3, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.ParticleData")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float3, [$asm0E.System.Single, $asm09.Fusee.Math.Core.float3]))) ();
  };


  function ParticleEmitter__ctor (myCount, myLifeMin, myLifeMax, myMinSize, myMaxSize, myRotation, myTransparency, myRandPosX, myRandPosY, myRandPosZ, myRandVelX, myRandVelY, myRandVelZ, myGravityX, myGravityY, myGravityZ) {
    this.VsSimpleTexture = "\r\n            /* Copies incoming vertex color without change.\r\n             * Applies the transformation matrix to vertex position.\r\n             */\r\n\r\n            attribute vec4 fuColor;\r\n            attribute vec3 fuVertex;\r\n            attribute vec3 fuNormal;\r\n            attribute vec2 fuUV;\r\n\r\n            varying vec4 vColor;\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n            varying float vTransparency;\r\n        \r\n            uniform mat4 FUSEE_MVP;\r\n            uniform mat4 FUSEE_MV;\r\n            uniform mat4 FUSEE_P;\r\n            uniform mat4 FUSEE_ITMV;\r\n            \r\n            uniform float timer;\r\n            attribute vec4 position;\r\n            varying vec2 texcoord;\r\n            varying float fade_factor;\r\n\r\n            void main()\r\n            {\r\n     \r\n                vec4 vPos = FUSEE_MV * vec4(fuVertex, 1.0);//umwandlung in Kamerakoordinaten\r\n               \r\n                //Offset rotieren um fuNormal.x\r\n                vec2 offset = fuUV;\r\n                offset.x  = fuUV.x*cos(fuNormal.x) - fuUV.y*sin(fuNormal.x);\r\n                offset.y =  fuUV.y*cos(fuNormal.x) + fuUV.x*sin(fuNormal.x);\r\n                vPos = vPos + vec4(100.0*offset, 0, 1.0);   //Offset  aus Partikelzentrum in Partikel-Eckpunkt          \r\n                gl_Position = FUSEE_P * vPos; //Perspektive-Projektion\r\n                vNormal = mat3(FUSEE_ITMV[0].xyz, FUSEE_ITMV[1].xyz, FUSEE_ITMV[2].xyz) * fuNormal;\r\n                vNormal = vec3(0, 0, 1);\r\n                vUV.x = (fuUV.x <= 0.0) ? 0.0 : 1.0;\r\n                vUV.y = (fuUV.y <= 0.0) ? 0.0 : 1.0;\r\n\r\n                vTransparency = fuNormal.y;\r\n            }";
    this.PsSimpleTexture = "\r\n            /* Copies incoming fragment color without change. */\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n\r\n            // The parameter required for the texturing process\r\n            uniform sampler2D texture1;\r\n            uniform vec4 vColor;\r\n            varying vec3 vNormal;\r\n            varying float vTransparency;\r\n\r\n            // The parameter holding the UV-Coordinates of the texture\r\n            varying vec2 vUV;\r\n\r\n            void main()\r\n            {    \r\n              // The most basic texturing function, expecting the above mentioned parameters  \r\n             vec4 AlphaColor = vec4(1.0, 1.0, 1.0, vTransparency);\r\n             gl_FragColor = texture2D(texture1, vUV)*AlphaColor;        \r\n            }";
    this.ParticleMesh = new ($T03())();
    this._particleList = $S00().Construct();
    this._customCount = (myCount | 0);
    this._customLifeMin = (myLifeMin | 0);
    this._customLifeMax = (myLifeMax | 0);
    this._customMinSize = +myMinSize;
    this._customMaxSize = +myMaxSize;
    this._customRotation = +myRotation;
    this._customTransparency = +myTransparency;
    this._customRandPosX = myRandPosX;
    this._customRandPosY = myRandPosY;
    this._customRandPosZ = myRandPosZ;
    this._customRandVelX = +myRandVelX;
    this._customRandVelY = +myRandVelY;
    this._customRandVelZ = +myRandVelZ;
    this._customGravityX = +myGravityX;
    this._customGravityY = +myGravityY;
    this._customGravityZ = +myGravityZ;
  }; 

  function ParticleEmitter_GenIntRand (one, two) {
    var rand = this._rnd;
    if ((one | 0) < (two | 0)) {
      var result = (rand.Next(one, two) | 0);
    } else {
      result = (rand.Next(two, one) | 0);
    }
    return result;
  }; 

  function ParticleEmitter_GenRand (one, two) {
    var rand = this._rnd;
    return (+one + (+rand.NextDouble() * (+two - +one)));
  }; 

  function ParticleEmitter_get_GravityX () {
    return this._customGravityX;
  }; 

  function ParticleEmitter_get_GravityY () {
    return this._customGravityY;
  }; 

  function ParticleEmitter_get_GravityZ () {
    return this._customGravityZ;
  }; 

  function ParticleEmitter_get_LifeMax () {
    return this._customLifeMax;
  }; 

  function ParticleEmitter_get_LifeMin () {
    return this._customLifeMin;
  }; 

  function ParticleEmitter_get_MaxSize () {
    return this._customMaxSize;
  }; 

  function ParticleEmitter_get_MinSize () {
    return this._customMinSize;
  }; 

  function ParticleEmitter_get_PMesh () {
    return this.ParticleMesh;
  }; 

  function ParticleEmitter_get_RandPosX () {
    return this._customRandPosX;
  }; 

  function ParticleEmitter_get_RandPosY () {
    return this._customRandPosY;
  }; 

  function ParticleEmitter_get_RandPosZ () {
    return this._customRandPosZ;
  }; 

  function ParticleEmitter_get_RandVelX () {
    return this._customRandVelX;
  }; 

  function ParticleEmitter_get_RandVelY () {
    return this._customRandVelY;
  }; 

  function ParticleEmitter_get_RandVelZ () {
    return this._customRandVelZ;
  }; 

  function ParticleEmitter_get_Transparency () {
    return this._customTransparency;
  }; 

  function ParticleEmitter_set_GravityX (value) {
    this._customGravityX = +value;
  }; 

  function ParticleEmitter_set_GravityY (value) {
    this._customGravityY = +value;
  }; 

  function ParticleEmitter_set_GravityZ (value) {
    this._customGravityZ = +value;
  }; 

  function ParticleEmitter_set_LifeMax (value) {
    this._customLifeMax = (value | 0);
  }; 

  function ParticleEmitter_set_LifeMin (value) {
    this._customLifeMin = (value | 0);
  }; 

  function ParticleEmitter_set_MaxSize (value) {
    this._customMaxSize = +value;
  }; 

  function ParticleEmitter_set_MinSize (value) {
    this._customMinSize = +value;
  }; 

  function ParticleEmitter_set_RandPosX (value) {
    this._customRandPosX = +value;
  }; 

  function ParticleEmitter_set_RandPosY (value) {
    this._customRandPosY = +value;
  }; 

  function ParticleEmitter_set_RandPosZ (value) {
    this._customRandPosZ = +value;
  }; 

  function ParticleEmitter_set_RandVelX (value) {
    this._customRandVelX = +value;
  }; 

  function ParticleEmitter_set_RandVelY (value) {
    this._customRandVelY = +value;
  }; 

  function ParticleEmitter_set_RandVelZ (value) {
    this._customRandVelZ = +value;
  }; 

  function ParticleEmitter_set_Transparency (value) {
    this._customTransparency = +value;
  }; 

  function ParticleEmitter_Tick (deltaTime) {
    var vertices = JSIL.Array.New($T07(), Math.imul(this._customCount, 4));
    var triangles = JSIL.Array.New($T09(), Math.imul(this._customCount, 6));
    var normals = JSIL.Array.New($T07(), Math.imul(this._customCount, 4));
    var uVs = JSIL.Array.New($T0B(), Math.imul(this._customCount, 4));
    this._rnd = $S01().Construct();

    while (((this._particleList).get_Count() | 0) < (this._customCount | 0)) {
      this._randVelX = +this.GenRand(-this._customRandVelX, this._customRandVelX);
      this._randVelY = +this.GenRand(-this._customRandVelY, this._customRandVelY);
      this._randVelZ = +this.GenRand(-this._customRandVelZ, this._customRandVelZ);
      this._randPosX = +this.GenRand(-this._customRandPosX, this._customRandPosX);
      this._randPosY = +this.GenRand(-this._customRandPosY, this._customRandPosY);
      this._randPosZ = +this.GenRand(-this._customRandPosZ, this._customRandPosZ);
      this._randRot = +this.GenRand(0, 1.3);
      this._randLife = (this.GenIntRand(this._customLifeMin, this._customLifeMax) | 0);
      this._particle = new ($T0C())();
      this._particle.Position = $S02().Construct(Math.fround(this._randPosX), Math.fround(this._randPosY), Math.fround(this._randPosZ));
      this._particle.Velocity = $S02().Construct(Math.fround(this._randVelX), Math.fround(this._randVelY), Math.fround(this._randVelZ));
      this._particle.Gravity = $S02().Construct(this._customGravityX, this._customGravityY, this._customGravityZ);
      this._particle.Life = (this._randLife | 0);
      this._particle.MaxSize = +this._customMaxSize;
      this._particle.MinSize = +this._customMinSize;
      this._particle.Rotation = Math.fround(this._randRot);
      this._particle.Transparency = +this._customTransparency;
      $S03().CallVirtual("Add", null, this._particleList, this._particle);
    }

    for (var i = 0; i < ((this._particleList).get_Count() | 0); i = ((i + 1) | 0)) {
      var t = (this._particleList).get_Item(i);
      var currentPos = t.Position;
      var currentSize = +t.MinSize;
      var flag = (t.Life | 0) > 0;
      if (flag) {
        vertices[Math.imul(i, 4)] = currentPos.MemberwiseClone();
        vertices[((Math.imul(i, 4) + 1) | 0)] = currentPos.MemberwiseClone();
        vertices[((Math.imul(i, 4) + 2) | 0)] = currentPos.MemberwiseClone();
        vertices[((Math.imul(i, 4) + 3) | 0)] = currentPos.MemberwiseClone();
        uVs[Math.imul(i, 4)] = $S04().Construct(+((currentSize / 2)), +((-currentSize / 2)));
        uVs[((Math.imul(i, 4) + 1) | 0)] = $S04().Construct(+((currentSize / 2)), +((currentSize / 2)));
        uVs[((Math.imul(i, 4) + 2) | 0)] = $S04().Construct(+((-currentSize / 2)), +((currentSize / 2)));
        uVs[((Math.imul(i, 4) + 3) | 0)] = $S04().Construct(+((-currentSize / 2)), +((-currentSize / 2)));
        normals[Math.imul(i, 4)] = $S02().Construct(t.Rotation, t.Transparency, 1);
        normals[((Math.imul(i, 4) + 1) | 0)] = $S02().Construct(t.Rotation, t.Transparency, 1);
        normals[((Math.imul(i, 4) + 2) | 0)] = $S02().Construct(t.Rotation, t.Transparency, 1);
        normals[((Math.imul(i, 4) + 3) | 0)] = $S02().Construct(t.Rotation, t.Transparency, 1);
        triangles[Math.imul(i, 6)] = (Math.imul(i, 4) & 0xFFFF);
        triangles[((Math.imul(i, 6) + 1) | 0)] = (((Math.imul(i, 4) + 1) | 0) & 0xFFFF);
        triangles[((Math.imul(i, 6) + 2) | 0)] = (((Math.imul(i, 4) + 2) | 0) & 0xFFFF);
        triangles[((Math.imul(i, 6) + 3) | 0)] = (Math.imul(i, 4) & 0xFFFF);
        triangles[((Math.imul(i, 6) + 4) | 0)] = (((Math.imul(i, 4) + 2) | 0) & 0xFFFF);
        triangles[((Math.imul(i, 6) + 5) | 0)] = (((Math.imul(i, 4) + 3) | 0) & 0xFFFF);
      }
    }
    (this.ParticleMesh).set_Vertices(vertices);
    (this.ParticleMesh).set_Triangles(triangles);
    (this.ParticleMesh).set_Normals(normals);
    (this.ParticleMesh).set_UVs(uVs);

    for (var j = 0; j < ((this._particleList).get_Count() | 0); j = ((j + 1) | 0)) {
      var changeParticle = (this._particleList).get_Item(j);
      changeParticle.Position = $T07().op_Addition(changeParticle.Position.MemberwiseClone(), $S05().CallStatic($T07(), "op_Multiply", null, Math.fround(deltaTime), changeParticle.Velocity.MemberwiseClone()));
      changeParticle.Velocity = $T07().op_Subtraction(changeParticle.Velocity.MemberwiseClone(), changeParticle.Gravity);
      changeParticle.Rotation += +this._customRotation;
      changeParticle.Transparency -= +((+changeParticle.Transparency / +(changeParticle.Life)));
      var flag2 = +changeParticle.MinSize <= +changeParticle.MaxSize;
      if (flag2) {
        changeParticle.MinSize += +((+changeParticle.MaxSize / +(changeParticle.Life)));
      }
      var flag3 = (changeParticle.Life >>> 0) > (0 >>> 0);
      if (flag3) {
        changeParticle.Life = (((changeParticle.Life | 0) - 1) | 0);
      }
      (this._particleList).set_Item(j, changeParticle);
      var flag4 = ((changeParticle.Life | 0) === 0) || 
      ((changeParticle.Life | 0) <= 0);
      if (flag4) {
        (this._particleList).Remove(changeParticle);
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.ParticleEmitter", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 16, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Double, $.Double, 
          $.Double, $.Single, 
          $.Single, $.Single
        ]), 
      ParticleEmitter__ctor
    );

    $.Method({Static:false, Public:false}, "GenIntRand", 
      new JSIL.MethodSignature($.Int32, [$.Int32, $.Int32]), 
      ParticleEmitter_GenIntRand
    );

    $.Method({Static:false, Public:false}, "GenRand", 
      new JSIL.MethodSignature($.Double, [$.Double, $.Double]), 
      ParticleEmitter_GenRand
    );

    $.Method({Static:false, Public:true }, "get_GravityX", 
      JSIL.MethodSignature.Return($.Single), 
      ParticleEmitter_get_GravityX
    );

    $.Method({Static:false, Public:true }, "get_GravityY", 
      JSIL.MethodSignature.Return($.Single), 
      ParticleEmitter_get_GravityY
    );

    $.Method({Static:false, Public:true }, "get_GravityZ", 
      JSIL.MethodSignature.Return($.Single), 
      ParticleEmitter_get_GravityZ
    );

    $.Method({Static:false, Public:true }, "get_LifeMax", 
      JSIL.MethodSignature.Return($.Int32), 
      ParticleEmitter_get_LifeMax
    );

    $.Method({Static:false, Public:true }, "get_LifeMin", 
      JSIL.MethodSignature.Return($.Int32), 
      ParticleEmitter_get_LifeMin
    );

    $.Method({Static:false, Public:true }, "get_MaxSize", 
      JSIL.MethodSignature.Return($.Single), 
      ParticleEmitter_get_MaxSize
    );

    $.Method({Static:false, Public:true }, "get_MinSize", 
      JSIL.MethodSignature.Return($.Single), 
      ParticleEmitter_get_MinSize
    );

    $.Method({Static:false, Public:true }, "get_PMesh", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      ParticleEmitter_get_PMesh
    );

    $.Method({Static:false, Public:true }, "get_RandPosX", 
      JSIL.MethodSignature.Return($.Double), 
      ParticleEmitter_get_RandPosX
    );

    $.Method({Static:false, Public:true }, "get_RandPosY", 
      JSIL.MethodSignature.Return($.Double), 
      ParticleEmitter_get_RandPosY
    );

    $.Method({Static:false, Public:true }, "get_RandPosZ", 
      JSIL.MethodSignature.Return($.Double), 
      ParticleEmitter_get_RandPosZ
    );

    $.Method({Static:false, Public:true }, "get_RandVelX", 
      JSIL.MethodSignature.Return($.Double), 
      ParticleEmitter_get_RandVelX
    );

    $.Method({Static:false, Public:true }, "get_RandVelY", 
      JSIL.MethodSignature.Return($.Double), 
      ParticleEmitter_get_RandVelY
    );

    $.Method({Static:false, Public:true }, "get_RandVelZ", 
      JSIL.MethodSignature.Return($.Double), 
      ParticleEmitter_get_RandVelZ
    );

    $.Method({Static:false, Public:true }, "get_Transparency", 
      JSIL.MethodSignature.Return($.Single), 
      ParticleEmitter_get_Transparency
    );

    $.Method({Static:false, Public:true }, "set_GravityX", 
      JSIL.MethodSignature.Action($.Single), 
      ParticleEmitter_set_GravityX
    );

    $.Method({Static:false, Public:true }, "set_GravityY", 
      JSIL.MethodSignature.Action($.Single), 
      ParticleEmitter_set_GravityY
    );

    $.Method({Static:false, Public:true }, "set_GravityZ", 
      JSIL.MethodSignature.Action($.Single), 
      ParticleEmitter_set_GravityZ
    );

    $.Method({Static:false, Public:true }, "set_LifeMax", 
      JSIL.MethodSignature.Action($.Int32), 
      ParticleEmitter_set_LifeMax
    );

    $.Method({Static:false, Public:true }, "set_LifeMin", 
      JSIL.MethodSignature.Action($.Int32), 
      ParticleEmitter_set_LifeMin
    );

    $.Method({Static:false, Public:true }, "set_MaxSize", 
      JSIL.MethodSignature.Action($.Single), 
      ParticleEmitter_set_MaxSize
    );

    $.Method({Static:false, Public:true }, "set_MinSize", 
      JSIL.MethodSignature.Action($.Single), 
      ParticleEmitter_set_MinSize
    );

    $.Method({Static:false, Public:true }, "set_RandPosX", 
      JSIL.MethodSignature.Action($.Double), 
      ParticleEmitter_set_RandPosX
    );

    $.Method({Static:false, Public:true }, "set_RandPosY", 
      JSIL.MethodSignature.Action($.Double), 
      ParticleEmitter_set_RandPosY
    );

    $.Method({Static:false, Public:true }, "set_RandPosZ", 
      JSIL.MethodSignature.Action($.Double), 
      ParticleEmitter_set_RandPosZ
    );

    $.Method({Static:false, Public:true }, "set_RandVelX", 
      JSIL.MethodSignature.Action($.Double), 
      ParticleEmitter_set_RandVelX
    );

    $.Method({Static:false, Public:true }, "set_RandVelY", 
      JSIL.MethodSignature.Action($.Double), 
      ParticleEmitter_set_RandVelY
    );

    $.Method({Static:false, Public:true }, "set_RandVelZ", 
      JSIL.MethodSignature.Action($.Double), 
      ParticleEmitter_set_RandVelZ
    );

    $.Method({Static:false, Public:true }, "set_Transparency", 
      JSIL.MethodSignature.Action($.Single), 
      ParticleEmitter_set_Transparency
    );

    $.Method({Static:false, Public:true }, "Tick", 
      JSIL.MethodSignature.Action($.Double), 
      ParticleEmitter_Tick
    );

    $.Field({Static:false, Public:true }, "VsSimpleTexture", $.String);

    $.Field({Static:false, Public:true }, "PsSimpleTexture", $.String);

    $.Field({Static:false, Public:true }, "ParticleMesh", $asm04.TypeRef("Fusee.Engine.Core.Mesh"));

    $.Field({Static:false, Public:false}, "_particleList", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm04.TypeRef("Fusee.Engine.Core.ParticleData")]));

    $.Field({Static:false, Public:false}, "_particle", $asm04.TypeRef("Fusee.Engine.Core.ParticleData"));

    $.Field({Static:false, Public:false}, "_rnd", $asm0E.TypeRef("System.Random"));

    $.Field({Static:false, Public:false}, "_randVelX", $.Double);

    $.Field({Static:false, Public:false}, "_randVelY", $.Double);

    $.Field({Static:false, Public:false}, "_randVelZ", $.Double);

    $.Field({Static:false, Public:false}, "_randPosX", $.Double);

    $.Field({Static:false, Public:false}, "_randPosY", $.Double);

    $.Field({Static:false, Public:false}, "_randPosZ", $.Double);

    $.Field({Static:false, Public:false}, "_randRot", $.Double);

    $.Field({Static:false, Public:false}, "_randLife", $.Int32);

    $.Field({Static:false, Public:false}, "_customCount", $.Int32);

    $.Field({Static:false, Public:false}, "_customLifeMin", $.Int32);

    $.Field({Static:false, Public:false}, "_customLifeMax", $.Int32);

    $.Field({Static:false, Public:false}, "_customMinSize", $.Single);

    $.Field({Static:false, Public:false}, "_customMaxSize", $.Single);

    $.Field({Static:false, Public:false}, "_customRandPosX", $.Double);

    $.Field({Static:false, Public:false}, "_customRandPosY", $.Double);

    $.Field({Static:false, Public:false}, "_customRandPosZ", $.Double);

    $.Field({Static:false, Public:false}, "_customRandVelX", $.Double);

    $.Field({Static:false, Public:false}, "_customRandVelY", $.Double);

    $.Field({Static:false, Public:false}, "_customRandVelZ", $.Double);

    $.Field({Static:false, Public:false}, "_customGravityX", $.Single);

    $.Field({Static:false, Public:false}, "_customGravityY", $.Single);

    $.Field({Static:false, Public:false}, "_customGravityZ", $.Single);

    $.Field({Static:false, Public:false}, "_customTransparency", $.Single);

    $.Field({Static:false, Public:false}, "_customRotation", $.Single);

    $.Property({Static:false, Public:true }, "PMesh", $asm04.TypeRef("Fusee.Engine.Core.Mesh"));

    $.Property({Static:false, Public:true }, "LifeMin", $.Int32);

    $.Property({Static:false, Public:true }, "LifeMax", $.Int32);

    $.Property({Static:false, Public:true }, "MinSize", $.Single);

    $.Property({Static:false, Public:true }, "MaxSize", $.Single);

    $.Property({Static:false, Public:true }, "Transparency", $.Single);

    $.Property({Static:false, Public:true }, "RandPosX", $.Double);

    $.Property({Static:false, Public:true }, "RandPosY", $.Double);

    $.Property({Static:false, Public:true }, "RandPosZ", $.Double);

    $.Property({Static:false, Public:true }, "RandVelX", $.Double);

    $.Property({Static:false, Public:true }, "RandVelY", $.Double);

    $.Property({Static:false, Public:true }, "RandVelZ", $.Double);

    $.Property({Static:false, Public:true }, "GravityX", $.Single);

    $.Property({Static:false, Public:true }, "GravityY", $.Single);

    $.Property({Static:false, Public:true }, "GravityZ", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.RenderCanvas */ 

(function RenderCanvas$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.InitEventArgs)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.RenderEventArgs)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.Network)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.Input)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.Time)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm03.Fusee.Engine.Common.ResizeEventArgs)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Engine.Core.Audio)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize(System.Array.Of($asm0E.System.Object))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.Reflection.MemberInfo)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm03.Fusee.Engine.Common.FuseeApplicationAttribute)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm04.Fusee.Engine.Core.VideoManager)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.InitEventArgs))) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.RenderEventArgs))) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.ResizeEventArgs))) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm03.Fusee.Engine.Common.IAudioImp)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDriverImp)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm03.Fusee.Engine.Common.INetworkImp)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm03.Fusee.Engine.Common.IVideoManagerImp)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm03.Fusee.Engine.Common.CursorType)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.InitEventArgs]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.InitEventArgs]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.RenderEventArgs]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.ResizeEventArgs]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.get_DeltaTime)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.CloseGameWindow)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.get_Fullscreen)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.get_Height)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.get_VerticalSync)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.get_Width)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.set_Caption)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.add_Init)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.add_UnLoad)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.add_Render)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.add_Resize)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.OpenLink)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.Present)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.Run)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.set_Fullscreen)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.set_Height)) ();
  };
  var $IM10 = function () {
    return ($IM10 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.set_VerticalSync)) ();
  };
  var $IM11 = function () {
    return ($IM11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.set_Width)) ();
  };
  var $IM12 = function () {
    return ($IM12 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.SetCursor)) ();
  };
  var $IM13 = function () {
    return ($IM13 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderCanvasImp.SetWindowSize)) ();
  };


  function RenderCanvas__ctor () {
  }; 

  function RenderCanvas_$lInitCanvas$gb__31_0 ($lp0$g, $lp1$g) {
    this.Init();
  }; 

  function RenderCanvas_$lInitCanvas$gb__31_1 ($lp0$g, $lp1$g) {
    this.DeInit();
  }; 

  function RenderCanvas_$lInitCanvas$gb__31_2 ($lp0$g, $lp1$g) {
    $T03().get_Instance().OnUpdateFrame();
    $T04().get_Instance().PreRender();
    $T05().get_Instance().set_DeltaTimeIncrement($IM00().Call(this.RenderCanvas$CanvasImplementor$value, null));
    this.RenderAFrame();
    $T04().get_Instance().PostRender();
  }; 

  function RenderCanvas_$lInitCanvas$gb__31_3 ($lp0$g, $lp1$g) {
    this.Resize();
  }; 

  function RenderCanvas_CloseGameWindow () {
    $IM01().Call(this.RenderCanvas$CanvasImplementor$value, null);
  }; 

  function RenderCanvas_DeInit () {
    $T08().get_Instance().CloseDevice();
    $T03().get_Instance().CloseDevice();
    $T08().get_Instance().Dispose();
    $T05().get_Instance().Dispose();
    $T04().get_Instance().Dispose();
    $T03().get_Instance().Dispose();
  }; 

  function RenderCanvas_get_AudioImplementor () {
    return this.RenderCanvas$AudioImplementor$value;
  }; 

  function RenderCanvas_get_CanvasImplementor () {
    return this.RenderCanvas$CanvasImplementor$value;
  }; 

  function RenderCanvas_get_ContextImplementor () {
    return this.RenderCanvas$ContextImplementor$value;
  }; 

  function RenderCanvas_get_Fullscreen () {
    return $IM02().Call(this.RenderCanvas$CanvasImplementor$value, null);
  }; 

  function RenderCanvas_get_Height () {
    return $IM03().Call(this.RenderCanvas$CanvasImplementor$value, null);
  }; 

  function RenderCanvas_get_InputDriverImplementor () {
    return this.RenderCanvas$InputDriverImplementor$value;
  }; 

  function RenderCanvas_get_NetworkImplementor () {
    return this.RenderCanvas$NetworkImplementor$value;
  }; 

  function RenderCanvas_get_RC () {
    return this.RenderCanvas$RC$value;
  }; 

  function RenderCanvas_get_VideoManagerImplementor () {
    return this.RenderCanvas$VideoManagerImplementor$value;
  }; 

  function RenderCanvas_get_VSync () {
    return $IM04().Call(this.RenderCanvas$CanvasImplementor$value, null);
  }; 

  function RenderCanvas_get_Width () {
    return $IM05().Call(this.RenderCanvas$CanvasImplementor$value, null);
  }; 

  function RenderCanvas_GetAppName () {
    var attributes = (JSIL.GetType(this)).GetCustomAttributes($T0B().__Type__, true);
    var flag = (attributes.length >>> 0) > (0 >>> 0);
    if (flag) {
      var fae = $T0B().$Cast(attributes[0]);
      var name = fae.Name;
    } else {
      name = (JSIL.GetType(this)).get_Name();
    }
    return name;
  }; 

  function RenderCanvas_GetWindowHeight () {
    var attributes = (JSIL.GetType(this)).GetCustomAttributes($T0B().__Type__, true);
    var flag = (attributes.length >>> 0) > (0 >>> 0);
    if (flag) {
      var fae = $T0B().$Cast(attributes[0]);
      var result = (fae.Height | 0);
    } else {
      result = -1;
    }
    return result;
  }; 

  function RenderCanvas_GetWindowWidth () {
    var attributes = (JSIL.GetType(this)).GetCustomAttributes($T0B().__Type__, true);
    var flag = (attributes.length >>> 0) > (0 >>> 0);
    if (flag) {
      var fae = $T0B().$Cast(attributes[0]);
      var result = (fae.Width | 0);
    } else {
      result = -1;
    }
    return result;
  }; 

  function RenderCanvas_Init () {
  }; 

  function RenderCanvas_InitCanvas () {
    $IM06().Call(this.RenderCanvas$CanvasImplementor$value, null, this.GetAppName());
    var windowWidth = (this.GetWindowWidth() | 0);
    var windowHeight = (this.GetWindowHeight() | 0);
    if ((windowWidth !== -1) && (windowHeight !== -1)) {
      this.SetWindowSize(
        windowWidth, 
        windowHeight, 
        -1, 
        -1, 
        false
      );
    }
    this.RenderCanvas$RC$value = new ($T10())(this.RenderCanvas$ContextImplementor$value);
    (this.RenderCanvas$RC$value).Viewport(
      0, 
      0, 
      this.get_Width(), 
      this.get_Height()
    );
    $T08().get_Instance().set_AudioImp(this.RenderCanvas$AudioImplementor$value);
    $T03().get_Instance().set_NetworkImp(this.RenderCanvas$NetworkImplementor$value);
    $T11().get_Instance().set_VideoManagerImp(this.RenderCanvas$VideoManagerImplementor$value);
    $IM07().Call(this.RenderCanvas$CanvasImplementor$value, null, $T12().New(this, null, new JSIL.MethodPointerInfo($thisType, "$lInitCanvas$gb__31_0", $S00(), false, false)));
    $IM08().Call(this.RenderCanvas$CanvasImplementor$value, null, $T12().New(this, null, new JSIL.MethodPointerInfo($thisType, "$lInitCanvas$gb__31_1", $S01(), false, false)));
    $IM09().Call(this.RenderCanvas$CanvasImplementor$value, null, $T13().New(this, null, new JSIL.MethodPointerInfo($thisType, "$lInitCanvas$gb__31_2", $S02(), false, false)));
    $IM0A().Call(this.RenderCanvas$CanvasImplementor$value, null, $T14().New(this, null, new JSIL.MethodPointerInfo($thisType, "$lInitCanvas$gb__31_3", $S03(), false, false)));
  }; 

  function RenderCanvas_OpenLink (link) {
    $IM0B().Call(this.RenderCanvas$CanvasImplementor$value, null, link);
  }; 

  function RenderCanvas_Present () {
    $IM0C().Call(this.RenderCanvas$CanvasImplementor$value, null);
  }; 

  function RenderCanvas_RenderAFrame () {
  }; 

  function RenderCanvas_Resize () {
  }; 

  function RenderCanvas_Run () {
    this.InitCanvas();
    $IM0D().Call(this.RenderCanvas$CanvasImplementor$value, null);
  }; 

  function RenderCanvas_set_AudioImplementor (value) {
    this.RenderCanvas$AudioImplementor$value = value;
  }; 

  function RenderCanvas_set_CanvasImplementor (value) {
    this.RenderCanvas$CanvasImplementor$value = value;
  }; 

  function RenderCanvas_set_ContextImplementor (value) {
    this.RenderCanvas$ContextImplementor$value = value;
  }; 

  function RenderCanvas_set_Fullscreen (value) {
    $IM0E().Call(this.RenderCanvas$CanvasImplementor$value, null, value);
  }; 

  function RenderCanvas_set_Height (value) {
    $IM0F().Call(this.RenderCanvas$CanvasImplementor$value, null, value);
  }; 

  function RenderCanvas_set_InputDriverImplementor (value) {
    this.RenderCanvas$InputDriverImplementor$value = value;
  }; 

  function RenderCanvas_set_NetworkImplementor (value) {
    this.RenderCanvas$NetworkImplementor$value = value;
  }; 

  function RenderCanvas_set_RC (value) {
    this.RenderCanvas$RC$value = value;
  }; 

  function RenderCanvas_set_VideoManagerImplementor (value) {
    this.RenderCanvas$VideoManagerImplementor$value = value;
  }; 

  function RenderCanvas_set_VSync (value) {
    $IM10().Call(this.RenderCanvas$CanvasImplementor$value, null, value);
  }; 

  function RenderCanvas_set_Width (value) {
    $IM11().Call(this.RenderCanvas$CanvasImplementor$value, null, value);
  }; 

  function RenderCanvas_SetCursor (cursorType) {
    $IM12().Call(this.RenderCanvas$CanvasImplementor$value, null, cursorType);
  }; 

  function RenderCanvas_SetWindowSize (width, height, posx, posy, borderHidden) {
    $IM13().Call(this.RenderCanvas$CanvasImplementor$value, null, 
      width, 
      height, 
      posx, 
      posy, 
      borderHidden
    );
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.RenderCanvas", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      RenderCanvas__ctor
    );

    $.Method({Static:false, Public:false}, "$lInitCanvas$gb__31_0", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.InitEventArgs")]), 
      RenderCanvas_$lInitCanvas$gb__31_0
    );

    $.Method({Static:false, Public:false}, "$lInitCanvas$gb__31_1", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.InitEventArgs")]), 
      RenderCanvas_$lInitCanvas$gb__31_1
    );

    $.Method({Static:false, Public:false}, "$lInitCanvas$gb__31_2", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.RenderEventArgs")]), 
      RenderCanvas_$lInitCanvas$gb__31_2
    );

    $.Method({Static:false, Public:false}, "$lInitCanvas$gb__31_3", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.ResizeEventArgs")]), 
      RenderCanvas_$lInitCanvas$gb__31_3
    );

    $.Method({Static:false, Public:true }, "CloseGameWindow", 
      JSIL.MethodSignature.Void, 
      RenderCanvas_CloseGameWindow
    );

    $.Method({Static:false, Public:true , Virtual:true }, "DeInit", 
      JSIL.MethodSignature.Void, 
      RenderCanvas_DeInit
    );

    $.Method({Static:false, Public:true }, "get_AudioImplementor", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.IAudioImp")), 
      RenderCanvas_get_AudioImplementor
    );

    $.Method({Static:false, Public:true }, "get_CanvasImplementor", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.IRenderCanvasImp")), 
      RenderCanvas_get_CanvasImplementor
    );

    $.Method({Static:false, Public:true }, "get_ContextImplementor", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.IRenderContextImp")), 
      RenderCanvas_get_ContextImplementor
    );

    $.Method({Static:false, Public:true }, "get_Fullscreen", 
      JSIL.MethodSignature.Return($.Boolean), 
      RenderCanvas_get_Fullscreen
    );

    $.Method({Static:false, Public:true }, "get_Height", 
      JSIL.MethodSignature.Return($.Int32), 
      RenderCanvas_get_Height
    );

    $.Method({Static:false, Public:true }, "get_InputDriverImplementor", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp")), 
      RenderCanvas_get_InputDriverImplementor
    );

    $.Method({Static:false, Public:true }, "get_NetworkImplementor", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.INetworkImp")), 
      RenderCanvas_get_NetworkImplementor
    );

    $.Method({Static:false, Public:false}, "get_RC", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      RenderCanvas_get_RC
    );

    $.Method({Static:false, Public:true }, "get_VideoManagerImplementor", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.IVideoManagerImp")), 
      RenderCanvas_get_VideoManagerImplementor
    );

    $.Method({Static:false, Public:true }, "get_VSync", 
      JSIL.MethodSignature.Return($.Boolean), 
      RenderCanvas_get_VSync
    );

    $.Method({Static:false, Public:true }, "get_Width", 
      JSIL.MethodSignature.Return($.Int32), 
      RenderCanvas_get_Width
    );

    $.Method({Static:false, Public:false}, "GetAppName", 
      JSIL.MethodSignature.Return($.String), 
      RenderCanvas_GetAppName
    );

    $.Method({Static:false, Public:false}, "GetWindowHeight", 
      JSIL.MethodSignature.Return($.Int32), 
      RenderCanvas_GetWindowHeight
    );

    $.Method({Static:false, Public:false}, "GetWindowWidth", 
      JSIL.MethodSignature.Return($.Int32), 
      RenderCanvas_GetWindowWidth
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Init", 
      JSIL.MethodSignature.Void, 
      RenderCanvas_Init
    );

    $.Method({Static:false, Public:false}, "InitCanvas", 
      JSIL.MethodSignature.Void, 
      RenderCanvas_InitCanvas
    );

    $.Method({Static:false, Public:true }, "OpenLink", 
      JSIL.MethodSignature.Action($.String), 
      RenderCanvas_OpenLink
    );

    $.Method({Static:false, Public:true }, "Present", 
      JSIL.MethodSignature.Void, 
      RenderCanvas_Present
    );

    $.Method({Static:false, Public:true , Virtual:true }, "RenderAFrame", 
      JSIL.MethodSignature.Void, 
      RenderCanvas_RenderAFrame
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Resize", 
      JSIL.MethodSignature.Void, 
      RenderCanvas_Resize
    );

    $.Method({Static:false, Public:true }, "Run", 
      JSIL.MethodSignature.Void, 
      RenderCanvas_Run
    );

    $.Method({Static:false, Public:true }, "set_AudioImplementor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IAudioImp")), 
      RenderCanvas_set_AudioImplementor
    );

    $.Method({Static:false, Public:true }, "set_CanvasImplementor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IRenderCanvasImp")), 
      RenderCanvas_set_CanvasImplementor
    );

    $.Method({Static:false, Public:true }, "set_ContextImplementor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IRenderContextImp")), 
      RenderCanvas_set_ContextImplementor
    );

    $.Method({Static:false, Public:true }, "set_Fullscreen", 
      JSIL.MethodSignature.Action($.Boolean), 
      RenderCanvas_set_Fullscreen
    );

    $.Method({Static:false, Public:true }, "set_Height", 
      JSIL.MethodSignature.Action($.Int32), 
      RenderCanvas_set_Height
    );

    $.Method({Static:false, Public:true }, "set_InputDriverImplementor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp")), 
      RenderCanvas_set_InputDriverImplementor
    );

    $.Method({Static:false, Public:true }, "set_NetworkImplementor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.INetworkImp")), 
      RenderCanvas_set_NetworkImplementor
    );

    $.Method({Static:false, Public:false}, "set_RC", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      RenderCanvas_set_RC
    );

    $.Method({Static:false, Public:true }, "set_VideoManagerImplementor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IVideoManagerImp")), 
      RenderCanvas_set_VideoManagerImplementor
    );

    $.Method({Static:false, Public:true }, "set_VSync", 
      JSIL.MethodSignature.Action($.Boolean), 
      RenderCanvas_set_VSync
    );

    $.Method({Static:false, Public:true }, "set_Width", 
      JSIL.MethodSignature.Action($.Int32), 
      RenderCanvas_set_Width
    );

    $.Method({Static:false, Public:true }, "SetCursor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.CursorType")), 
      RenderCanvas_SetCursor
    );

    $.Method({Static:false, Public:true }, "SetWindowSize", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32, $.Int32, 
          $.Boolean
        ]), 
      RenderCanvas_SetWindowSize
    );

    $.Field({Static:false, Public:false}, "RenderCanvas$CanvasImplementor$value", $asm03.TypeRef("Fusee.Engine.Common.IRenderCanvasImp"));

    $.Field({Static:false, Public:false}, "RenderCanvas$ContextImplementor$value", $asm03.TypeRef("Fusee.Engine.Common.IRenderContextImp"));

    $.Field({Static:false, Public:false}, "RenderCanvas$AudioImplementor$value", $asm03.TypeRef("Fusee.Engine.Common.IAudioImp"));

    $.Field({Static:false, Public:false}, "RenderCanvas$InputDriverImplementor$value", $asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp"));

    $.Field({Static:false, Public:false}, "RenderCanvas$VideoManagerImplementor$value", $asm03.TypeRef("Fusee.Engine.Common.IVideoManagerImp"));

    $.Field({Static:false, Public:false}, "RenderCanvas$NetworkImplementor$value", $asm03.TypeRef("Fusee.Engine.Common.INetworkImp"));

    $.Field({Static:false, Public:false}, "RenderCanvas$RC$value", $asm04.TypeRef("Fusee.Engine.Core.RenderContext"));

    $.Property({Static:false, Public:true }, "CanvasImplementor", $asm03.TypeRef("Fusee.Engine.Common.IRenderCanvasImp"))
      .Attribute($asm00.TypeRef("Fusee.Base.Common.InjectMeAttribute"));

    $.Property({Static:false, Public:true }, "ContextImplementor", $asm03.TypeRef("Fusee.Engine.Common.IRenderContextImp"))
      .Attribute($asm00.TypeRef("Fusee.Base.Common.InjectMeAttribute"));

    $.Property({Static:false, Public:true }, "AudioImplementor", $asm03.TypeRef("Fusee.Engine.Common.IAudioImp"))
      .Attribute($asm00.TypeRef("Fusee.Base.Common.InjectMeAttribute"));

    $.Property({Static:false, Public:true }, "InputDriverImplementor", $asm03.TypeRef("Fusee.Engine.Common.IInputDriverImp"))
      .Attribute($asm00.TypeRef("Fusee.Base.Common.InjectMeAttribute"));

    $.Property({Static:false, Public:true }, "VideoManagerImplementor", $asm03.TypeRef("Fusee.Engine.Common.IVideoManagerImp"))
      .Attribute($asm00.TypeRef("Fusee.Base.Common.InjectMeAttribute"));

    $.Property({Static:false, Public:true }, "NetworkImplementor", $asm03.TypeRef("Fusee.Engine.Common.INetworkImp"))
      .Attribute($asm00.TypeRef("Fusee.Base.Common.InjectMeAttribute"));

    $.Property({Static:false, Public:false}, "RC", $asm04.TypeRef("Fusee.Engine.Core.RenderContext"));

    $.Property({Static:false, Public:true }, "Width", $.Int32);

    $.Property({Static:false, Public:true }, "Height", $.Int32);

    $.Property({Static:false, Public:true }, "VSync", $.Boolean);

    $.Property({Static:false, Public:true }, "Fullscreen", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.RenderContext */ 

(function RenderContext$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm00.Fusee.Base.Common.ColorUint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext_MatrixParamNames)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.Shaders)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderProgram)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm03.Fusee.Engine.Common.ClearFlags)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm03.Fusee.Engine.Common.ITexture)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm00.Fusee.Base.Common.ImageData)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm03.Fusee.Engine.Common.WritableTextureFormat)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm03.Fusee.Engine.Common.Rectangle)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm03.Fusee.Engine.Common.HardwareCapability)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IShaderParam)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm03.Fusee.Engine.Common.RenderState)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt32))) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float4))) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt16))) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float4x4))) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0E.System.NotImplementedException)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderStateSet)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm03.Fusee.Engine.Common.RenderState, $asm0E.System.UInt32)))) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm03.Fusee.Engine.Common.RenderState, $asm0E.System.UInt32)))) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm0E.System.Collections.IEnumerator)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm03.Fusee.Engine.Common.RenderState, $asm0E.System.UInt32))) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm0E.System.IDisposable)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm03.Fusee.Engine.Common.GBufferHandle)) ();
  };
  var $T25 = function () {
    return ($T25 = JSIL.Memoize($asm03.Fusee.Engine.Common.IVideoStreamImp)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.NotImplementedException, [$asm0E.System.String]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm03.Fusee.Engine.Common.IShaderParam, $asm03.Fusee.Engine.Common.ITexture]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm03.Fusee.Engine.Common.IShaderParam, $asm03.Fusee.Engine.Common.ITexture, 
        $asm03.Fusee.Engine.Common.GBufferHandle
      ]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.Clear)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.ColorMask)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.CopyDepthBufferFromDeferredBuffer)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.CreateShader)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.CreateTexture)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.CreateWritableTexture)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.DebugLine)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.get_ClearColor)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.get_ClearDepth)) ();
  };
  var $IM09 = function () {
    return ($IM09 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.GetBufferContent)) ();
  };
  var $IM0A = function () {
    return ($IM0A = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.GetHardwareCapabilities)) ();
  };
  var $IM0B = function () {
    return ($IM0B = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.GetParamValue)) ();
  };
  var $IM0C = function () {
    return ($IM0C = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.GetPixelColor)) ();
  };
  var $IM0D = function () {
    return ($IM0D = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.GetPixelDepth)) ();
  };
  var $IM0E = function () {
    return ($IM0E = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.GetRenderState)) ();
  };
  var $IM0F = function () {
    return ($IM0F = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.GetShaderParam)) ();
  };
  var $IM10 = function () {
    return ($IM10 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.GetShaderParamList)) ();
  };
  var $IM11 = function () {
    return ($IM11 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.RemoveVertices)) ();
  };
  var $IM12 = function () {
    return ($IM12 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.RemoveNormals)) ();
  };
  var $IM13 = function () {
    return ($IM13 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.RemoveColors)) ();
  };
  var $IM14 = function () {
    return ($IM14 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.RemoveUVs)) ();
  };
  var $IM15 = function () {
    return ($IM15 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.RemoveTriangles)) ();
  };
  var $IM16 = function () {
    return ($IM16 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.RemoveBoneWeights)) ();
  };
  var $IM17 = function () {
    return ($IM17 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.RemoveBoneIndices)) ();
  };
  var $IM18 = function () {
    return ($IM18 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.CreateMeshImp)) ();
  };
  var $IM19 = function () {
    return ($IM19 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetColors)) ();
  };
  var $IM1A = function () {
    return ($IM1A = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetVertices)) ();
  };
  var $IM1B = function () {
    return ($IM1B = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetUVs)) ();
  };
  var $IM1C = function () {
    return ($IM1C = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetNormals)) ();
  };
  var $IM1D = function () {
    return ($IM1D = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetBoneIndices)) ();
  };
  var $IM1E = function () {
    return ($IM1E = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetBoneWeights)) ();
  };
  var $IM1F = function () {
    return ($IM1F = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetTriangles)) ();
  };
  var $IM20 = function () {
    return ($IM20 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.Render)) ();
  };
  var $IM21 = function () {
    return ($IM21 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.set_ClearDepth)) ();
  };
  var $IM22 = function () {
    return ($IM22 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetCubeMapRenderTarget)) ();
  };
  var $IM23 = function () {
    return ($IM23 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetRenderState)) ();
  };
  var $IM24 = function () {
    return ($IM24 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm03.Fusee.Engine.Common.RenderState, $asm0E.System.UInt32)).GetEnumerator)) ();
  };
  var $IM25 = function () {
    return ($IM25 = JSIL.Memoize($asm0E.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM26 = function () {
    return ($IM26 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm03.Fusee.Engine.Common.RenderState, $asm0E.System.UInt32)).get_Current)) ();
  };
  var $IM27 = function () {
    return ($IM27 = JSIL.Memoize($asm0E.System.IDisposable.Dispose)) ();
  };
  var $IM28 = function () {
    return ($IM28 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetRenderTarget)) ();
  };
  var $IM29 = function () {
    return ($IM29 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShader)) ();
  };
  var $IM2A = function () {
    return ($IM2A = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShaderParam1f)) ();
  };
  var $IM2B = function () {
    return ($IM2B = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShaderParam2f)) ();
  };
  var $IM2C = function () {
    return ($IM2C = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShaderParam3f)) ();
  };
  var $IM2D = function () {
    return ($IM2D = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShaderParam4f)) ();
  };
  var $IM2E = function () {
    return ($IM2E = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShaderParam4fArray)) ();
  };
  var $IM2F = function () {
    return ($IM2F = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShaderParamfloat4x4)) ();
  };
  var $IM30 = function () {
    return ($IM30 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShaderParamMtx4fArray)) ();
  };
  var $IM31 = function () {
    return ($IM31 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShaderParamI)) ();
  };
  var $IM32 = function () {
    return ($IM32 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.SetShaderParamTexture)) ();
  };
  var $IM33 = function () {
    return ($IM33 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.UpdateTextureFromVideoStream)) ();
  };
  var $IM34 = function () {
    return ($IM34 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.UpdateTextureRegion)) ();
  };
  var $IM35 = function () {
    return ($IM35 = JSIL.Memoize($asm03.Fusee.Engine.Common.IRenderContextImp.Viewport)) ();
  };


  function RenderContext__ctor (rci) {
    this._debugLinesEnabled = true;
    this._rci = rci;
    (this.View = $T01().Identity.MemberwiseClone());
    (this.Model = $T01().Identity.MemberwiseClone());
    (this.Projection = $T01().Identity.MemberwiseClone());
    this._col = $T02().White.MemberwiseClone().Tofloat3();
    this._currentShaderParams = new ($T03())();
    this._updatedShaderParams = false;
    this._debugShader = $T04().GetColorShader(this);
    this._debugColor = (this._debugShader).GetShaderParam("color");
  }; 

  function RenderContext_Clear (flags) {
    $IM00().Call(this._rci, null, flags);
  }; 

  function RenderContext_ColorMask (red, green, blue, alpha) {
    $IM01().Call(this._rci, null, red, green, blue, alpha);
  }; 

  function RenderContext_CopyDepthBufferFromDeferredBuffer (texture) {
    $IM02().Call(this._rci, null, texture);
  }; 

  function RenderContext_CreateShader (vs, ps) {
    return new ($T05())(this._rci, $IM03().Call(this._rci, null, vs, ps));
  }; 

  function RenderContext_CreateTexture (imgData, repeat) {
    return $IM04().Call(this._rci, null, imgData.MemberwiseClone(), repeat);
  }; 

  function RenderContext_CreateWritableTexture (width, height, textureFormat) {
    return $IM05().Call(this._rci, null, width, height, textureFormat);
  }; 

  function RenderContext_DebugLine (start, end, color) {
    var debugLinesEnabled = this._debugLinesEnabled;
    if (debugLinesEnabled) {
      start = $T0D().op_Division(start.MemberwiseClone(), 2).MemberwiseClone();
      end = $T0D().op_Division(end.MemberwiseClone(), 2).MemberwiseClone();
      var oldShader = this._currentShader;
      this.SetShader(this._debugShader);
      this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_MVP, this.get_ModelViewProjection().MemberwiseClone());
      this.SetShaderParam4f(this._debugColor, color.MemberwiseClone());
      $IM06().Call(this._rci, null, start.MemberwiseClone(), end.MemberwiseClone(), color.MemberwiseClone());
      var flag = oldShader !== null;
      if (flag) {
        this.SetShader(oldShader);
      }
    }
  }; 

  function RenderContext_get_Bones () {
    return this._bones;
  }; 

  function RenderContext_get_ClearColor () {
    return $IM07().Call(this._rci, null);
  }; 

  function RenderContext_get_ClearDepth () {
    return $IM08().Call(this._rci, null);
  }; 

  function RenderContext_get_CurrentShader () {
    return this._currentShader;
  }; 

  function RenderContext_get_DebugLinesEnabled () {
    return this._debugLinesEnabled;
  }; 

  function RenderContext_get_HasPickingContext () {
    return this.RenderContext$HasPickingContext$value;
  }; 

  function RenderContext_get_InvModel () {
    if (!this._invModelOk) {
      this._invModel = $T01().Invert(this.get_Model().MemberwiseClone()).MemberwiseClone();
      this._invModelOk = true;
    }
    return this._invModel;
  }; 

  function RenderContext_get_InvModelView () {
    if (!this._invModelViewOk) {
      this._invModelView = $T01().Invert(this.get_ModelView().MemberwiseClone()).MemberwiseClone();
      this._invModelViewOk = true;
    }
    return this._invModelView;
  }; 

  function RenderContext_get_InvModelViewProjection () {
    if (!this._invModelViewProjectionOk) {
      this._invModelViewProjection = $T01().Invert(this.get_ModelViewProjection().MemberwiseClone()).MemberwiseClone();
      this._invModelViewProjectionOk = true;
    }
    return this._invModelViewProjection;
  }; 

  function RenderContext_get_InvProjection () {
    if (!this._invProjectionOk) {
      this._invProjection = $T01().Invert(this.get_Projection().MemberwiseClone()).MemberwiseClone();
      this._invProjectionOk = true;
    }
    return this._invProjection;
  }; 

  function RenderContext_get_InvTransModel () {
    if (!this._invTransModelOk) {
      this._invTransModel = $T01().Invert(this.get_TransModel().MemberwiseClone()).MemberwiseClone();
      this._invTransModelOk = true;
    }
    return this._invTransModel;
  }; 

  function RenderContext_get_InvTransModelView () {
    if (!this._invTransModelViewOk) {
      this._invTransModelView = $T01().Invert(this.get_TransModelView().MemberwiseClone()).MemberwiseClone();
      this._invTransModelViewOk = true;
    }
    return this._invTransModelView;
  }; 

  function RenderContext_get_InvTransModelViewProjection () {
    if (!this._invTransModelViewProjectionOk) {
      this._invTransModelViewProjection = $T01().Invert(this.get_TransModelViewProjection().MemberwiseClone()).MemberwiseClone();
      this._invTransModelViewProjectionOk = true;
    }
    return this._invTransModelViewProjection;
  }; 

  function RenderContext_get_InvTransProjection () {
    if (!this._invTransProjectionOk) {
      this._invTransProjection = $T01().Invert(this.get_TransProjection().MemberwiseClone()).MemberwiseClone();
      this._invTransProjectionOk = true;
    }
    return this._invTransProjection;
  }; 

  function RenderContext_get_InvTransView () {
    if (!this._invTransViewOk) {
      this._invTransView = $T01().Invert(this.get_TransView().MemberwiseClone()).MemberwiseClone();
      this._invTransViewOk = true;
    }
    return this._invTransView;
  }; 

  function RenderContext_get_InvView () {
    if (!this._invViewOk) {
      this._invView = $T01().Invert(this.get_View().MemberwiseClone()).MemberwiseClone();
      this._invViewOk = true;
    }
    return this._invView;
  }; 

  function RenderContext_get_Model () {
    return this._model;
  }; 

  function RenderContext_get_ModelView () {
    return this._modelView;
  }; 

  function RenderContext_get_ModelViewProjection () {
    if (!this._modelViewProjectionOk) {
      this._modelViewProjection = $T01().Mult(
        this.get_Projection().MemberwiseClone(), 
        this.get_ModelView().MemberwiseClone()
      ).MemberwiseClone();
      this._modelViewProjectionOk = true;
    }
    return this._modelViewProjection;
  }; 

  function RenderContext_get_Projection () {
    return this._projection;
  }; 

  function RenderContext_get_TransModel () {
    if (!this._transModelOk) {
      this._transModel = $T01().Transpose(this.get_Model().MemberwiseClone());
      this._transModelOk = true;
    }
    return this._transModel;
  }; 

  function RenderContext_get_TransModelView () {
    if (!this._transModelViewOk) {
      this._transModelView = $T01().Transpose(this.get_ModelView().MemberwiseClone());
      this._transModelViewOk = true;
    }
    return this._transModelView;
  }; 

  function RenderContext_get_TransModelViewProjection () {
    if (!this._transModelViewProjectionOk) {
      this._transModelViewProjection = $T01().Transpose(this.get_ModelViewProjection().MemberwiseClone());
      this._transModelViewProjectionOk = true;
    }
    return this._transModelViewProjection;
  }; 

  function RenderContext_get_TransProjection () {
    if (!this._transProjectionOk) {
      this._transProjection = $T01().Transpose(this.get_Projection().MemberwiseClone());
      this._transProjectionOk = true;
    }
    return this._transProjection;
  }; 

  function RenderContext_get_TransView () {
    if (!this._transViewOk) {
      this._transView = $T01().Transpose(this.get_View().MemberwiseClone());
      this._transViewOk = true;
    }
    return this._transView;
  }; 

  function RenderContext_get_View () {
    return this._view;
  }; 

  function RenderContext_get_ViewportHeight () {
    return this.RenderContext$ViewportHeight$value;
  }; 

  function RenderContext_get_ViewportWidth () {
    return this.RenderContext$ViewportWidth$value;
  }; 

  function RenderContext_GetBufferContent (quad, texId) {
    $IM09().Call(this._rci, null, quad.MemberwiseClone(), texId);
  }; 

  function RenderContext_GetHardwareCapabilities (capability) {
    return $IM0A().Call(this._rci, null, capability);
  }; 

  function RenderContext_GetParamValue (program, handle) {
    return $IM0B().Call(this._rci, null, program._spi, handle);
  }; 

  function RenderContext_GetPixelColor (x, y, w, h) {
    return $IM0C().Call(this._rci, null, x, y, w, h);
  }; 

  function RenderContext_GetPixelDepth (x, y) {
    return $IM0D().Call(this._rci, null, x, y);
  }; 

  function RenderContext_GetRenderState (renderState) {
    return $IM0E().Call(this._rci, null, renderState);
  }; 

  function RenderContext_GetShaderParam (program, paramName) {
    return $IM0F().Call(this._rci, null, program._spi, paramName);
  }; 

  function RenderContext_GetShaderParamList (program) {
    return $IM10().Call(this._rci, null, program._spi);
  }; 

  function RenderContext_Remove (m) {
    var flag = m._meshImp === null;
    if (!flag) {
      $IM11().Call(this._rci, null, m._meshImp);
      $IM12().Call(this._rci, null, m._meshImp);
      $IM13().Call(this._rci, null, m._meshImp);
      $IM14().Call(this._rci, null, m._meshImp);
      $IM15().Call(this._rci, null, m._meshImp);
      $IM16().Call(this._rci, null, m._meshImp);
      $IM17().Call(this._rci, null, m._meshImp);
    }
  }; 

  function RenderContext_Render (m) {
    var flag = m._meshImp === null;
    if (flag) {
      m._meshImp = $IM18().Call(this._rci, null);
    }
    var flag2 = !((m.get_Colors() === null) || 
      ((m.get_Colors().length | 0) === 0)) && 
    !m.get_ColorsSet();
    if (flag2) {
      $IM19().Call(this._rci, null, m._meshImp, m.get_Colors());
    }
    var flag3 = !((m.get_Vertices() === null) || 
      ((m.get_Vertices().length | 0) === 0)) && 
    !m.get_VerticesSet();
    if (flag3) {
      $IM1A().Call(this._rci, null, m._meshImp, m.get_Vertices());
    }
    var flag4 = !((m.get_UVs() === null) || 
      ((m.get_UVs().length | 0) === 0)) && 
    !m.get_UVsSet();
    if (flag4) {
      $IM1B().Call(this._rci, null, m._meshImp, m.get_UVs());
    }
    var flag5 = !((m.get_Normals() === null) || 
      ((m.get_Normals().length | 0) === 0)) && 
    !m.get_NormalsSet();
    if (flag5) {
      $IM1C().Call(this._rci, null, m._meshImp, m.get_Normals());
    }
    var flag6 = !((m.get_BoneIndices() === null) || 
      ((m.get_BoneIndices().length | 0) === 0)) && 
    !m.get_BoneIndicesSet();
    if (flag6) {
      $IM1D().Call(this._rci, null, m._meshImp, m.get_BoneIndices());
    }
    var flag7 = !((m.get_BoneWeights() === null) || 
      ((m.get_BoneWeights().length | 0) === 0)) && 
    !m.get_BoneWeightsSet();
    if (flag7) {
      $IM1E().Call(this._rci, null, m._meshImp, m.get_BoneWeights());
    }
    var flag8 = !((m.get_Triangles() === null) || 
      ((m.get_Triangles().length | 0) === 0)) && 
    !m.get_TrianglesSet();
    if (flag8) {
      $IM1F().Call(this._rci, null, m._meshImp, m.get_Triangles());
    }
    $IM20().Call(this._rci, null, m._meshImp);
  }; 

  function RenderContext_set_Bones (value) {
    this._bones = value;
    this.UpdateCurrentShader();
  }; 

  function RenderContext_set_ClearColor (value) {
    (this._rci.ClearColor = value.MemberwiseClone());
  }; 

  function RenderContext_set_ClearDepth (value) {
    $IM21().Call(this._rci, null, value);
  }; 

  function RenderContext_set_DebugLinesEnabled (value) {
    this._debugLinesEnabled = value;
  }; 

  function RenderContext_set_HasPickingContext (value) {
    this.RenderContext$HasPickingContext$value = value;
  }; 

  function RenderContext_set_Model (value) {
    this._model = value.MemberwiseClone();
    this._modelViewProjectionOk = false;
    this._invModelOk = false;
    this._invModelViewOk = false;
    this._invModelViewProjectionOk = false;
    this._invTransModelOk = false;
    this._invTransModelViewOk = false;
    this._invTransModelViewProjectionOk = false;
    this._transModelOk = false;
    this._transModelViewOk = false;
    this._transModelViewProjectionOk = false;
    this._modelView = $S00().CallStatic($T01(), "op_Multiply", null, this._view.MemberwiseClone(), this._model.MemberwiseClone()).MemberwiseClone();
    this.UpdateCurrentShader();
  }; 

  function RenderContext_set_ModelView (value) {
    this._modelView = value.MemberwiseClone();
    this._view = $T01().Identity.MemberwiseClone();
    this._model = value.MemberwiseClone();
    this._modelViewProjectionOk = false;
    this._invModelOk = false;
    this._invViewOk = false;
    this._invModelViewOk = false;
    this._invModelViewProjectionOk = false;
    this._invTransModelOk = false;
    this._invTransViewOk = false;
    this._invTransModelViewOk = false;
    this._invTransModelViewProjectionOk = false;
    this._transModelOk = false;
    this._transViewOk = false;
    this._transModelViewOk = false;
    this._transModelViewProjectionOk = false;
    this.UpdateCurrentShader();
  }; 

  function RenderContext_set_Projection (value) {
    this._projection = value.MemberwiseClone();
    this._modelViewProjectionOk = false;
    this._invProjectionOk = false;
    this._invProjectionOk = false;
    this._invTransProjectionOk = false;
    this._invTransProjectionOk = false;
    this._transProjectionOk = false;
    this._transProjectionOk = false;
    this.UpdateCurrentShader();
  }; 

  function RenderContext_set_View (value) {
    this._view = value.MemberwiseClone();
    this._modelViewProjectionOk = false;
    this._invViewOk = false;
    this._invModelViewOk = false;
    this._invModelViewProjectionOk = false;
    this._invTransViewOk = false;
    this._invTransModelViewOk = false;
    this._invTransModelViewProjectionOk = false;
    this._transViewOk = false;
    this._transModelViewOk = false;
    this._transModelViewProjectionOk = false;
    this._modelView = $S00().CallStatic($T01(), "op_Multiply", null, this._view.MemberwiseClone(), this._model.MemberwiseClone()).MemberwiseClone();
    this.UpdateCurrentShader();
  }; 

  function RenderContext_set_ViewportHeight (value) {
    this.RenderContext$ViewportHeight$value = (value | 0);
  }; 

  function RenderContext_set_ViewportWidth (value) {
    this.RenderContext$ViewportWidth$value = (value | 0);
  }; 

  function RenderContext_SetCubeMapRenderTarget (texture, position) {
    $IM22().Call(this._rci, null, texture, position);
  }; 

  function RenderContext_SetLight$00 (v3, diffuse, ambient, specular, type, id) {
    if ((type | 0) !== 1) {
      if ((type | 0) === 2) {
        this.SetLightActive(id, +type);
        this.SetLightAmbient(id, ambient);
        this.SetLightDiffuse(id, diffuse);
        this.SetLightSpecular(id, specular);
        this.SetLightPosition(id, v3);
      }
    } else {
      this.SetLightActive(id, +type);
      this.SetLightAmbient(id, ambient);
      this.SetLightDiffuse(id, diffuse);
      this.SetLightSpecular(id, specular);
      this.SetLightDirection(id, v3);
    }
  }; 

  function RenderContext_SetLight$01 (position, direction, diffuse, ambient, specular, type, id) {
    this.SetLightActive(id, +type);
    this.SetLightAmbient(id, ambient);
    this.SetLightDiffuse(id, diffuse);
    this.SetLightSpecular(id, specular);
    this.SetLightPosition(id, position);
    this.SetLightDirection(id, direction);
  }; 

  function RenderContext_SetLightActive (lightInx, active) {
    throw $S01().Construct("Removed Single Pass Light Support");
  }; 

  function RenderContext_SetLightAmbient (lightInx, ambientColor) {
    throw $S01().Construct("Removed Single Pass Light Support");
  }; 

  function RenderContext_SetLightDiffuse (lightInx, diffuseColor) {
    throw $S01().Construct("Removed Single Pass Light Support");
  }; 

  function RenderContext_SetLightDirection (lightInx, direction) {
    throw $S01().Construct("Removed Single Pass Light Support");
  }; 

  function RenderContext_SetLightPosition (lightInx, position) {
    throw $S01().Construct("Removed Single Pass Light Support");
  }; 

  function RenderContext_SetLightSpecular (lightInx, specularColor) {
  }; 

  function RenderContext_SetLightSpotAngle (lightInx, angle) {
    throw $S01().Construct("Removed Single Pass Light Support");
  }; 

  function RenderContext_SetRenderState$02 (renderState, value) {
    $IM23().Call(this._rci, null, renderState, value);
  }; 

  function RenderContext_SetRenderState$03 (renderStateSet) {
    var enumerator = $IM24().Call(renderStateSet.get_States(), null);
    try {

      while ($IM25().Call(enumerator, null)) {
        var state = $IM26().Call(enumerator, null);
        var theKey = state.get_Key();
        var theValue = (state.get_Value() >>> 0);
        $IM23().Call(this._rci, null, theKey, theValue);
      }
    } finally {
      if (enumerator !== null) {
        $IM27().Call(enumerator, null);
      }
    }
  }; 

  function RenderContext_SetRenderTarget (texture) {
    $IM28().Call(this._rci, null, texture);
  }; 

  function RenderContext_SetShader (program) {
    this._updatedShaderParams = false;
    var flag = this._currentShader !== program;
    if (flag) {
      this._currentShader = program;
      $IM29().Call(this._rci, null, program._spi);
    }
    this.UpdateShaderParams();
  }; 

  function RenderContext_SetShaderParam1f (param, val) {
    $IM2A().Call(this._rci, null, param, val);
  }; 

  function RenderContext_SetShaderParam2f (param, val) {
    $IM2B().Call(this._rci, null, param, val.MemberwiseClone());
  }; 

  function RenderContext_SetShaderParam3f (param, val) {
    $IM2C().Call(this._rci, null, param, val.MemberwiseClone());
  }; 

  function RenderContext_SetShaderParam4f (param, val) {
    $IM2D().Call(this._rci, null, param, val.MemberwiseClone());
  }; 

  function RenderContext_SetShaderParam4fArray (param, val) {
    $IM2E().Call(this._rci, null, param, val);
  }; 

  function RenderContext_SetShaderParamfloat4x4 (param, val) {
    $IM2F().Call(this._rci, null, param, val.MemberwiseClone());
  }; 

  function RenderContext_SetShaderParamMtx4fArray (param, val) {
    $IM30().Call(this._rci, null, param, val);
  }; 

  function RenderContext_SetShaderParamI (param, val) {
    $IM31().Call(this._rci, null, param, val);
  }; 

  function RenderContext_SetShaderParamTexture$04 (param, texId) {
    $S02().CallVirtual($IM32(), null, this._rci, param, texId);
  }; 

  function RenderContext_SetShaderParamTexture$05 (param, texId, gHandle) {
    $S03().CallVirtual($IM32(), null, this._rci, param, texId, gHandle);
  }; 

  function RenderContext_UpdateCurrentShader () {
    if (this._currentShader !== null) {
      if (!this._updatedShaderParams) {
        this.UpdateShaderParams();
      }
      if (this._currentShaderParams.FUSEE_M !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_M, this.get_Model().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_V !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_V, this.get_View().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_MV !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_MV, this.get_ModelView().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_P !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_P, this.get_Projection().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_MVP !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_MVP, this.get_ModelViewProjection().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_IMV !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_IMV, this.get_InvModelView().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_IP !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_IP, this.get_InvProjection().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_IMVP !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_IMVP, this.get_InvModelViewProjection().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_TMV !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_TMV, this.get_TransModelView().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_TP !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_TP, this.get_TransProjection().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_TMVP !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_TMVP, this.get_TransModelViewProjection().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_ITMV !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_ITMV, this.get_InvTransModelView().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_ITP !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_ITP, this.get_InvTransProjection().MemberwiseClone());
      }
      if (this._currentShaderParams.FUSEE_ITMVP !== null) {
        this.SetShaderParamfloat4x4(this._currentShaderParams.FUSEE_ITMVP, this.get_InvTransModelViewProjection().MemberwiseClone());
      }
      var flag17 = (this._currentShaderParams.FUSEE_BONES !== null) && 
      (this.get_Bones() !== null);
      if (flag17) {
        this.SetShaderParamMtx4fArray(this._currentShaderParams.FUSEE_BONES, this.get_Bones());
      }
    }
  }; 

  function RenderContext_UpdateShaderParams () {
    if (this._currentShader !== null) {
      this._currentShaderParams.FUSEE_M = (this._currentShader).GetShaderParam("FUSEE_M");
      this._currentShaderParams.FUSEE_V = (this._currentShader).GetShaderParam("FUSEE_V");
      this._currentShaderParams.FUSEE_MV = (this._currentShader).GetShaderParam("FUSEE_MV");
      this._currentShaderParams.FUSEE_P = (this._currentShader).GetShaderParam("FUSEE_P");
      this._currentShaderParams.FUSEE_MVP = (this._currentShader).GetShaderParam("FUSEE_MVP");
      this._currentShaderParams.FUSEE_IMV = (this._currentShader).GetShaderParam("FUSEE_IMV");
      this._currentShaderParams.FUSEE_IP = (this._currentShader).GetShaderParam("FUSEE_IP");
      this._currentShaderParams.FUSEE_IMVP = (this._currentShader).GetShaderParam("FUSEE_IMVP");
      this._currentShaderParams.FUSEE_TMV = (this._currentShader).GetShaderParam("FUSEE_TMV");
      this._currentShaderParams.FUSEE_TP = (this._currentShader).GetShaderParam("FUSEE_TP");
      this._currentShaderParams.FUSEE_TMVP = (this._currentShader).GetShaderParam("FUSEE_TMVP");
      this._currentShaderParams.FUSEE_ITMV = (this._currentShader).GetShaderParam("FUSEE_ITMV");
      this._currentShaderParams.FUSEE_ITP = (this._currentShader).GetShaderParam("FUSEE_ITP");
      this._currentShaderParams.FUSEE_ITMVP = (this._currentShader).GetShaderParam("FUSEE_ITMVP");
      this._currentShaderParams.FUSEE_BONES = (this._currentShader).GetShaderParam("FUSEE_BONES[0]");
      this._updatedShaderParams = true;
      this.UpdateCurrentShader();
    }
  }; 

  function RenderContext_UpdateTextureFromVideoStream (stream, tex) {
    $IM33().Call(this._rci, null, stream, tex);
  }; 

  function RenderContext_UpdateTextureRegion (tex, img, startX, startY, width, height) {
    $IM34().Call(this._rci, null, 
      tex, 
      img.MemberwiseClone(), 
      startX, 
      startY, 
      width, 
      height
    );
  }; 

  function RenderContext_Viewport (x, y, width, height) {
    this.RenderContext$ViewportWidth$value = (width | 0);
    this.RenderContext$ViewportHeight$value = (height | 0);
    $IM35().Call(this._rci, null, x, y, width, height);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.RenderContext", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IRenderContextImp")), 
      RenderContext__ctor
    );

    $.Method({Static:false, Public:true }, "Clear", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.ClearFlags")), 
      RenderContext_Clear
    );

    $.Method({Static:false, Public:true }, "ColorMask", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.Boolean, 
          $.Boolean, $.Boolean
        ]), 
      RenderContext_ColorMask
    );

    $.Method({Static:false, Public:true }, "CopyDepthBufferFromDeferredBuffer", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.ITexture")), 
      RenderContext_CopyDepthBufferFromDeferredBuffer
    );

    $.Method({Static:false, Public:true }, "CreateShader", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"), [$.String, $.String]), 
      RenderContext_CreateShader
    );

    $.Method({Static:false, Public:true }, "CreateTexture", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.ITexture"), [$asm00.TypeRef("Fusee.Base.Common.ImageData"), $.Boolean]), 
      RenderContext_CreateTexture
    );

    $.Method({Static:false, Public:true }, "CreateWritableTexture", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.ITexture"), [
          $.Int32, $.Int32, 
          $asm03.TypeRef("Fusee.Engine.Common.WritableTextureFormat")
        ]), 
      RenderContext_CreateWritableTexture
    );

    $.Method({Static:false, Public:true }, "DebugLine", 
      new JSIL.MethodSignature(null, [
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $asm09.TypeRef("Fusee.Math.Core.float4")
        ]), 
      RenderContext_DebugLine
    );

    $.Method({Static:false, Public:true }, "get_Bones", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4x4")])), 
      RenderContext_get_Bones
    );

    $.Method({Static:false, Public:true }, "get_ClearColor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4")), 
      RenderContext_get_ClearColor
    );

    $.Method({Static:false, Public:true }, "get_ClearDepth", 
      JSIL.MethodSignature.Return($.Single), 
      RenderContext_get_ClearDepth
    );

    $.Method({Static:false, Public:true }, "get_CurrentShader", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram")), 
      RenderContext_get_CurrentShader
    );

    $.Method({Static:false, Public:true }, "get_DebugLinesEnabled", 
      JSIL.MethodSignature.Return($.Boolean), 
      RenderContext_get_DebugLinesEnabled
    );

    $.Method({Static:false, Public:true }, "get_HasPickingContext", 
      JSIL.MethodSignature.Return($.Boolean), 
      RenderContext_get_HasPickingContext
    );

    $.Method({Static:false, Public:true }, "get_InvModel", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvModel
    );

    $.Method({Static:false, Public:true }, "get_InvModelView", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvModelView
    );

    $.Method({Static:false, Public:true }, "get_InvModelViewProjection", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvModelViewProjection
    );

    $.Method({Static:false, Public:true }, "get_InvProjection", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvProjection
    );

    $.Method({Static:false, Public:true }, "get_InvTransModel", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvTransModel
    );

    $.Method({Static:false, Public:true }, "get_InvTransModelView", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvTransModelView
    );

    $.Method({Static:false, Public:true }, "get_InvTransModelViewProjection", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvTransModelViewProjection
    );

    $.Method({Static:false, Public:true }, "get_InvTransProjection", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvTransProjection
    );

    $.Method({Static:false, Public:true }, "get_InvTransView", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvTransView
    );

    $.Method({Static:false, Public:true }, "get_InvView", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_InvView
    );

    $.Method({Static:false, Public:true }, "get_Model", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_Model
    );

    $.Method({Static:false, Public:true }, "get_ModelView", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_ModelView
    );

    $.Method({Static:false, Public:true }, "get_ModelViewProjection", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_ModelViewProjection
    );

    $.Method({Static:false, Public:true }, "get_Projection", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_Projection
    );

    $.Method({Static:false, Public:true }, "get_TransModel", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_TransModel
    );

    $.Method({Static:false, Public:true }, "get_TransModelView", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_TransModelView
    );

    $.Method({Static:false, Public:true }, "get_TransModelViewProjection", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_TransModelViewProjection
    );

    $.Method({Static:false, Public:true }, "get_TransProjection", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_TransProjection
    );

    $.Method({Static:false, Public:true }, "get_TransView", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_TransView
    );

    $.Method({Static:false, Public:true }, "get_View", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_get_View
    );

    $.Method({Static:false, Public:false}, "get_ViewportHeight", 
      JSIL.MethodSignature.Return($.Int32), 
      RenderContext_get_ViewportHeight
    );

    $.Method({Static:false, Public:false}, "get_ViewportWidth", 
      JSIL.MethodSignature.Return($.Int32), 
      RenderContext_get_ViewportWidth
    );

    $.Method({Static:false, Public:true }, "GetBufferContent", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.Rectangle"), $asm03.TypeRef("Fusee.Engine.Common.ITexture")]), 
      RenderContext_GetBufferContent
    );

    $.Method({Static:false, Public:true }, "GetHardwareCapabilities", 
      new JSIL.MethodSignature($.UInt32, [$asm03.TypeRef("Fusee.Engine.Common.HardwareCapability")]), 
      RenderContext_GetHardwareCapabilities
    );

    $.Method({Static:false, Public:true }, "GetParamValue", 
      new JSIL.MethodSignature($.Single, [$asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"), $asm03.TypeRef("Fusee.Engine.Common.IShaderParam")]), 
      RenderContext_GetParamValue
    );

    $.Method({Static:false, Public:true }, "GetPixelColor", 
      new JSIL.MethodSignature($asm00.TypeRef("Fusee.Base.Common.ImageData"), [
          $.Int32, $.Int32, 
          $.Int32, $.Int32
        ]), 
      RenderContext_GetPixelColor
    );

    $.Method({Static:false, Public:true }, "GetPixelDepth", 
      new JSIL.MethodSignature($.Single, [$.Int32, $.Int32]), 
      RenderContext_GetPixelDepth
    );

    $.Method({Static:false, Public:true }, "GetRenderState", 
      new JSIL.MethodSignature($.UInt32, [$asm03.TypeRef("Fusee.Engine.Common.RenderState")]), 
      RenderContext_GetRenderState
    );

    $.Method({Static:false, Public:true }, "GetShaderParam", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), [$asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"), $.String]), 
      RenderContext_GetShaderParam
    );

    $.Method({Static:false, Public:true }, "GetShaderParamList", 
      new JSIL.MethodSignature($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm03.TypeRef("Fusee.Engine.Common.ShaderParamInfo")]), [$asm04.TypeRef("Fusee.Engine.Core.ShaderProgram")]), 
      RenderContext_GetShaderParamList
    );

    $.Method({Static:false, Public:true }, "Remove", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      RenderContext_Remove
    );

    $.Method({Static:false, Public:true }, "Render", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      RenderContext_Render
    );

    $.Method({Static:false, Public:true }, "set_Bones", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4x4")])), 
      RenderContext_set_Bones
    );

    $.Method({Static:false, Public:true }, "set_ClearColor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4")), 
      RenderContext_set_ClearColor
    );

    $.Method({Static:false, Public:true }, "set_ClearDepth", 
      JSIL.MethodSignature.Action($.Single), 
      RenderContext_set_ClearDepth
    );

    $.Method({Static:false, Public:true }, "set_DebugLinesEnabled", 
      JSIL.MethodSignature.Action($.Boolean), 
      RenderContext_set_DebugLinesEnabled
    );

    $.Method({Static:false, Public:false}, "set_HasPickingContext", 
      JSIL.MethodSignature.Action($.Boolean), 
      RenderContext_set_HasPickingContext
    );

    $.Method({Static:false, Public:true }, "set_Model", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_set_Model
    );

    $.Method({Static:false, Public:true }, "set_ModelView", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_set_ModelView
    );

    $.Method({Static:false, Public:true }, "set_Projection", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_set_Projection
    );

    $.Method({Static:false, Public:true }, "set_View", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4x4")), 
      RenderContext_set_View
    );

    $.Method({Static:false, Public:false}, "set_ViewportHeight", 
      JSIL.MethodSignature.Action($.Int32), 
      RenderContext_set_ViewportHeight
    );

    $.Method({Static:false, Public:false}, "set_ViewportWidth", 
      JSIL.MethodSignature.Action($.Int32), 
      RenderContext_set_ViewportWidth
    );

    $.Method({Static:false, Public:true }, "SetCubeMapRenderTarget", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.ITexture"), $.Int32]), 
      RenderContext_SetCubeMapRenderTarget
    );

    $.Method({Static:false, Public:true }, "SetLight", 
      new JSIL.MethodSignature(null, [
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float4"), 
          $asm09.TypeRef("Fusee.Math.Core.float4"), $asm09.TypeRef("Fusee.Math.Core.float4"), 
          $.Int32, $.Int32
        ]), 
      RenderContext_SetLight$00
    );

    $.Method({Static:false, Public:true }, "SetLight", 
      new JSIL.MethodSignature(null, [
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $asm09.TypeRef("Fusee.Math.Core.float4"), $asm09.TypeRef("Fusee.Math.Core.float4"), 
          $asm09.TypeRef("Fusee.Math.Core.float4"), $.Int32, 
          $.Int32
        ]), 
      RenderContext_SetLight$01
    );

    $.Method({Static:false, Public:true }, "SetLightActive", 
      new JSIL.MethodSignature(null, [$.Int32, $.Single]), 
      RenderContext_SetLightActive
    );

    $.Method({Static:false, Public:true }, "SetLightAmbient", 
      new JSIL.MethodSignature(null, [$.Int32, $asm09.TypeRef("Fusee.Math.Core.float4")]), 
      RenderContext_SetLightAmbient
    );

    $.Method({Static:false, Public:true }, "SetLightDiffuse", 
      new JSIL.MethodSignature(null, [$.Int32, $asm09.TypeRef("Fusee.Math.Core.float4")]), 
      RenderContext_SetLightDiffuse
    );

    $.Method({Static:false, Public:true }, "SetLightDirection", 
      new JSIL.MethodSignature(null, [$.Int32, $asm09.TypeRef("Fusee.Math.Core.float3")]), 
      RenderContext_SetLightDirection
    );

    $.Method({Static:false, Public:true }, "SetLightPosition", 
      new JSIL.MethodSignature(null, [$.Int32, $asm09.TypeRef("Fusee.Math.Core.float3")]), 
      RenderContext_SetLightPosition
    );

    $.Method({Static:false, Public:true }, "SetLightSpecular", 
      new JSIL.MethodSignature(null, [$.Int32, $asm09.TypeRef("Fusee.Math.Core.float4")]), 
      RenderContext_SetLightSpecular
    );

    $.Method({Static:false, Public:true }, "SetLightSpotAngle", 
      new JSIL.MethodSignature(null, [$.Int32, $.Single]), 
      RenderContext_SetLightSpotAngle
    );

    $.Method({Static:false, Public:true }, "SetRenderState", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.RenderState"), $.UInt32]), 
      RenderContext_SetRenderState$02
    );

    $.Method({Static:false, Public:true }, "SetRenderState", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderStateSet")), 
      RenderContext_SetRenderState$03
    );

    $.Method({Static:false, Public:true }, "SetRenderTarget", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.ITexture")), 
      RenderContext_SetRenderTarget
    );

    $.Method({Static:false, Public:true }, "SetShader", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.ShaderProgram")), 
      RenderContext_SetShader
    );

    $.Method({Static:false, Public:true }, "SetShaderParam1f", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $.Single]), 
      RenderContext_SetShaderParam1f
    );

    $.Method({Static:false, Public:true }, "SetShaderParam2f", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $asm09.TypeRef("Fusee.Math.Core.float2")]), 
      RenderContext_SetShaderParam2f
    );

    $.Method({Static:false, Public:true }, "SetShaderParam3f", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $asm09.TypeRef("Fusee.Math.Core.float3")]), 
      RenderContext_SetShaderParam3f
    );

    $.Method({Static:false, Public:true }, "SetShaderParam4f", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $asm09.TypeRef("Fusee.Math.Core.float4")]), 
      RenderContext_SetShaderParam4f
    );

    $.Method({Static:false, Public:true }, "SetShaderParam4fArray", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4")])]), 
      RenderContext_SetShaderParam4fArray
    );

    $.Method({Static:false, Public:true }, "SetShaderParamfloat4x4", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $asm09.TypeRef("Fusee.Math.Core.float4x4")]), 
      RenderContext_SetShaderParamfloat4x4
    );

    $.Method({Static:false, Public:true }, "SetShaderParamMtx4fArray", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4x4")])]), 
      RenderContext_SetShaderParamMtx4fArray
    );

    $.Method({Static:false, Public:true }, "SetShaderParamI", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $.Int32]), 
      RenderContext_SetShaderParamI
    );

    $.Method({Static:false, Public:true }, "SetShaderParamTexture", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $asm03.TypeRef("Fusee.Engine.Common.ITexture")]), 
      RenderContext_SetShaderParamTexture$04
    );

    $.Method({Static:false, Public:true }, "SetShaderParamTexture", 
      new JSIL.MethodSignature(null, [
          $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"), $asm03.TypeRef("Fusee.Engine.Common.ITexture"), 
          $asm03.TypeRef("Fusee.Engine.Common.GBufferHandle")
        ]), 
      RenderContext_SetShaderParamTexture$05
    );

    $.Method({Static:false, Public:false}, "UpdateCurrentShader", 
      JSIL.MethodSignature.Void, 
      RenderContext_UpdateCurrentShader
    );

    $.Method({Static:false, Public:false}, "UpdateShaderParams", 
      JSIL.MethodSignature.Void, 
      RenderContext_UpdateShaderParams
    );

    $.Method({Static:false, Public:true }, "UpdateTextureFromVideoStream", 
      new JSIL.MethodSignature(null, [$asm03.TypeRef("Fusee.Engine.Common.IVideoStreamImp"), $asm03.TypeRef("Fusee.Engine.Common.ITexture")]), 
      RenderContext_UpdateTextureFromVideoStream
    );

    $.Method({Static:false, Public:true }, "UpdateTextureRegion", 
      new JSIL.MethodSignature(null, [
          $asm03.TypeRef("Fusee.Engine.Common.ITexture"), $asm00.TypeRef("Fusee.Base.Common.ImageData"), 
          $.Int32, $.Int32, 
          $.Int32, $.Int32
        ]), 
      RenderContext_UpdateTextureRegion
    );

    $.Method({Static:false, Public:true }, "Viewport", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32, $.Int32
        ]), 
      RenderContext_Viewport
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_rci", $asm03.TypeRef("Fusee.Engine.Common.IRenderContextImp"));

    $.Field({Static:false, Public:false}, "RenderContext$ViewportWidth$value", $.Int32);

    $.Field({Static:false, Public:false}, "RenderContext$ViewportHeight$value", $.Int32);

    $.Field({Static:false, Public:false}, "_currentShader", $asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_currentShaderParams", $asm04.TypeRef("Fusee.Engine.Core.RenderContext+MatrixParamNames"));

    $.Field({Static:false, Public:false}, "_updatedShaderParams", $.Boolean);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_debugShader", $asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_debugColor", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false}, "_debugLinesEnabled", $.Boolean);

    $.Field({Static:false, Public:false}, "RenderContext$HasPickingContext$value", $.Boolean);

    $.Field({Static:false, Public:false}, "_modelView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_projection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_view", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_model", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_bones", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4x4")]));

    $.Field({Static:false, Public:false}, "_modelViewProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invModel", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invModelView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invModelViewProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invTransView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invTransModel", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invTransModelView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invTransProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_invTransModelViewProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_transView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_transModel", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_transModelView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_transProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_transModelViewProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_modelViewProjectionOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invViewOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invModelOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invModelViewOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invProjectionOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invModelViewProjectionOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invTransViewOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invTransModelOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invTransModelViewOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invTransProjectionOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_invTransModelViewProjectionOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_transViewOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_transModelOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_transModelViewOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_transProjectionOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_transModelViewProjectionOk", $.Boolean);

    $.Field({Static:false, Public:false}, "_col", $asm09.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false}, "ViewportWidth", $.Int32);

    $.Property({Static:false, Public:false}, "ViewportHeight", $.Int32);

    $.Property({Static:false, Public:true }, "HasPickingContext", $.Boolean);

    $.Property({Static:false, Public:true }, "Bones", $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float4x4")]));

    $.Property({Static:false, Public:true }, "View", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "Model", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "ModelView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "Projection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "ModelViewProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvModel", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvModelView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvModelViewProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "TransView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "TransModel", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "TransModelView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "TransProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "TransModelViewProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvTransView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvTransModel", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvTransModelView", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvTransProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "InvTransModelViewProjection", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Property({Static:false, Public:true }, "ClearColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Property({Static:false, Public:true }, "ClearDepth", $.Single);

    $.Property({Static:false, Public:true }, "CurrentShader", $asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"));

    $.Property({Static:false, Public:true }, "DebugLinesEnabled", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.RenderContext+MatrixParamNames */ 

(function MatrixParamNames$Members () {
  var $, $thisType;

  function MatrixParamNames__ctor () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.RenderContext+MatrixParamNames", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      MatrixParamNames__ctor
    );

    $.Field({Static:false, Public:true }, "FUSEE_M", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_V", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_MV", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_P", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_MVP", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_IMV", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_IP", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_IMVP", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_TMV", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_TP", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_TMVP", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_ITMV", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_ITP", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_ITMVP", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:true }, "FUSEE_BONES", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Engine.Core.RenderContext+LightParamNames */ 

(function LightParamNames$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.ValueType"), 
      Name: "Fusee.Engine.Core.RenderContext+LightParamNames", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
      SizeBytes: 1, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.RenderStateSet */ 

(function RenderStateSet$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm03.Fusee.Engine.Common.RenderState, $asm0E.System.UInt32))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm03.Fusee.Engine.Common.RenderState)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm00.Fusee.Base.Common.ColorUint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.BlendOperation)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm03.Fusee.Engine.Common.Cull)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm03.Fusee.Engine.Common.Blend)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm03.Fusee.Engine.Common.FillMode)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm03.Fusee.Engine.Common.Compare)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.UInt32, $asm0E.System.UInt32))) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2_Enumerator.Of($asm0E.System.UInt32, $asm0E.System.UInt32))) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.Collections.Generic.KeyValuePair$b2.Of($asm0E.System.UInt32, $asm0E.System.UInt32))) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm03.Fusee.Engine.Common.RenderState, $asm0E.System.UInt32), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4, [$asm00.Fusee.Base.Common.ColorUint]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm00.Fusee.Base.Common.ColorUint, [$asm0E.System.UInt32]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.UInt32, [$asm00.Fusee.Base.Common.ColorUint]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm00.Fusee.Base.Common.ColorUint, [$asm09.Fusee.Math.Core.float4]))) ();
  };


  function RenderStateSet__ctor () {
    this._states = $S00().Construct();
  }; 

  function RenderStateSet_get_AlphaBlendEnable () {
    return (((this._states).get_Item($T01().AlphaBlendEnable) >>> 0) > 0);
  }; 

  function RenderStateSet_get_BlendFactor () {
    return $S01().CallStatic($T02(), "op_Explicit", null, $S02().CallStatic($T02(), "op_Explicit", null, (this._states).get_Item($T01().BlendFactor)).MemberwiseClone());
  }; 

  function RenderStateSet_get_BlendOperation () {
    return $T03().$Cast((this._states).get_Item($T01().BlendOperation));
  }; 

  function RenderStateSet_get_BlendOperationAlpha () {
    return $T03().$Cast((this._states).get_Item($T01().BlendOperationAlpha));
  }; 

  function RenderStateSet_get_Clipping () {
    return (((this._states).get_Item($T01().Clipping) >>> 0) > 0);
  }; 

  function RenderStateSet_get_CullMode () {
    return $T04().$Cast((this._states).get_Item($T01().CullMode));
  }; 

  function RenderStateSet_get_DestinationBlend () {
    return $T05().$Cast((this._states).get_Item($T01().DestinationBlend));
  }; 

  function RenderStateSet_get_DestinationBlendAlpha () {
    return $T05().$Cast((this._states).get_Item($T01().DestinationBlendAlpha));
  }; 

  function RenderStateSet_get_FillMode () {
    return $T06().$Cast((this._states).get_Item($T01().FillMode));
  }; 

  function RenderStateSet_get_SourceBlend () {
    return $T05().$Cast((this._states).get_Item($T01().SourceBlend));
  }; 

  function RenderStateSet_get_SourceBlendAlpha () {
    return $T05().$Cast((this._states).get_Item($T01().SourceBlendAlpha));
  }; 

  function RenderStateSet_get_States () {
    return this._states;
  }; 

  function RenderStateSet_get_ZEnable () {
    return (((this._states).get_Item($T01().ZEnable) >>> 0) > 0);
  }; 

  function RenderStateSet_get_ZFunc () {
    return $T07().$Cast((this._states).get_Item($T01().ZFunc));
  }; 

  function RenderStateSet_get_ZWriteEnable () {
    return (((this._states).get_Item($T01().ZWriteEnable) >>> 0) > 0);
  }; 

  function RenderStateSet_set_AlphaBlendEnable (value) {
    (this._states).set_Item($T01().AlphaBlendEnable, (
        value
           ? 1
           : 0)
    );
  }; 

  function RenderStateSet_set_BlendFactor (value) {
    (this._states).set_Item($T01().BlendFactor, $S03().CallStatic($T02(), "op_Explicit", null, $S04().CallStatic($T02(), "op_Explicit", null, value.MemberwiseClone())));
  }; 

  function RenderStateSet_set_BlendOperation (value) {
    (this._states).set_Item($T01().BlendOperation, value.valueOf());
  }; 

  function RenderStateSet_set_BlendOperationAlpha (value) {
    (this._states).set_Item($T01().BlendOperationAlpha, value.valueOf());
  }; 

  function RenderStateSet_set_Clipping (value) {
    (this._states).set_Item($T01().Clipping, (
        value
           ? 1
           : 0)
    );
  }; 

  function RenderStateSet_set_CullMode (value) {
    (this._states).set_Item($T01().CullMode, value.valueOf());
  }; 

  function RenderStateSet_set_DestinationBlend (value) {
    (this._states).set_Item($T01().DestinationBlend, value.valueOf());
  }; 

  function RenderStateSet_set_DestinationBlendAlpha (value) {
    (this._states).set_Item($T01().DestinationBlendAlpha, value.valueOf());
  }; 

  function RenderStateSet_set_FillMode (value) {
    (this._states).set_Item($T01().FillMode, value.valueOf());
  }; 

  function RenderStateSet_set_SourceBlend (value) {
    (this._states).set_Item($T01().SourceBlend, value.valueOf());
  }; 

  function RenderStateSet_set_SourceBlendAlpha (value) {
    (this._states).set_Item($T01().SourceBlendAlpha, value.valueOf());
  }; 

  function RenderStateSet_set_ZEnable (value) {
    (this._states).set_Item($T01().ZEnable, (
        value
           ? 1
           : 0)
    );
  }; 

  function RenderStateSet_set_ZFunc (value) {
    (this._states).set_Item($T01().ZFunc, value.valueOf());
  }; 

  function RenderStateSet_set_ZWriteEnable (value) {
    (this._states).set_Item($T01().ZWriteEnable, (
        value
           ? 1
           : 0)
    );
  }; 

  function RenderStateSet_SetRenderStates (renderStateContainer) {
    var enumerator = $T0A().prototype.GetEnumerator.call(renderStateContainer);

    while ($T0B().prototype.MoveNext.call(enumerator)) {
      var renderState = $T0B().prototype.get_Current.call(enumerator);
      (this._states).set_Item(
        $T01().$Cast(renderState.get_Key()), 
        renderState.get_Value()
      );
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.RenderStateSet", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      RenderStateSet__ctor
    );

    $.Method({Static:false, Public:true }, "get_AlphaBlendEnable", 
      JSIL.MethodSignature.Return($.Boolean), 
      RenderStateSet_get_AlphaBlendEnable
    );

    $.Method({Static:false, Public:true }, "get_BlendFactor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4")), 
      RenderStateSet_get_BlendFactor
    );

    $.Method({Static:false, Public:true }, "get_BlendOperation", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.BlendOperation")), 
      RenderStateSet_get_BlendOperation
    );

    $.Method({Static:false, Public:true }, "get_BlendOperationAlpha", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.BlendOperation")), 
      RenderStateSet_get_BlendOperationAlpha
    );

    $.Method({Static:false, Public:true }, "get_Clipping", 
      JSIL.MethodSignature.Return($.Boolean), 
      RenderStateSet_get_Clipping
    );

    $.Method({Static:false, Public:true }, "get_CullMode", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.Cull")), 
      RenderStateSet_get_CullMode
    );

    $.Method({Static:false, Public:true }, "get_DestinationBlend", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.Blend")), 
      RenderStateSet_get_DestinationBlend
    );

    $.Method({Static:false, Public:true }, "get_DestinationBlendAlpha", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.Blend")), 
      RenderStateSet_get_DestinationBlendAlpha
    );

    $.Method({Static:false, Public:true }, "get_FillMode", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.FillMode")), 
      RenderStateSet_get_FillMode
    );

    $.Method({Static:false, Public:true }, "get_SourceBlend", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.Blend")), 
      RenderStateSet_get_SourceBlend
    );

    $.Method({Static:false, Public:true }, "get_SourceBlendAlpha", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.Blend")), 
      RenderStateSet_get_SourceBlendAlpha
    );

    $.Method({Static:false, Public:true }, "get_States", 
      JSIL.MethodSignature.Return($asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0E.TypeRef("System.Collections.Generic.KeyValuePair`2", [$asm03.TypeRef("Fusee.Engine.Common.RenderState"), $.UInt32])])), 
      RenderStateSet_get_States
    );

    $.Method({Static:false, Public:true }, "get_ZEnable", 
      JSIL.MethodSignature.Return($.Boolean), 
      RenderStateSet_get_ZEnable
    );

    $.Method({Static:false, Public:true }, "get_ZFunc", 
      JSIL.MethodSignature.Return($asm03.TypeRef("Fusee.Engine.Common.Compare")), 
      RenderStateSet_get_ZFunc
    );

    $.Method({Static:false, Public:true }, "get_ZWriteEnable", 
      JSIL.MethodSignature.Return($.Boolean), 
      RenderStateSet_get_ZWriteEnable
    );

    $.Method({Static:false, Public:true }, "set_AlphaBlendEnable", 
      JSIL.MethodSignature.Action($.Boolean), 
      RenderStateSet_set_AlphaBlendEnable
    );

    $.Method({Static:false, Public:true }, "set_BlendFactor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4")), 
      RenderStateSet_set_BlendFactor
    );

    $.Method({Static:false, Public:true }, "set_BlendOperation", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.BlendOperation")), 
      RenderStateSet_set_BlendOperation
    );

    $.Method({Static:false, Public:true }, "set_BlendOperationAlpha", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.BlendOperation")), 
      RenderStateSet_set_BlendOperationAlpha
    );

    $.Method({Static:false, Public:true }, "set_Clipping", 
      JSIL.MethodSignature.Action($.Boolean), 
      RenderStateSet_set_Clipping
    );

    $.Method({Static:false, Public:true }, "set_CullMode", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.Cull")), 
      RenderStateSet_set_CullMode
    );

    $.Method({Static:false, Public:true }, "set_DestinationBlend", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.Blend")), 
      RenderStateSet_set_DestinationBlend
    );

    $.Method({Static:false, Public:true }, "set_DestinationBlendAlpha", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.Blend")), 
      RenderStateSet_set_DestinationBlendAlpha
    );

    $.Method({Static:false, Public:true }, "set_FillMode", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.FillMode")), 
      RenderStateSet_set_FillMode
    );

    $.Method({Static:false, Public:true }, "set_SourceBlend", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.Blend")), 
      RenderStateSet_set_SourceBlend
    );

    $.Method({Static:false, Public:true }, "set_SourceBlendAlpha", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.Blend")), 
      RenderStateSet_set_SourceBlendAlpha
    );

    $.Method({Static:false, Public:true }, "set_ZEnable", 
      JSIL.MethodSignature.Action($.Boolean), 
      RenderStateSet_set_ZEnable
    );

    $.Method({Static:false, Public:true }, "set_ZFunc", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.Compare")), 
      RenderStateSet_set_ZFunc
    );

    $.Method({Static:false, Public:true }, "set_ZWriteEnable", 
      JSIL.MethodSignature.Action($.Boolean), 
      RenderStateSet_set_ZWriteEnable
    );

    $.Method({Static:false, Public:true }, "SetRenderStates", 
      JSIL.MethodSignature.Action($asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.UInt32, $.UInt32])), 
      RenderStateSet_SetRenderStates
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_states", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$asm03.TypeRef("Fusee.Engine.Common.RenderState"), $.UInt32]));

    $.Property({Static:false, Public:true }, "FillMode", $asm03.TypeRef("Fusee.Engine.Common.FillMode"));

    $.Property({Static:false, Public:true }, "CullMode", $asm03.TypeRef("Fusee.Engine.Common.Cull"));

    $.Property({Static:false, Public:true }, "Clipping", $.Boolean);

    $.Property({Static:false, Public:true }, "AlphaBlendEnable", $.Boolean);

    $.Property({Static:false, Public:true }, "BlendOperation", $asm03.TypeRef("Fusee.Engine.Common.BlendOperation"));

    $.Property({Static:false, Public:true }, "BlendOperationAlpha", $asm03.TypeRef("Fusee.Engine.Common.BlendOperation"));

    $.Property({Static:false, Public:true }, "SourceBlend", $asm03.TypeRef("Fusee.Engine.Common.Blend"));

    $.Property({Static:false, Public:true }, "DestinationBlend", $asm03.TypeRef("Fusee.Engine.Common.Blend"));

    $.Property({Static:false, Public:true }, "SourceBlendAlpha", $asm03.TypeRef("Fusee.Engine.Common.Blend"));

    $.Property({Static:false, Public:true }, "DestinationBlendAlpha", $asm03.TypeRef("Fusee.Engine.Common.Blend"));

    $.Property({Static:false, Public:true }, "BlendFactor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Property({Static:false, Public:true }, "ZEnable", $.Boolean);

    $.Property({Static:false, Public:true }, "ZFunc", $asm03.TypeRef("Fusee.Engine.Common.Compare"));

    $.Property({Static:false, Public:true }, "ZWriteEnable", $.Boolean);

    $.Property({Static:false, Public:true }, "States", $asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0E.TypeRef("System.Collections.Generic.KeyValuePair`2", [$asm03.TypeRef("Fusee.Engine.Common.RenderState"), $.UInt32])]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Engine.Core.EffectPassDeclaration */ 

(function EffectPassDeclaration$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.ValueType"), 
      Name: "Fusee.Engine.Core.EffectPassDeclaration", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "StateSet", $asm04.TypeRef("Fusee.Engine.Core.RenderStateSet"));

    $.Field({Static:false, Public:true }, "VS", $.String);

    $.Field({Static:false, Public:true }, "PS", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Engine.Core.EffectParameterDeclaration */ 

(function EffectParameterDeclaration$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.ValueType"), 
      Name: "Fusee.Engine.Core.EffectParameterDeclaration", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "Name", $.String);

    $.Field({Static:false, Public:true }, "Value", $.Object);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.EffectParam */ 

(function EffectParam$Members () {
  var $, $thisType;

  function EffectParam__ctor () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.EffectParam", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      EffectParam__ctor
    );

    $.Field({Static:false, Public:true }, "Info", $asm03.TypeRef("Fusee.Engine.Common.ShaderParamInfo"));

    $.Field({Static:false, Public:true }, "Value", $.Object);

    $.Field({Static:false, Public:true }, "ShaderInxs", $asm0E.TypeRef("System.Collections.Generic.List`1", [$.Int32]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.ShaderEffect */ 

(function ShaderEffect$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Engine.Core.EffectPassDeclaration))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.ArgumentNullException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderStateSet)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderProgram)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm0E.System.Object))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.Collections.IEnumerator)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Engine.Core.EffectParameterDeclaration)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.IDisposable)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.Exception)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm04.Fusee.Engine.Core.EffectParam)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize(System.Array.Of($asm0E.System.String))) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm04.Fusee.Engine.Core.EffectParam))) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.EffectParam)))) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.ShaderParamInfo))) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.EffectParam))) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.ShaderParamInfo))) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm03.Fusee.Engine.Common.ShaderParamInfo)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm0E.System.Type)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0E.System.Double)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize(System.Array.Of($asm0E.System.Object))) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.Int32))) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm0E.System.Int32))) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float4x4))) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm03.Fusee.Engine.Common.ITexture)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentNullException, [$asm0E.System.String, $asm0E.System.String]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm0E.System.Object), null))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Exception, [$asm0E.System.String, $asm0E.System.Exception]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.Dictionary$b2.Of($asm0E.System.String, $asm04.Fusee.Engine.Core.EffectParam), null))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.EffectParam)), null))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.Collections.Generic.List`1", [$asm04.TypeRef("Fusee.Engine.Core.EffectParam")])]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.EffectParam), null))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Boolean, [$asm0E.System.Type]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Exception, [$asm0E.System.String]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.TypeRef("System.Int32")]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.Generic.List$b1.Of($asm0E.System.Int32), [$asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0E.TypeRef("System.Int32")])]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.EffectParam")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration).GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0E.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration).get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0E.System.IDisposable.Dispose)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm03.Fusee.Engine.Common.ShaderParamInfo).GetEnumerator)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm03.Fusee.Engine.Common.ShaderParamInfo).get_Current)) ();
  };


  function ShaderEffect__ctor (effectPasses, effectParameters) {
    var flag = (effectPasses === null) || 
    ((effectPasses.length | 0) === 0);
    if (flag) {
      throw $S00().Construct("effectPasses", "must not be null and must contain at least one pass");
    }
    var nPasses = (effectPasses.length | 0);
    this._states = JSIL.Array.New($T05(), nPasses);
    this._compiledShaders = JSIL.Array.New($T06(), nPasses);
    this._vertexShaderSrc = JSIL.Array.New($T07(), nPasses);
    this._pixelShaderSrc = JSIL.Array.New($T07(), nPasses);

    for (var i = 0; i < nPasses; i = ((i + 1) | 0)) {
      this._states[i] = effectPasses[i].StateSet;
      this._vertexShaderSrc[i] = effectPasses[i].VS;
      this._pixelShaderSrc[i] = effectPasses[i].PS;
    }
    this._paramDecl = $S01().Construct();
    var flag2 = effectParameters !== null;
    if (flag2) {
      var enumerator = $IM00().Call(effectParameters, null);
      try {

        while ($IM01().Call(enumerator, null)) {
          var param = $IM02().Call(enumerator, null).MemberwiseClone();
          (this._paramDecl).Add(param.Name, param.Value);
        }
      } finally {
        if (enumerator !== null) {
          $IM03().Call(enumerator, null);
        }
      }
    }
  }; 

  function ShaderEffect_AttachToContext (rc, $exception) {
    var initValue = new JSIL.BoxedVariable(null);
    var paramExisting = new JSIL.BoxedVariable(null);
    if (rc === null) {
      throw $S00().Construct("rc", "must pass a valid render context.");
    }
    this._rc = rc;
    var i = 0;
    var nPasses = (this._vertexShaderSrc.length | 0);
    try {

      for (i = 0; i < nPasses; i = ((i + 1) | 0)) {
        this._compiledShaders[i] = (this._rc).CreateShader(this._vertexShaderSrc[i], this._pixelShaderSrc[i]);
      }
    } catch ($exception) {
      throw $S02().Construct(JSIL.ConcatString("Error while compiling shader for pass ", $T04().$Box(i)), $exception);
    }
    this._parameters = $S03().Construct();
    this._paramsPerPass = $S04().Construct();

    for (i = 0; i < nPasses; i = ((i + 1) | 0)) {
      var paramList = (this._rc).GetShaderParamList(this._compiledShaders[i]);
      $S05().CallVirtual("Add", null, this._paramsPerPass, $S06().Construct());
      var enumerator = $IM04().Call(paramList, null);
      try {

        while ($IM01().Call(enumerator, null)) {
          var paramNew = $IM05().Call(enumerator, null).MemberwiseClone();
          var flag2 = (this._paramDecl).TryGetValue(paramNew.Name, /* ref */ initValue);
          if (flag2) {
            var initValType = JSIL.GetType(initValue.get());
            var flag3 = !(!((paramNew.Type !== $T04().__Type__) && 
                (paramNew.Type !== $T19().__Type__)) && 
              ((initValType === $T04().__Type__) || 
                (initValType === $T19().__Type__) || 
                (initValType === $T1A().__Type__))) && 
            !$S07().CallVirtual("IsAssignableFrom", null, paramNew.Type, initValType);
            if (flag3) {
              throw $S08().Construct(JSIL.ConcatString.apply(null, JSIL.Array.New($T0F(), ["Error preparing effect pass ", $T04().$Box(i), ". Shader parameter ", (paramNew.Type).toString(), " ", paramNew.Name, " was defined as ", initValType.toString(), " ", paramNew.Name, " during initialization (different types)."])));
            }
            var flag4 = (this._parameters).TryGetValue(paramNew.Name, /* ref */ paramExisting);
            if (flag4) {
              var flag5 = ((paramExisting.get().Info.Size | 0) !== (paramNew.Size | 0)) || 
              (paramExisting.get().Info.Type !== paramNew.Type);
              if (flag5) {
                throw $S08().Construct(JSIL.ConcatString.apply(null, JSIL.Array.New($T0F(), ["Error preparing effect pass ", $T04().$Box(i), ". Shader parameter ", paramNew.Name, " already defined with a different type in effect pass ", $T04().$Box((paramExisting.get().ShaderInxs).get_Item(0))])));
              }
              $S09().CallVirtual("Add", null, paramExisting.get().ShaderInxs, i);
            } else {
              var effectParam = new ($T10())();
              effectParam.Info = paramNew.MemberwiseClone();
              effectParam.ShaderInxs = $S0A().Construct($T1D().$Cast(JSIL.Array.New($T04(), [i])));
              effectParam.Value = initValue.get();
              paramExisting.set(effectParam);
              (this._parameters).Add(paramNew.Name, paramExisting.get());
            }
            $S0B().CallVirtual("Add", null, (this._paramsPerPass).get_Item(i), paramExisting.get());
          }
        }
      } finally {
        if (enumerator !== null) {
          $IM03().Call(enumerator, null);
        }
      }
    }
  }; 

  function ShaderEffect_DetachFromContext () {
    this._parameters = null;
    this._paramsPerPass = null;
    this._paramDecl = null;
    this._compiledShaders = null;
    this._rc = null;
  }; 

  function ShaderEffect_GetEffectParam (name) {
    var param = new JSIL.BoxedVariable(null);
    var flag = (this._parameters).TryGetValue(name, /* ref */ param);
    if (flag) {
      var result = param.get().Value;
    } else {
      result = null;
    }
    return result;
  }; 

  function ShaderEffect_RenderMesh (mesh, $exception) {
    var $temp00;
    var i = 0;
    var nPasses = (this._vertexShaderSrc.length | 0);
    try {

      for (i = 0; i < nPasses; i = ((i + 1) | 0)) {
        (this._rc).SetShader(this._compiledShaders[i]);

        for (var a$0 = (this._paramsPerPass).get_Item(i)._items, i$0 = 0, l$0 = ((this._paramsPerPass).get_Item(i)._size | 0); i$0 < l$0; ($temp00 = i$0, 
            i$0 = ((i$0 + 1) | 0), 
            $temp00)) {
          var param = a$0[i$0];
          var flag = param.Info.Type === $T04().__Type__;
          if (flag) {
            (this._rc).SetShaderParamI(param.Info.Handle, $T04().$Cast(param.Value));
          } else {
            var flag2 = param.Info.Type === $T19().__Type__;
            if (flag2) {
              (this._rc).SetShaderParam1f(param.Info.Handle, $T19().$Cast(param.Value));
            } else {
              var flag3 = param.Info.Type === $T1F().__Type__;
              if (flag3) {
                (this._rc).SetShaderParam2f(param.Info.Handle, $T1F().$Cast(param.Value).MemberwiseClone());
              } else {
                var flag4 = param.Info.Type === $T20().__Type__;
                if (flag4) {
                  (this._rc).SetShaderParam3f(param.Info.Handle, $T20().$Cast(param.Value).MemberwiseClone());
                } else {
                  var flag5 = param.Info.Type === $T21().__Type__;
                  if (flag5) {
                    (this._rc).SetShaderParam4f(param.Info.Handle, $T21().$Cast(param.Value).MemberwiseClone());
                  } else {
                    var flag6 = param.Info.Type === $T22().__Type__;
                    if (flag6) {
                      (this._rc).SetShaderParamfloat4x4(param.Info.Handle, $T22().$Cast(param.Value).MemberwiseClone());
                    } else {
                      var flag7 = param.Info.Type === $T23().__Type__;
                      if (flag7) {
                        (this._rc).SetShaderParamMtx4fArray(param.Info.Handle, $T23().$Cast(param.Value));
                      } else {
                        var flag8 = param.Info.Type === $T24().__Type__;
                        if (flag8) {
                          (this._rc).SetShaderParamTexture(param.Info.Handle, $T24().$Cast(param.Value));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        (this._rc).SetRenderState(this._states[i]);
        (this._rc).Render(mesh);
      }
    } catch ($exception) {
      throw $S02().Construct(JSIL.ConcatString("Error while rendering pass ", $T04().$Box(i)), $exception);
    }
  }; 

  function ShaderEffect_SetEffectParam (name, value) {
    var param = new JSIL.BoxedVariable(null);
    if (this._parameters !== null) {
      var flag2 = (this._parameters).TryGetValue(name, /* ref */ param);
      if (flag2) {
        param.get().Value = value;
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.ShaderEffect", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$asm04.TypeRef("Fusee.Engine.Core.EffectPassDeclaration")]), $asm0E.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm04.TypeRef("Fusee.Engine.Core.EffectParameterDeclaration")])]), 
      ShaderEffect__ctor
    );

    $.Method({Static:false, Public:true }, "AttachToContext", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      ShaderEffect_AttachToContext
    );

    $.Method({Static:false, Public:true }, "DetachFromContext", 
      JSIL.MethodSignature.Void, 
      ShaderEffect_DetachFromContext
    );

    $.Method({Static:false, Public:true }, "GetEffectParam", 
      new JSIL.MethodSignature($.Object, [$.String]), 
      ShaderEffect_GetEffectParam
    );

    $.Method({Static:false, Public:true }, "RenderMesh", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      ShaderEffect_RenderMesh
    );

    $.Method({Static:false, Public:true }, "SetEffectParam", 
      new JSIL.MethodSignature(null, [$.String, $.Object]), 
      ShaderEffect_SetEffectParam
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_states", $jsilcore.TypeRef("System.Array", [$asm04.TypeRef("Fusee.Engine.Core.RenderStateSet")]));

    $.Field({Static:false, Public:false}, "_compiledShaders", $jsilcore.TypeRef("System.Array", [$asm04.TypeRef("Fusee.Engine.Core.ShaderProgram")]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_vertexShaderSrc", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_pixelShaderSrc", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "_parameters", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $asm04.TypeRef("Fusee.Engine.Core.EffectParam")]));

    $.Field({Static:false, Public:false}, "_paramsPerPass", $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm0E.TypeRef("System.Collections.Generic.List`1", [$asm04.TypeRef("Fusee.Engine.Core.EffectParam")])]));

    $.Field({Static:false, Public:false}, "_paramDecl", $asm0E.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.Object]));

    $.Field({Static:false, Public:false}, "_rc", $asm04.TypeRef("Fusee.Engine.Core.RenderContext"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum Fusee.Engine.Core.Stereo3DEye */ 

JSIL.MakeEnum(
  {
    FullName: "Fusee.Engine.Core.Stereo3DEye", 
    BaseType: $asm0E.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Left: 0, 
    Right: 1, 
  }
);

/* enum Fusee.Engine.Core.Stereo3DMode */ 

JSIL.MakeEnum(
  {
    FullName: "Fusee.Engine.Core.Stereo3DMode", 
    BaseType: $asm0E.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Anaglyph: 0, 
    Oculus: 1, 
  }
);

/* class Fusee.Engine.Core.Stereo3DParams */ 

(function Stereo3DParams$Members () {
  var $, $thisType;

  JSIL.MakeStaticClass("Fusee.Engine.Core.Stereo3DParams", false, [], function ($ib) {
    $ = $ib;

    $.Field({Static:true , Public:false}, "EyeDistance", $.Single, 6);

    $.Field({Static:true , Public:false}, "Convergence", $.Single, 0);


    function Stereo3DParams__cctor () {
      $thisType.EyeDistance = 6;
      $thisType.Convergence = 0;
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      Stereo3DParams__cctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Stereo3D */ 

(function Stereo3D$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.Stereo3DMode)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm00.Fusee.Base.Common.ImageData)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm00.Fusee.Base.Common.ImagePixelFormat)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIImage)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIElement)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderProgram)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm03.Fusee.Engine.Common.ClearFlags)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm04.Fusee.Engine.Core.Stereo3DEye)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm04.Fusee.Engine.Core.Stereo3DParams)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm03.Fusee.Engine.Common.Rectangle)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.Fusee.Engine.Core.GUI.GUIImage, [
        $asm00.Fusee.Base.Common.ImageData, $asm0E.System.Int32, 
        $asm0E.System.Int32, $asm0E.System.Int32, 
        $asm0E.System.Int32
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float4, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float3, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };


  function Stereo3D__ctor (mode, width, height) {
    this._activeMode = mode;
    this._screenWidth = (width | 0);
    this._screenHeight = (height | 0);
  }; 

  function Stereo3D_AttachToContext (rc) {
    this._rc = rc;
    this._clearColor = rc.get_ClearColor().MemberwiseClone();
    var imgData = new ($T03())();
    imgData.Width = (this._screenWidth | 0);
    imgData.Height = (this._screenHeight | 0);
    imgData.PixelFormat = $T04().RGBA;
    imgData.Stride = 4;
    this._contentLTex = (this._rc).CreateTexture(imgData.MemberwiseClone(), false);
    this._contentRTex = (this._rc).CreateTexture(imgData.MemberwiseClone(), false);
    var activeMode = this._activeMode;
    if ((activeMode.valueOf() | 0) !== 0) {
      if (activeMode === $T00().Oculus) {
        this._guiLImage = $S00().Construct(new ($T03())(), 0, 0, (((this._screenWidth | 0) / 2) | 0), this._screenHeight);
        (this._guiLImage).AttachToContext(rc);
        (this._guiLImage).Refresh();
        this._guiRImage = $S00().Construct(new ($T03())(), (((this._screenWidth | 0) / 2) | 0), 0, (((this._screenWidth | 0) / 2) | 0), this._screenHeight);
        (this._guiRImage).AttachToContext(rc);
        (this._guiRImage).Refresh();
        this._shaderProgram = (this._rc).CreateShader("\r\n            attribute vec3 fuVertex;\r\n            attribute vec2 fuUV;\r\n            attribute vec4 fuColor;\r\n\r\n            varying vec2 vUV;\r\n\r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n                gl_Position = vec4(fuVertex, 1);\r\n            }", "\r\n            uniform sampler2D vTexture;\r\n\r\n            uniform vec2 LensCenter;\r\n            uniform vec2 ScreenCenter;\r\n            uniform vec2 Scale;\r\n            uniform vec2 ScaleIn;\r\n            uniform vec4 HmdWarpParam;\r\n\r\n            varying vec2 vUV;\r\n\r\n            vec2 HmdWarp(vec2 texIn)\r\n            {\r\n                vec2 theta = (texIn - LensCenter) * ScaleIn;\r\n                float rSq = theta.x * theta.x + theta.y * theta.y;\r\n                vec2 theta1 = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\r\n                return LensCenter + Scale * theta1;\r\n            }\r\n\r\n            void main()\r\n            {\r\n                vec2 tc = HmdWarp(vUV.xy);\r\n\t            if (any(bvec2(clamp(tc,ScreenCenter-vec2(0.25,0.5), ScreenCenter+vec2(0.25,0.5)) - tc)))\r\n\t            {\r\n\t\t            gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);\r\n\t\t            return;\r\n\t            }\r\n\r\n\t            gl_FragColor = texture(vTexture, tc);\r\n            }");
        this._shaderTexture = (this._shaderProgram).GetShaderParam("vTexture");
        this._lensCenterParam = (this._shaderProgram).GetShaderParam("LensCenter");
        this._screenCenterParam = (this._shaderProgram).GetShaderParam("ScreenCenter");
        this._scaleParam = (this._shaderProgram).GetShaderParam("Scale");
        this._scaleInParam = (this._shaderProgram).GetShaderParam("ScaleIn");
        this._hdmWarpParam = (this._shaderProgram).GetShaderParam("HmdWarpParam");
      }
    } else {
      this._shaderProgram = (this._rc).CreateShader("\r\n            attribute vec3 fuVertex;\r\n            attribute vec2 fuUV;\r\n            attribute vec4 fuColor;\r\n\r\n            varying vec2 vUV;\r\n\r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n                gl_Position = vec4(fuVertex, 1);\r\n            }", "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n        \r\n            uniform sampler2D vTexture;\r\n            varying vec2 vUV;\r\n\r\n            void main()\r\n            {\r\n                vec4 colTex = texture2D(vTexture, vUV);\r\n                vec4 _redBalance = vec4(0.1, 0.65, 0.25, 0);\r\n                float _redColor = (colTex.r * _redBalance.r + colTex.g * _redBalance.g + colTex.b * _redBalance.b) * 1.5;\r\n                gl_FragColor = vec4(_redColor, colTex.g, colTex.b, 1) * 1.4; // * dot(vNormal, vec3(0, 0, -1))  lefthanded change???\r\n            }");
      this._shaderTexture = (this._shaderProgram).GetShaderParam("vTexture");
      this._guiLImage = $S00().Construct(new ($T03())(), 0, 0, this._screenWidth, this._screenHeight);
      (this._guiLImage).AttachToContext(rc);
      (this._guiLImage).Refresh();
    }
  }; 

  function Stereo3D_Display () {
    (this._rc.ClearColor = $S01().Construct(0, 0, 0, 0));
    (this._rc).Clear($T09().$Flags("Color", "Depth"));
    var currShader = (this._rc).get_CurrentShader();
    var activeMode = this._activeMode;
    if ((activeMode.valueOf() | 0) !== 0) {
      if (activeMode === $T00().Oculus) {
        (this._rc).SetShader(this._shaderProgram);
        this.RenderDistortedEye($T0A().Left);
        this.RenderDistortedEye($T0A().Right);
      }
    } else {
      (this._rc).SetShader(this._shaderProgram);
      this.RenderColorMaskedEye(
        $T0A().Left, 
        true, 
        false, 
        false, 
        false
      );
      (this._rc).Clear($T09().Depth);
      this.RenderColorMaskedEye(
        $T0A().Right, 
        false, 
        true, 
        true, 
        false
      );
      (this._rc).ColorMask(true, true, true, false);
    }
    (this._rc).SetShader(currShader);
  }; 

  function Stereo3D_get_CurrentEye () {
    return this._currentEye;
  }; 

  function Stereo3D_LookAt3D (eye, eyeV, target, up) {
    var x = +(
      ((eye.valueOf() | 0) === 0)
         ? (+eyeV.x - +$T0D().EyeDistance)
         : (+eyeV.x + +$T0D().EyeDistance))
    ;
    var newEye = $S02().Construct(x, eyeV.y, eyeV.z);
    var newTarget = $S02().Construct(target.x, target.y, target.z);
    return $T0E().LookAt(newEye, newTarget.MemberwiseClone(), up.MemberwiseClone());
  }; 

  function Stereo3D_Prepare (eye) {
    this._currentEye = eye;
    if (this._activeMode === $T00().Oculus) {
      this._currentEye = eye;
      if ((eye.valueOf() | 0) !== 0) {
        if (eye === $T0A().Right) {
          (this._rc).Viewport((((this._screenWidth | 0) / 2) | 0), 100, (((this._screenWidth | 0) / 2) | 0), (((this._screenHeight | 0) - 100) | 0));
        }
      } else {
        (this._rc).Viewport(0, 100, (((this._screenWidth | 0) / 2) | 0), (((this._screenHeight | 0) - 100) | 0));
      }
    }
    (this._rc.ClearColor = this._clearColor.MemberwiseClone());
    (this._rc).Clear($T09().$Flags("Color", "Depth"));
  }; 

  function Stereo3D_RenderColorMaskedEye (eye, red, green, blue, alpha) {
    (this._rc).SetShaderParamTexture(this._shaderTexture, (
        ((eye.valueOf() | 0) === 0)
           ? this._contentLTex
           : this._contentRTex)
    );
    (this._rc).ColorMask(red, green, blue, alpha);
    (this._rc).Render(this._guiLImage.GUIElement$GUIMesh$value);
  }; 

  function Stereo3D_RenderDistortedEye (eye) {
    var lensCenter = new ($T10())(), screenCenter = new ($T10())();
    var scale = $S03().Construct(0.1469278, 0.2350845);
    var scaleIn = $S03().Construct(2, 2.5);
    var hdmWarp = $S01().Construct(1, 0.22, 0.24, 0);
    if (eye === $T0A().Left) {
      (this._rc).SetShaderParamTexture(this._shaderTexture, this._contentLTex);
      (lensCenter = lensCenter.MemberwiseClone(), 
        $T10().prototype._ctor.call(lensCenter, 0.3125, 0.5));
      (screenCenter = screenCenter.MemberwiseClone(), 
        $T10().prototype._ctor.call(screenCenter, 0.25, 0.5));
    } else {
      (this._rc).SetShaderParamTexture(this._shaderTexture, this._contentRTex);
      (lensCenter = lensCenter.MemberwiseClone(), 
        $T10().prototype._ctor.call(lensCenter, 0.6875, 0.5));
      (screenCenter = screenCenter.MemberwiseClone(), 
        $T10().prototype._ctor.call(screenCenter, 0.75, 0.5));
    }
    (this._rc).SetShaderParam2f(this._lensCenterParam, lensCenter.MemberwiseClone());
    (this._rc).SetShaderParam2f(this._screenCenterParam, screenCenter.MemberwiseClone());
    (this._rc).SetShaderParam2f(this._scaleParam, scale.MemberwiseClone());
    (this._rc).SetShaderParam2f(this._scaleInParam, scaleIn.MemberwiseClone());
    (this._rc).SetShaderParam4f(this._hdmWarpParam, hdmWarp.MemberwiseClone());
    (this._rc).Render((
        ((eye.valueOf() | 0) === 0)
           ? this._guiLImage.GUIElement$GUIMesh$value
           : this._guiRImage.GUIElement$GUIMesh$value)
    );
  }; 

  function Stereo3D_Save () {
    var activeMode = this._activeMode;
    if ((activeMode.valueOf() | 0) !== 0) {
      if (activeMode === $T00().Oculus) {
        var currentEye = this._currentEye;
        if ((currentEye.valueOf() | 0) !== 0) {
          if (currentEye === $T0A().Right) {
            (this._rc).GetBufferContent(new ($T11())(81, 0, (((this._screenWidth | 0) + 81) | 0), this._screenHeight), this._contentRTex);
          }
        } else {
          (this._rc).GetBufferContent(new ($T11())(-81, 0, (((this._screenWidth | 0) - 81) | 0), this._screenHeight), this._contentLTex);
        }
        (this._rc).Viewport(0, 0, this._screenWidth, this._screenHeight);
      }
    } else {
      (this._rc).GetBufferContent(new ($T11())(0, 0, this._screenWidth, this._screenHeight), (
          (((this._currentEye).valueOf() | 0) === 0)
             ? this._contentLTex
             : this._contentRTex)
      );
    }
  }; 

  function Stereo3D_UpdateOnResize (width, height) {
    this._screenWidth = (width | 0);
    this._screenHeight = (height | 0);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Stereo3D", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Engine.Core.Stereo3DMode"), $.Int32, 
          $.Int32
        ]), 
      Stereo3D__ctor
    );

    $.Method({Static:false, Public:true }, "AttachToContext", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      Stereo3D_AttachToContext
    );

    $.Method({Static:false, Public:true }, "Display", 
      JSIL.MethodSignature.Void, 
      Stereo3D_Display
    );

    $.Method({Static:false, Public:true }, "get_CurrentEye", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.Stereo3DEye")), 
      Stereo3D_get_CurrentEye
    );

    $.Method({Static:false, Public:true , Virtual:true }, "LookAt3D", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.float4x4"), [
          $asm04.TypeRef("Fusee.Engine.Core.Stereo3DEye"), $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3")
        ]), 
      Stereo3D_LookAt3D
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Prepare", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.Stereo3DEye")), 
      Stereo3D_Prepare
    );

    $.Method({Static:false, Public:false}, "RenderColorMaskedEye", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Engine.Core.Stereo3DEye"), $.Boolean, 
          $.Boolean, $.Boolean, 
          $.Boolean
        ]), 
      Stereo3D_RenderColorMaskedEye
    );

    $.Method({Static:false, Public:false}, "RenderDistortedEye", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.Stereo3DEye")), 
      Stereo3D_RenderDistortedEye
    );

    $.Method({Static:false, Public:true }, "Save", 
      JSIL.MethodSignature.Void, 
      Stereo3D_Save
    );

    $.Method({Static:false, Public:true }, "UpdateOnResize", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32]), 
      Stereo3D_UpdateOnResize
    );

    $.Field({Static:false, Public:false}, "_rc", $asm04.TypeRef("Fusee.Engine.Core.RenderContext"));

    $.Field({Static:false, Public:false}, "_clearColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_activeMode", $asm04.TypeRef("Fusee.Engine.Core.Stereo3DMode"));

    $.Field({Static:false, Public:false}, "_currentEye", $asm04.TypeRef("Fusee.Engine.Core.Stereo3DEye"));

    $.Field({Static:false, Public:false}, "_guiLImage", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIImage"));

    $.Field({Static:false, Public:false}, "_guiRImage", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIImage"));

    $.Field({Static:false, Public:false}, "_shaderProgram", $asm04.TypeRef("Fusee.Engine.Core.ShaderProgram"));

    $.Field({Static:false, Public:false}, "_shaderTexture", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false}, "_screenWidth", $.Int32);

    $.Field({Static:false, Public:false}, "_screenHeight", $.Int32);

    $.Field({Static:false, Public:false}, "_contentLTex", $asm03.TypeRef("Fusee.Engine.Common.ITexture"));

    $.Field({Static:false, Public:false}, "_contentRTex", $asm03.TypeRef("Fusee.Engine.Common.ITexture"));

    $.Constant({Static:true , Public:false}, "K0", $.Single, 1);

    $.Constant({Static:true , Public:false}, "K1", $.Single, 0.22);

    $.Constant({Static:true , Public:false}, "K2", $.Single, 0.24);

    $.Constant({Static:true , Public:false}, "K3", $.Single, 0);

    $.Field({Static:false, Public:false}, "_lensCenterParam", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false}, "_screenCenterParam", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false}, "_scaleParam", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false}, "_scaleInParam", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false}, "_hdmWarpParam", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Constant({Static:true , Public:false}, "OculusVs", $.String, "\r\n            attribute vec3 fuVertex;\r\n            attribute vec2 fuUV;\r\n            attribute vec4 fuColor;\r\n\r\n            varying vec2 vUV;\r\n\r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n                gl_Position = vec4(fuVertex, 1);\r\n            }");

    $.Constant({Static:true , Public:false}, "OculusPs", $.String, "\r\n            uniform sampler2D vTexture;\r\n\r\n            uniform vec2 LensCenter;\r\n            uniform vec2 ScreenCenter;\r\n            uniform vec2 Scale;\r\n            uniform vec2 ScaleIn;\r\n            uniform vec4 HmdWarpParam;\r\n\r\n            varying vec2 vUV;\r\n\r\n            vec2 HmdWarp(vec2 texIn)\r\n            {\r\n                vec2 theta = (texIn - LensCenter) * ScaleIn;\r\n                float rSq = theta.x * theta.x + theta.y * theta.y;\r\n                vec2 theta1 = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\r\n                return LensCenter + Scale * theta1;\r\n            }\r\n\r\n            void main()\r\n            {\r\n                vec2 tc = HmdWarp(vUV.xy);\r\n\t            if (any(bvec2(clamp(tc,ScreenCenter-vec2(0.25,0.5), ScreenCenter+vec2(0.25,0.5)) - tc)))\r\n\t            {\r\n\t\t            gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);\r\n\t\t            return;\r\n\t            }\r\n\r\n\t            gl_FragColor = texture(vTexture, tc);\r\n            }");

    $.Constant({Static:true , Public:false}, "AnaglyphVs", $.String, "\r\n            attribute vec3 fuVertex;\r\n            attribute vec2 fuUV;\r\n            attribute vec4 fuColor;\r\n\r\n            varying vec2 vUV;\r\n\r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n                gl_Position = vec4(fuVertex, 1);\r\n            }");

    $.Constant({Static:true , Public:false}, "AnaglyphPs", $.String, "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif\r\n        \r\n            uniform sampler2D vTexture;\r\n            varying vec2 vUV;\r\n\r\n            void main()\r\n            {\r\n                vec4 colTex = texture2D(vTexture, vUV);\r\n                vec4 _redBalance = vec4(0.1, 0.65, 0.25, 0);\r\n                float _redColor = (colTex.r * _redBalance.r + colTex.g * _redBalance.g + colTex.b * _redBalance.b) * 1.5;\r\n                gl_FragColor = vec4(_redColor, colTex.g, colTex.b, 1) * 1.4; // * dot(vNormal, vec3(0, 0, -1))  lefthanded change???\r\n            }");

    $.Property({Static:false, Public:true }, "CurrentEye", $asm04.TypeRef("Fusee.Engine.Core.Stereo3DEye"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.StereoCameraRig */ 

(function StereoCameraRig$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.Stereo3DMode)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.Stereo3D)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.Stereo3DParams)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Engine.Core.Stereo3DEye)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.ArgumentOutOfRangeException)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.Math)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0E.System.Double)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float3, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.ArgumentOutOfRangeException, [$asm0E.System.String]))) ();
  };


  function StereoCameraRig__ctor (mode, width, height, iod) {
    $T03().prototype._ctor.call(this, mode, width, height);
    this.set_Iod(iod);
  }; 

  function StereoCameraRig_get_FocalLength () {
    return this.StereoCameraRig$FocalLength$value;
  }; 

  function StereoCameraRig_get_Iod () {
    return $T04().EyeDistance;
  }; 

  function StereoCameraRig_LookAt3D (eye, eyeV, target, up) {
    var x = +(
      ((eye.valueOf() | 0) === 0)
         ? (+eyeV.x - +((+this.get_Iod() / 2)))
         : (+eyeV.x + +((+this.get_Iod() / 2))))
    ;
    var newEye = $S00().Construct(x, eyeV.y, eyeV.z);
    var newTarget = $S00().Construct(x, target.y, target.z);
    return $T07().LookAt(newEye, newTarget.MemberwiseClone(), up.MemberwiseClone());
  }; 

  function StereoCameraRig_Prepare (eye) {
    (this._rc.Projection = (
        ((eye.valueOf() | 0) === 0)
           ? this._leftFrustum
           : this._rightFrustum)
      .MemberwiseClone());
    $T03().prototype.Prepare.call(this, eye);
  }; 

  function StereoCameraRig_set_FocalLength (value) {
    this.StereoCameraRig$FocalLength$value = +value;
  }; 

  function StereoCameraRig_set_Iod (value) {
    $T04().EyeDistance = +value;
  }; 

  function StereoCameraRig_SetFrustums (rc, fovy, aspectRatio, zNear, zFar, focalLength) {
    this.StereoCameraRig$FocalLength$value = +focalLength;
    this._leftFrustum = this.ViewFrustumShifted(
      fovy, 
      aspectRatio, 
      zNear, 
      zFar, 
      focalLength, 
      true
    ).MemberwiseClone();
    this._rightFrustum = this.ViewFrustumShifted(
      fovy, 
      aspectRatio, 
      zNear, 
      zFar, 
      focalLength, 
      false
    ).MemberwiseClone();
    (rc.Projection = this._leftFrustum.MemberwiseClone());
  }; 

  function StereoCameraRig_ViewFrustumShifted (fovy, aspect, zNear, zFar, focalLength, lefteye) {
    var result = new JSIL.BoxedVariable(new ($T07())());
    var flag = (+fovy <= 0) || 
    (fovy > 3.1415926535897931);
    if (flag) {
      throw $S01().Construct("fovy");
    }
    var flag2 = +aspect <= 0;
    if (flag2) {
      throw $S01().Construct("aspect");
    }
    if (+zNear <= 0) {
      throw $S01().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S01().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S01().Construct("zNear");
    }
    var top = Math.fround(Math.tan(+fovy * 0.5)) * +zNear;
    var shiftLr = ((
      lefteye
         ? -1
         : 1)
     | 0);
    var shiftOffset = (+this.get_Iod() * 0.5) * +((+zNear / +focalLength));
    var left = (-aspect * top) + (shiftOffset * +shiftLr);
    var right = (+aspect * top) + (shiftOffset * +shiftLr);
    $T07().CreatePerspectiveOffCenter(
      left, 
      right, 
      -top, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.Stereo3D"), 
      Name: "Fusee.Engine.Core.StereoCameraRig", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Engine.Core.Stereo3DMode"), $.Int32, 
          $.Int32, $.Single
        ]), 
      StereoCameraRig__ctor
    );

    $.Method({Static:false, Public:true }, "get_FocalLength", 
      JSIL.MethodSignature.Return($.Single), 
      StereoCameraRig_get_FocalLength
    );

    $.Method({Static:false, Public:true }, "get_Iod", 
      JSIL.MethodSignature.Return($.Single), 
      StereoCameraRig_get_Iod
    );

    $.Method({Static:false, Public:true , Virtual:true }, "LookAt3D", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.float4x4"), [
          $asm04.TypeRef("Fusee.Engine.Core.Stereo3DEye"), $asm09.TypeRef("Fusee.Math.Core.float3"), 
          $asm09.TypeRef("Fusee.Math.Core.float3"), $asm09.TypeRef("Fusee.Math.Core.float3")
        ]), 
      StereoCameraRig_LookAt3D
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Prepare", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.Stereo3DEye")), 
      StereoCameraRig_Prepare
    );

    $.Method({Static:false, Public:false}, "set_FocalLength", 
      JSIL.MethodSignature.Action($.Single), 
      StereoCameraRig_set_FocalLength
    );

    $.Method({Static:false, Public:true }, "set_Iod", 
      JSIL.MethodSignature.Action($.Single), 
      StereoCameraRig_set_Iod
    );

    $.Method({Static:false, Public:true }, "SetFrustums", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Engine.Core.RenderContext"), $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      StereoCameraRig_SetFrustums
    );

    $.Method({Static:false, Public:false}, "ViewFrustumShifted", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.float4x4"), [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Boolean
        ]), 
      StereoCameraRig_ViewFrustumShifted
    );

    $.Field({Static:false, Public:false}, "_leftFrustum", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_rightFrustum", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "StereoCameraRig$FocalLength$value", $.Single);

    $.Property({Static:false, Public:true }, "FocalLength", $.Single);

    $.Property({Static:false, Public:true }, "Iod", $.Single);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.Time */ 

(function Time$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Int64)) ();
  };


  function Time__ctor () {
    this._timeScale = 1;
  }; 

  function Time_Dispose () {
  }; 

  function Time_get_DeltaTime () {
    return $thisType.get_Instance().get_TimeDeltaTime();
  }; 

  function Time_get_FramePerSecond () {
    return $thisType.get_Instance().get_TimeFramePerSecond();
  }; 

  function Time_get_Frames () {
    return $thisType.get_Instance().get_TimeFrames();
  }; 

  function Time_get_FramesPerSecondAverage () {
    return $thisType.get_Instance().get_TimeFramesPerSecondAverage();
  }; 

  function Time_get_Instance () {
    var arg_14_0 = null;
    if ((arg_14_0 = $thisType._instance) === null) {
      arg_14_0 = $thisType._instance = new $thisType();
    }
    return arg_14_0;
  }; 

  function Time_get_InstTimeScale () {
    return this._timeScale;
  }; 

  function Time_get_InstTimeSinceStart () {
    return this._time;
  }; 

  function Time_get_RealDeltaTimeMs () {
    return $thisType.get_Instance().get_TimeRealDeltaTimeMs();
  }; 

  function Time_get_RealTimeSinceStart () {
    return $thisType.get_Instance().get_TimeRealTimeSinceStart();
  }; 

  function Time_get_TimeDeltaTime () {
    return this._deltaTime;
  }; 

  function Time_get_TimeFramePerSecond () {
    return this._unsmoothedFps;
  }; 

  function Time_get_TimeFrames () {
    return this._frameCount;
  }; 

  function Time_get_TimeFramesPerSecondAverage () {
    return this._framesPerSecondAverage;
  }; 

  function Time_get_TimeRealDeltaTimeMs () {
    return this._realDeltaTime;
  }; 

  function Time_get_TimeRealTimeSinceStart () {
    return this._realTime;
  }; 

  function Time_get_TimeScale () {
    return $thisType.get_Instance().get_InstTimeScale();
  }; 

  function Time_get_TimeSinceStart () {
    return $thisType.get_Instance().get_InstTimeSinceStart();
  }; 

  function Time_set_DeltaTimeIncrement (value) {
    this._deltaTime = +value;
    this._realDeltaTime = +this._deltaTime;
    this._unsmoothedFps = +((1 / +this._deltaTime));
    this._timeSecond = +this._timeSecond + +value;
    this._framePerSecond = (((this._framePerSecond | 0) + 1) | 0);
    this._realTime = +this._realTime + +this._deltaTime;
    this._frameCount = $T01().op_Addition(this._frameCount, $T01().Create(1, 0, 0));
    this._deltaTime = +this._deltaTime * +this._timeScale;
    this._time = +this._time + +this._deltaTime;
    if (+this._timeSecond >= 1) {
      this._framesPerSecondAverage = (this._framePerSecond | 0);
      this._framePerSecond = 0;
      this._timeSecond = 0;
    }
  }; 

  function Time_set_InstTimeScale (value) {
    this._timeScale = +value;
  }; 

  function Time_set_TimeScale (value) {
    $thisType.get_Instance().set_InstTimeScale(value);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.Time", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      Time__ctor
    );

    $.Method({Static:false, Public:false}, "Dispose", 
      JSIL.MethodSignature.Void, 
      Time_Dispose
    );

    $.Method({Static:true , Public:true }, "get_DeltaTime", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_DeltaTime
    );

    $.Method({Static:true , Public:true }, "get_FramePerSecond", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_FramePerSecond
    );

    $.Method({Static:true , Public:true }, "get_Frames", 
      JSIL.MethodSignature.Return($.Int64), 
      Time_get_Frames
    );

    $.Method({Static:true , Public:true }, "get_FramesPerSecondAverage", 
      JSIL.MethodSignature.Return($.Int32), 
      Time_get_FramesPerSecondAverage
    );

    $.Method({Static:true , Public:true }, "get_Instance", 
      JSIL.MethodSignature.Return($.Type), 
      Time_get_Instance
    );

    $.Method({Static:false, Public:true }, "get_InstTimeScale", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_InstTimeScale
    );

    $.Method({Static:false, Public:true }, "get_InstTimeSinceStart", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_InstTimeSinceStart
    );

    $.Method({Static:true , Public:true }, "get_RealDeltaTimeMs", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_RealDeltaTimeMs
    );

    $.Method({Static:true , Public:true }, "get_RealTimeSinceStart", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_RealTimeSinceStart
    );

    $.Method({Static:false, Public:true }, "get_TimeDeltaTime", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_TimeDeltaTime
    );

    $.Method({Static:false, Public:true }, "get_TimeFramePerSecond", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_TimeFramePerSecond
    );

    $.Method({Static:false, Public:true }, "get_TimeFrames", 
      JSIL.MethodSignature.Return($.Int64), 
      Time_get_TimeFrames
    );

    $.Method({Static:false, Public:true }, "get_TimeFramesPerSecondAverage", 
      JSIL.MethodSignature.Return($.Int32), 
      Time_get_TimeFramesPerSecondAverage
    );

    $.Method({Static:false, Public:true }, "get_TimeRealDeltaTimeMs", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_TimeRealDeltaTimeMs
    );

    $.Method({Static:false, Public:true }, "get_TimeRealTimeSinceStart", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_TimeRealTimeSinceStart
    );

    $.Method({Static:true , Public:true }, "get_TimeScale", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_TimeScale
    );

    $.Method({Static:true , Public:true }, "get_TimeSinceStart", 
      JSIL.MethodSignature.Return($.Single), 
      Time_get_TimeSinceStart
    );

    $.Method({Static:false, Public:false}, "set_DeltaTimeIncrement", 
      JSIL.MethodSignature.Action($.Single), 
      Time_set_DeltaTimeIncrement
    );

    $.Method({Static:false, Public:true }, "set_InstTimeScale", 
      JSIL.MethodSignature.Action($.Single), 
      Time_set_InstTimeScale
    );

    $.Method({Static:true , Public:true }, "set_TimeScale", 
      JSIL.MethodSignature.Action($.Single), 
      Time_set_TimeScale
    );

    $.Field({Static:true , Public:false}, "_instance", $.Type);

    $.Field({Static:false, Public:false}, "_deltaTime", $.Single);

    $.Field({Static:false, Public:false}, "_time", $.Single);

    $.Field({Static:false, Public:false}, "_timeScale", $.Single);

    $.Field({Static:false, Public:false}, "_frameCount", $.Int64);

    $.Field({Static:false, Public:false}, "_realTime", $.Single);

    $.Field({Static:false, Public:false}, "_framesPerSecondAverage", $.Int32);

    $.Field({Static:false, Public:false}, "_timeSecond", $.Single);

    $.Field({Static:false, Public:false}, "_framePerSecond", $.Int32);

    $.Field({Static:false, Public:false}, "_unsmoothedFps", $.Single);

    $.Field({Static:false, Public:false}, "_realDeltaTime", $.Single);

    $.Property({Static:false, Public:false}, "DeltaTimeIncrement", $.Single);

    $.Property({Static:false, Public:true }, "TimeFramesPerSecondAverage", $.Int32);

    $.Property({Static:true , Public:true }, "FramesPerSecondAverage", $.Int32);

    $.Property({Static:false, Public:true }, "TimeRealTimeSinceStart", $.Single);

    $.Property({Static:true , Public:true }, "RealTimeSinceStart", $.Single);

    $.Property({Static:false, Public:true }, "TimeFramePerSecond", $.Single);

    $.Property({Static:true , Public:true }, "FramePerSecond", $.Single);

    $.Property({Static:false, Public:true }, "TimeFrames", $.Int64);

    $.Property({Static:true , Public:true }, "Frames", $.Int64);

    $.Property({Static:false, Public:true }, "TimeDeltaTime", $.Single);

    $.Property({Static:true , Public:true }, "DeltaTime", $.Single);

    $.Property({Static:false, Public:true }, "TimeRealDeltaTimeMs", $.Single);

    $.Property({Static:true , Public:true }, "RealDeltaTimeMs", $.Single);

    $.Property({Static:false, Public:true }, "InstTimeSinceStart", $.Single);

    $.Property({Static:true , Public:true }, "TimeSinceStart", $.Single);

    $.Property({Static:false, Public:true }, "InstTimeScale", $.Single);

    $.Property({Static:true , Public:true }, "TimeScale", $.Single);

    $.Property({Static:true , Public:true }, "Instance", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum Fusee.Engine.Core.TwoPointAction */ 

JSIL.MakeEnum(
  {
    FullName: "Fusee.Engine.Core.TwoPointAction", 
    BaseType: $asm0E.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    None: 0, 
    Pinch: 1, 
    Move: 2, 
    Rotate: 3, 
  }
);

/* class Fusee.Engine.Core.TouchDevice */ 

(function TouchDevice$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IInputDeviceImp)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisDirection)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm03.Fusee.Engine.Common.TouchPoints)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0E.System.Math)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Double)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm04.Fusee.Engine.Core.TwoPointAction)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisDescription)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisNature)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisBoundedType)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice_AxisValueCalculator)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm04.Fusee.Engine.Core.TouchDevice_$l$gc__DisplayClass12_0)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Single, [$asm0E.System.Single]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Single, [$asm0E.System.Single]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0E.System.Single, [$asm0E.System.Single]))) ();
  };


  function TouchDevice__ctor (inpDeviceImp) {
    var $temp00, $temp01;
    this._angleVelNormalFactor = 500;
    this._midpointVelNormalFactor = 1;
    this._distanceVelNormalFactor = 1;
    this._doubleTouchMovementThreshold = 0.001;
    $T01().prototype._ctor.call(this, inpDeviceImp);
    var nTouchpoints = (this.get_ButtonCount() | 0);
    var nVelAxes = Math.imul(nTouchpoints, 2);
    this._velocityIDs = JSIL.Array.New($T02(), nVelAxes);
    var axisId = 6;

    for (var i = 0; i < nVelAxes; i = ((i + 1) | 0)) {
      this._velocityIDs[i] = (this.RegisterVelocityAxis(
        ($temp00 = axisId, 
          axisId = ((axisId + 1) | 0), 
          $temp00), 
        1, 
        0, 
        null, 
        $T03().Unknown
      ).Id | 0);
      i = ((i + 1) | 0);
      this._velocityIDs[i] = (this.RegisterVelocityAxis(
        ($temp01 = axisId, 
          axisId = ((axisId + 1) | 0), 
          $temp01), 
        1, 
        0, 
        null, 
        $T03().Unknown
      ).Id | 0);
    }
    this._tpDistance = (this.RegisterTtpDistanceAxis() | 0);
    this._tpDistanceVel = (this.RegisterVelocityAxis(
      this._tpDistance, 
      2, 
      0, 
      null, 
      $T03().Unknown
    ).Id | 0);
    this._tpAngle = (this.RegisterTtpAngleAxis() | 0);
    this._tpAngleVel = (this.RegisterVelocityAxis(
      this._tpAngle, 
      2, 
      0, 
      null, 
      $T03().Unknown
    ).Id | 0);
    this._tpMidPointX = (this.RegisterTtpMidpointAxis(
      6, 
      8, 
      2, 
      3, 
      $T03().X, 
      "Double-Touch Midpoint X"
    ) | 0);
    this._tpMidPointVelX = (this.RegisterVelocityAxis(
      this._tpMidPointX, 
      2, 
      0, 
      null, 
      $T03().Unknown
    ).Id | 0);
    this._tpMidPointY = (this.RegisterTtpMidpointAxis(
      7, 
      9, 
      4, 
      5, 
      $T03().Y, 
      "Double-Touch Midpoint Y"
    ) | 0);
    this._tpMidPointVelY = (this.RegisterVelocityAxis(
      this._tpMidPointY, 
      2, 
      0, 
      null, 
      $T03().Unknown
    ).Id | 0);
  }; 

  function TouchDevice_$lRegisterTtpAngleAxis$gb__10_0 ($lp0$g) {
    var flag = !this.get_TwoPoint();
    if (flag) {
      var result = 0;
    } else {
      var p0 = this.GetPosition($T07().Touchpoint_0);
      var p = this.GetPosition($T07().Touchpoint_1);
      var delta = $T06().op_Subtraction(p.MemberwiseClone(), p0);
      var angle = Math.fround(Math.atan2(-delta.y, delta.x));
      result = angle;
    }
    return result;
  }; 

  function TouchDevice_$lRegisterTtpDistanceAxis$gb__11_0 ($lp0$g) {
    var flag = !this.get_TwoPoint();
    if (flag) {
      var result = 0;
    } else {
      var p0 = this.GetPosition($T07().Touchpoint_0);
      var p = this.GetPosition($T07().Touchpoint_1);
      var distance = +($T06().op_Subtraction(p.MemberwiseClone(), p0)).get_Length();
      result = distance;
    }
    return result;
  }; 

  function TouchDevice_get_ActiveTouchpoints () {
    return ((this.GetAxis(1)) | 0);
  }; 

  function TouchDevice_get_TwoPoint () {
    return ((this.get_ActiveTouchpoints() | 0) >= 2);
  }; 

  function TouchDevice_get_TwoPointAngle () {
    return this.GetAxis(this._tpAngle);
  }; 

  function TouchDevice_get_TwoPointAngleVel () {
    return this.GetAxis(this._tpAngleVel);
  }; 

  function TouchDevice_get_TwoPointDistance () {
    return this.GetAxis(this._tpDistance);
  }; 

  function TouchDevice_get_TwoPointDistanceVel () {
    return this.GetAxis(this._tpDistanceVel);
  }; 

  function TouchDevice_get_TwoPointGesture () {
    var flag = !this.get_TwoPoint();
    if (flag) {
      var result = $T0A().None;
    } else {
      var angleNormalized = (Math.abs((+this.get_TwoPointAngleVel() * +this._angleVelNormalFactor)));
      var midpointNormalized = +(this.get_TwoPointMidPointVel()).get_Length() * +this._midpointVelNormalFactor;
      var distanceNormalized = (Math.abs((+this.get_TwoPointDistanceVel() * +this._distanceVelNormalFactor)));
      var flag2 = !((angleNormalized >= +this._doubleTouchMovementThreshold) || 
        (midpointNormalized >= +this._doubleTouchMovementThreshold)) && 
      (distanceNormalized < +this._doubleTouchMovementThreshold);
      if (flag2) {
        result = $T0A().None;
      } else {
        var flag3 = angleNormalized > midpointNormalized;
        if (flag3) {
          var flag4 = angleNormalized > distanceNormalized;
          if (flag4) {
            result = $T0A().Rotate;
          } else {
            result = $T0A().Pinch;
          }
        } else {
          var flag5 = midpointNormalized > distanceNormalized;
          if (flag5) {
            result = $T0A().Move;
          } else {
            result = $T0A().Pinch;
          }
        }
      }
    }
    return result;
  }; 

  function TouchDevice_get_TwoPointMidPoint () {
    return $S00().Construct(this.GetAxis(this._tpMidPointX), this.GetAxis(this._tpMidPointY));
  }; 

  function TouchDevice_get_TwoPointMidPointVel () {
    return $S00().Construct(this.GetAxis(this._tpMidPointVelX), this.GetAxis(this._tpMidPointVelY));
  }; 

  function TouchDevice_GetPosition (touch) {
    return $S00().Construct(this.GetAxis(((Math.imul(2, ((touch - $T07().Touchpoint_0) | 0)) + 6) | 0)), this.GetAxis(((Math.imul(2, ((touch - $T07().Touchpoint_0) | 0)) + 7) | 0)));
  }; 

  function TouchDevice_GetTouchActive (touch) {
    return this.GetButton(touch.valueOf());
  }; 

  function TouchDevice_GetVelocity (touch) {
    return $S00().Construct(this.GetAxis(this._velocityIDs[Math.imul(2, ((touch - $T07().Touchpoint_0) | 0))]), this.GetAxis(this._velocityIDs[((Math.imul(2, ((touch - $T07().Touchpoint_0) | 0)) + 1) | 0)]));
  }; 

  function TouchDevice_RegisterTtpAngleAxis () {
    var id = (this.get_NewAxisID() | 0);
    var axisDescription = new ($T0B())();
    axisDescription.Id = id;
    axisDescription.Name = "Double-Touch Angle";
    axisDescription.Direction = $T03().Unknown;
    axisDescription.Nature = $T0C().Position;
    axisDescription.Bounded = $T0D().Constant;
    axisDescription.MaxValueOrAxis = 3.14159274;
    axisDescription.MinValueOrAxis = -3.14159274;
    var calculatedAxisDesc = axisDescription;
    this.RegisterCalculatedAxis(calculatedAxisDesc.MemberwiseClone(), $T0E().New(this, null, new JSIL.MethodPointerInfo($thisType, "$lRegisterTtpAngleAxis$gb__10_0", $S01(), false, false)), 0);
    return calculatedAxisDesc.Id;
  }; 

  function TouchDevice_RegisterTtpDistanceAxis () {
    var id = (this.get_NewAxisID() | 0);
    var axisDescription = new ($T0B())();
    axisDescription.Id = id;
    axisDescription.Name = "Double-Touch Distance";
    axisDescription.Direction = $T03().Unknown;
    axisDescription.Nature = $T0C().Position;
    axisDescription.Bounded = $T0D().Unbound;
    var calculatedAxisDesc = axisDescription;
    this.RegisterCalculatedAxis(calculatedAxisDesc.MemberwiseClone(), $T0E().New(this, null, new JSIL.MethodPointerInfo($thisType, "$lRegisterTtpDistanceAxis$gb__11_0", $S02(), false, false)), 0);
    return calculatedAxisDesc.Id;
  }; 

  function TouchDevice_RegisterTtpMidpointAxis (axId0, axId1, axIdMin, axIdMax, dir, name) {
    var $closure0 = new ($T10())();
    $closure0.$l$g4__this = this;
    $closure0.axId0 = (axId0 | 0);
    $closure0.axId1 = (axId1 | 0);
    var calculator = $T0E().New($closure0, null, new JSIL.MethodPointerInfo($asm04.Fusee.Engine.Core.TouchDevice_$l$gc__DisplayClass12_0, "$lRegisterTtpMidpointAxis$gb__0", $S03(), false, false));
    var id = (this.get_NewAxisID() | 0);
    var axisDescription = new ($T0B())();
    axisDescription.Id = id;
    axisDescription.Name = name;
    axisDescription.Direction = dir;
    axisDescription.Nature = $T0C().Position;
    axisDescription.Bounded = $T0D().OtherAxis;
    axisDescription.MinValueOrAxis = +axIdMin;
    axisDescription.MaxValueOrAxis = +axIdMax;
    var calculatedAxisDesc = axisDescription;
    this.RegisterCalculatedAxis(calculatedAxisDesc.MemberwiseClone(), calculator, 0);
    return calculatedAxisDesc.Id;
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.InputDevice"), 
      Name: "Fusee.Engine.Core.TouchDevice", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IInputDeviceImp")), 
      TouchDevice__ctor
    );

    $.Method({Static:false, Public:false}, "$lRegisterTtpAngleAxis$gb__10_0", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      TouchDevice_$lRegisterTtpAngleAxis$gb__10_0
    );

    $.Method({Static:false, Public:false}, "$lRegisterTtpDistanceAxis$gb__11_0", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      TouchDevice_$lRegisterTtpDistanceAxis$gb__11_0
    );

    $.Method({Static:false, Public:true }, "get_ActiveTouchpoints", 
      JSIL.MethodSignature.Return($.Int32), 
      TouchDevice_get_ActiveTouchpoints
    );

    $.Method({Static:false, Public:true }, "get_TwoPoint", 
      JSIL.MethodSignature.Return($.Boolean), 
      TouchDevice_get_TwoPoint
    );

    $.Method({Static:false, Public:true }, "get_TwoPointAngle", 
      JSIL.MethodSignature.Return($.Single), 
      TouchDevice_get_TwoPointAngle
    );

    $.Method({Static:false, Public:true }, "get_TwoPointAngleVel", 
      JSIL.MethodSignature.Return($.Single), 
      TouchDevice_get_TwoPointAngleVel
    );

    $.Method({Static:false, Public:true }, "get_TwoPointDistance", 
      JSIL.MethodSignature.Return($.Single), 
      TouchDevice_get_TwoPointDistance
    );

    $.Method({Static:false, Public:true }, "get_TwoPointDistanceVel", 
      JSIL.MethodSignature.Return($.Single), 
      TouchDevice_get_TwoPointDistanceVel
    );

    $.Method({Static:false, Public:true }, "get_TwoPointGesture", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.TwoPointAction")), 
      TouchDevice_get_TwoPointGesture
    );

    $.Method({Static:false, Public:true }, "get_TwoPointMidPoint", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float2")), 
      TouchDevice_get_TwoPointMidPoint
    );

    $.Method({Static:false, Public:true }, "get_TwoPointMidPointVel", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float2")), 
      TouchDevice_get_TwoPointMidPointVel
    );

    $.Method({Static:false, Public:true }, "GetPosition", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.float2"), [$asm03.TypeRef("Fusee.Engine.Common.TouchPoints")]), 
      TouchDevice_GetPosition
    );

    $.Method({Static:false, Public:true }, "GetTouchActive", 
      new JSIL.MethodSignature($.Boolean, [$asm03.TypeRef("Fusee.Engine.Common.TouchPoints")]), 
      TouchDevice_GetTouchActive
    );

    $.Method({Static:false, Public:true }, "GetVelocity", 
      new JSIL.MethodSignature($asm09.TypeRef("Fusee.Math.Core.float2"), [$asm03.TypeRef("Fusee.Engine.Common.TouchPoints")]), 
      TouchDevice_GetVelocity
    );

    $.Method({Static:false, Public:false}, "RegisterTtpAngleAxis", 
      JSIL.MethodSignature.Return($.Int32), 
      TouchDevice_RegisterTtpAngleAxis
    );

    $.Method({Static:false, Public:false}, "RegisterTtpDistanceAxis", 
      JSIL.MethodSignature.Return($.Int32), 
      TouchDevice_RegisterTtpDistanceAxis
    );

    $.Method({Static:false, Public:false}, "RegisterTtpMidpointAxis", 
      new JSIL.MethodSignature($.Int32, [
          $.Int32, $.Int32, 
          $.Int32, $.Int32, 
          $asm03.TypeRef("Fusee.Engine.Common.AxisDirection"), $.String
        ]), 
      TouchDevice_RegisterTtpMidpointAxis
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_velocityIDs", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_tpDistance", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_tpDistanceVel", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_tpAngle", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_tpAngleVel", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_tpMidPointX", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_tpMidPointVelX", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_tpMidPointY", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_tpMidPointVelY", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_angleVelNormalFactor", $.Single);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_midpointVelNormalFactor", $.Single);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_distanceVelNormalFactor", $.Single);

    $.Field({Static:false, Public:false, ReadOnly:true }, "_doubleTouchMovementThreshold", $.Single);

    $.Property({Static:false, Public:true }, "ActiveTouchpoints", $.Int32);

    $.Property({Static:false, Public:true }, "TwoPoint", $.Boolean);

    $.Property({Static:false, Public:true }, "TwoPointGesture", $asm04.TypeRef("Fusee.Engine.Core.TwoPointAction"));

    $.Property({Static:false, Public:true }, "TwoPointDistance", $.Single);

    $.Property({Static:false, Public:true }, "TwoPointDistanceVel", $.Single);

    $.Property({Static:false, Public:true }, "TwoPointAngle", $.Single);

    $.Property({Static:false, Public:true }, "TwoPointAngleVel", $.Single);

    $.Property({Static:false, Public:true }, "TwoPointMidPoint", $asm09.TypeRef("Fusee.Math.Core.float2"));

    $.Property({Static:false, Public:true }, "TwoPointMidPointVel", $asm09.TypeRef("Fusee.Math.Core.float2"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.TouchDevice+<>c__DisplayClass12_0 */ 

(function $l$gc__DisplayClass12_0$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.TouchDevice)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };


  function $l$gc__DisplayClass12_0__ctor () {
  }; 

  function $l$gc__DisplayClass12_0_$lRegisterTtpMidpointAxis$gb__0 ($lp0$g) {
    var flag = !(this.$l$g4__this).get_TwoPoint();
    if (flag) {
      var result = 0;
    } else {
      var v0 = +(this.$l$g4__this).GetAxis(this.axId0);
      var v = +(this.$l$g4__this).GetAxis(this.axId1);
      var midpoint = (v0 + v) * 0.5;
      result = midpoint;
    }
    return result;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.TouchDevice+<>c__DisplayClass12_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__DisplayClass12_0__ctor
    );

    $.Method({Static:false, Public:false}, "$lRegisterTtpMidpointAxis$gb__0", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      $l$gc__DisplayClass12_0_$lRegisterTtpMidpointAxis$gb__0
    );

    $.Field({Static:false, Public:true }, "axId0", $.Int32);

    $.Field({Static:false, Public:true }, "axId1", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm04.TypeRef("Fusee.Engine.Core.TouchDevice"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.VideoManager */ 

(function VideoManager$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IVideoManagerImp)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IVideoManagerImp.CreateVideoStreamImpFromCamera)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IVideoManagerImp.CreateVideoStreamImpFromFile)) ();
  };


  function VideoManager__ctor () {
  }; 

  function VideoManager_get_Instance () {
    var arg_15_0 = null;
    if ((arg_15_0 = $thisType._instance) === null) {
      arg_15_0 = $thisType._instance = new $thisType();
    }
    return arg_15_0;
  }; 

  function VideoManager_LoadVideoFromCamera (cameraIndex, useAudio) {
    return $IM00().Call(this._videoManagerImp, null, cameraIndex, useAudio);
  }; 

  function VideoManager_LoadVideoFromFile (filename, loopVideo, useAudio) {
    return $IM01().Call(this._videoManagerImp, null, filename, loopVideo, useAudio);
  }; 

  function VideoManager_set_VideoManagerImp (value) {
    this._videoManagerImp = value;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.VideoManager", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      VideoManager__ctor
    );

    $.Method({Static:true , Public:true }, "get_Instance", 
      JSIL.MethodSignature.Return($.Type), 
      VideoManager_get_Instance
    );

    $.Method({Static:false, Public:true }, "LoadVideoFromCamera", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.IVideoStreamImp"), [$.Int32, $.Boolean]), 
      VideoManager_LoadVideoFromCamera
    );

    $.Method({Static:false, Public:true }, "LoadVideoFromFile", 
      new JSIL.MethodSignature($asm03.TypeRef("Fusee.Engine.Common.IVideoStreamImp"), [
          $.String, $.Boolean, 
          $.Boolean
        ]), 
      VideoManager_LoadVideoFromFile
    );

    $.Method({Static:false, Public:false}, "set_VideoManagerImp", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.IVideoManagerImp")), 
      VideoManager_set_VideoManagerImp
    );

    $.Field({Static:true , Public:false}, "_instance", $.Type);

    $.Field({Static:false, Public:false}, "_videoManagerImp", $asm03.TypeRef("Fusee.Engine.Common.IVideoManagerImp"));

    $.Property({Static:false, Public:false}, "VideoManagerImp", $asm03.TypeRef("Fusee.Engine.Common.IVideoManagerImp"));

    $.Property({Static:true , Public:true }, "Instance", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.VideoStream */ 

(function VideoStream$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IVideoStreamImp)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm03.Fusee.Engine.Common.IVideoStreamImp.GetCurrentFrame)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm03.Fusee.Engine.Common.IVideoStreamImp.Start)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm03.Fusee.Engine.Common.IVideoStreamImp.Stop)) ();
  };


  function VideoStream__ctor () {
  }; 

  function VideoStream_GetCurrentFrame () {
    return $IM00().Call(this._imp, null);
  }; 

  function VideoStream_Start () {
    $IM01().Call(this._imp, null);
  }; 

  function VideoStream_Stop () {
    $IM02().Call(this._imp, null);
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.VideoStream", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      VideoStream__ctor
    );

    $.Method({Static:false, Public:true }, "GetCurrentFrame", 
      JSIL.MethodSignature.Return($asm00.TypeRef("Fusee.Base.Common.ImageData")), 
      VideoStream_GetCurrentFrame
    );

    $.Method({Static:false, Public:true }, "Start", 
      JSIL.MethodSignature.Void, 
      VideoStream_Start
    );

    $.Method({Static:false, Public:true }, "Stop", 
      JSIL.MethodSignature.Void, 
      VideoStream_Stop
    );

    $.Field({Static:false, Public:true }, "_imp", $asm03.TypeRef("Fusee.Engine.Common.IVideoStreamImp"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("Fusee.Engine.Core.GUI");
/* delegate Fusee.Engine.Core.GUI.GUIButtonHandler */ 

JSIL.MakeDelegate("Fusee.Engine.Core.GUI.GUIButtonHandler", true, [], 
  new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButton"), $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonEventArgs")]));

/* class Fusee.Engine.Core.GUI.GUIButtonEventArgs */ 

(function GUIButtonEventArgs$Members () {
  var $, $thisType;

  function GUIButtonEventArgs__ctor () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.GUI.GUIButtonEventArgs", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      GUIButtonEventArgs__ctor
    );

    $.Field({Static:false, Public:true }, "mouseX", $.Int32);

    $.Field({Static:false, Public:true }, "mouseY", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GUI.GUIElement */ 

(function GUIElement$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.FontMap)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderEffect)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float3))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize(System.Array.Of($asm0E.System.UInt16))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize(System.Array.Of($asm0E.System.UInt32))) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize(System.Array.Of($asm04.Fusee.Engine.Core.EffectPassDeclaration))) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm04.Fusee.Engine.Core.EffectPassDeclaration)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderStateSet)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm03.Fusee.Engine.Common.Blend)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration))) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm04.Fusee.Engine.Core.EffectParameterDeclaration)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration))) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm03.Fusee.Engine.Common.ITexture)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm09.Fusee.Math.Core.float3)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm09.Fusee.Math.Core.M)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0E.System.UInt16)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0E.System.Math)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm0E.System.Char)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm04.Fusee.Engine.Core.GlyphOnMap)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm00.Fusee.Base.Common.GlyphInfo)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm01.Fusee.Base.Core.Font)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float3, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm09.Fusee.Math.Core.float4x4, [$asm09.Fusee.Math.Core.float4x4, $asm09.Fusee.Math.Core.float4x4]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };


  function GUIElement__ctor (text, fontMap, x, y, z, width, height, zRot, xPivot, yPivot) {
    this.GUIVS = "\r\n            uniform mat4 guiXForm;\r\n            attribute vec3 fuVertex;\r\n            attribute vec2 fuUV;\r\n            attribute vec4 fuColor;\r\n\r\n            varying vec2 vUV;\r\n            varying vec4 vColor;\r\n\r\n            void main()\r\n            {\r\n                vUV = fuUV;\r\n                vColor = fuColor;\r\n\r\n                gl_Position = guiXForm * vec4(fuVertex, 1);\r\n            }";
    this.GUIPS = "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif    \r\n  \r\n            varying vec2 vUV;\r\n            varying vec4 vColor;\r\n\r\n            void main(void) {\r\n                gl_FragColor = vColor;\r\n            }";
    this.TEXTPS = "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif    \r\n  \r\n            varying vec2 vUV;\r\n            varying vec4 vColor;\r\n\r\n            uniform sampler2D tex;\r\n            uniform vec4 uColor;\r\n\r\n            void main(void) {\r\n                gl_FragColor = vec4(1, 1, 1, texture2D(tex, vUV).a) * uColor;\r\n            }";
    this.Dirty = false;
    this.set_PosX(x);
    this.set_PosY(y);
    this.PosZ = (z | 0);
    this.set_OffsetX(0);
    this.set_OffsetY(0);
    this.set_OffsetZ(0);
    this.Width = (width | 0);
    this.Height = (height | 0);
    this.set_Text(text);
    this.FontMap = fontMap;
    this.GUIElement$ZRot$value = +zRot;
    this.GUIElement$XPivot$value = (xPivot | 0);
    this.GUIElement$YPivot$value = (yPivot | 0);
  }; 

  function GUIElement_AttachToContext (rc) {
    var flag = this.RContext === rc;
    if (!flag) {
      if (this.RContext !== null) {
        (this.TextShader).DetachFromContext();
        this.TextShader = null;
      }
      this.RContext = rc;
      if (this.GUIShader !== null) {
        (this.GUIShader).AttachToContext(this.RContext);
      }
      if (this.FontMap !== null) {
        this.CreateTextShader(rc.CreateTexture((this.FontMap).get_Image().MemberwiseClone(), false));
        (this.TextShader).AttachToContext(this.RContext);
      }
      this.Refresh();
    }
  }; 

  function GUIElement_CreateGUIMesh (vertices, uvs, indices, colors) {
    var flag = this.GUIElement$GUIMesh$value === null;
    if (flag) {
      var expr_14 = new ($T0B())();
      expr_14.set_Vertices(vertices);
      expr_14.set_UVs(uvs);
      expr_14.set_Triangles(indices);
      expr_14.set_Colors(colors);
      this.GUIElement$GUIMesh$value = expr_14;
    } else {
      (this.GUIElement$GUIMesh$value).set_Vertices(vertices);
      (this.GUIElement$GUIMesh$value).set_UVs(uvs);
      (this.GUIElement$GUIMesh$value).set_Triangles(indices);
      (this.GUIElement$GUIMesh$value).set_Colors(colors);
    }
  }; 

  function GUIElement_CreateGUIShader () {
    var expr_08 = JSIL.Array.New($T0D(), 1);
    var effectPassDeclaration = new ($T0D())();
    effectPassDeclaration.VS = this.GUIVS;
    effectPassDeclaration.PS = this.GUIPS;
    var expr_33 = new ($T0E())();
    expr_33.set_AlphaBlendEnable(true);
    expr_33.set_SourceBlend($T0F().SourceAlpha);
    expr_33.set_DestinationBlend($T0F().InverseSourceAlpha);
    expr_33.set_ZEnable(true);
    effectPassDeclaration.StateSet = expr_33;
    expr_08[0] = effectPassDeclaration.MemberwiseClone();
    var expr_64 = JSIL.Array.New($T11(), 1);
    var effectParameterDeclaration = new ($T11())();
    effectParameterDeclaration.Name = "guiXForm";
    effectParameterDeclaration.Value = $T12().Identity.MemberwiseClone();
    expr_64[0] = effectParameterDeclaration.MemberwiseClone();
    this.GUIShader = new ($T06())(expr_08, $T13().$Cast(expr_64));
  }; 

  function GUIElement_CreateTextMesh (vertices, uvs, indices) {
    var flag = this.GUIElement$TextMesh$value === null;
    if (flag) {
      var expr_14 = new ($T0B())();
      expr_14.set_Vertices(vertices);
      expr_14.set_UVs(uvs);
      expr_14.set_Triangles(indices);
      this.GUIElement$TextMesh$value = expr_14;
    } else {
      (this.GUIElement$TextMesh$value).set_Vertices(vertices);
      (this.GUIElement$TextMesh$value).set_UVs(uvs);
      (this.GUIElement$TextMesh$value).set_Triangles(indices);
    }
  }; 

  function GUIElement_CreateTextShader (textAtlas) {
    var expr_08 = JSIL.Array.New($T0D(), 1);
    var effectPassDeclaration = new ($T0D())();
    effectPassDeclaration.VS = this.GUIVS;
    effectPassDeclaration.PS = this.TEXTPS;
    var expr_33 = new ($T0E())();
    expr_33.set_AlphaBlendEnable(true);
    expr_33.set_SourceBlend($T0F().SourceAlpha);
    expr_33.set_DestinationBlend($T0F().InverseSourceAlpha);
    expr_33.set_ZEnable(false);
    effectPassDeclaration.StateSet = expr_33;
    expr_08[0] = effectPassDeclaration.MemberwiseClone();
    var expr_64 = JSIL.Array.New($T11(), 3);
    var effectParameterDeclaration = new ($T11())();
    effectParameterDeclaration.Name = "tex";
    effectParameterDeclaration.Value = textAtlas;
    expr_64[0] = effectParameterDeclaration.MemberwiseClone();
    effectParameterDeclaration = new ($T11())();
    effectParameterDeclaration.Name = "uColor";
    effectParameterDeclaration.Value = this._textColor.MemberwiseClone();
    expr_64[1] = effectParameterDeclaration.MemberwiseClone();
    effectParameterDeclaration = new ($T11())();
    effectParameterDeclaration.Name = "guiXForm";
    effectParameterDeclaration.Value = $T12().Identity.MemberwiseClone();
    expr_64[2] = effectParameterDeclaration.MemberwiseClone();
    this.TextShader = new ($T06())(expr_08, $T13().$Cast(expr_64));
  }; 

  function GUIElement_DetachFromContext () {
    this.RContext = null;
    if (this.GUIShader !== null) {
      (this.GUIShader).DetachFromContext();
    }
    if (this.TextShader !== null) {
      (this.TextShader).DetachFromContext();
    }
  }; 

  function GUIElement_DrawRectangle (c1, c2, c3, c4, vtStart, indStart, color, /* ref */ vertices, /* ref */ indices, /* ref */ colors) {
    vertices.get()[vtStart] = $S00().Construct(c1, c3, 0);
    vertices.get()[(((vtStart | 0) + 1) | 0)] = $S00().Construct(c1, c4, 0);
    vertices.get()[(((vtStart | 0) + 2) | 0)] = $S00().Construct(c2, c3, 0);
    vertices.get()[(((vtStart | 0) + 3) | 0)] = $S00().Construct(c2, c4, 0);
    var colorInt = ($T18().Float4ToABGR(color) >>> 0);
    colors.get()[vtStart] = colorInt;
    colors.get()[(((vtStart | 0) + 1) | 0)] = colorInt;
    colors.get()[(((vtStart | 0) + 2) | 0)] = colorInt;
    colors.get()[(((vtStart | 0) + 3) | 0)] = colorInt;
    indices.get()[indStart] = ((((vtStart | 0) + 1) | 0) & 0xFFFF);
    indices.get()[(((indStart | 0) + 1) | 0)] = (vtStart & 0xFFFF);
    indices.get()[(((indStart | 0) + 2) | 0)] = ((((vtStart | 0) + 2) | 0) & 0xFFFF);
    indices.get()[(((indStart | 0) + 3) | 0)] = ((((vtStart | 0) + 1) | 0) & 0xFFFF);
    indices.get()[(((indStart | 0) + 4) | 0)] = ((((vtStart | 0) + 2) | 0) & 0xFFFF);
    indices.get()[(((indStart | 0) + 5) | 0)] = ((((vtStart | 0) + 3) | 0) & 0xFFFF);
  }; 

  function GUIElement_get_GUIMesh () {
    return this.GUIElement$GUIMesh$value;
  }; 

  function GUIElement_get_OffsetX () {
    return this._offsetX;
  }; 

  function GUIElement_get_OffsetY () {
    return this._offsetY;
  }; 

  function GUIElement_get_OffsetZ () {
    return this._offsetZ;
  }; 

  function GUIElement_get_PosX () {
    return this._posX;
  }; 

  function GUIElement_get_PosY () {
    return this._posY;
  }; 

  function GUIElement_get_Tag () {
    return this.GUIElement$Tag$value;
  }; 

  function GUIElement_get_Text () {
    return this._text;
  }; 

  function GUIElement_get_TextColor () {
    return this._textColor;
  }; 

  function GUIElement_get_TextMesh () {
    return this.GUIElement$TextMesh$value;
  }; 

  function GUIElement_get_XPivot () {
    return this.GUIElement$XPivot$value;
  }; 

  function GUIElement_get_YPivot () {
    return this.GUIElement$YPivot$value;
  }; 

  function GUIElement_get_ZIndex () {
    return (((this.PosZ | 0) + (this._offsetZ | 0)) | 0);
  }; 

  function GUIElement_get_ZRot () {
    return this.GUIElement$ZRot$value;
  }; 

  function GUIElement_PreRender (rc) {
    var flag = this.RContext !== rc;
    if (flag) {
      this.AttachToContext(rc);
    }
    var dirty = this.Dirty;
    if (dirty) {
      this.Refresh();
    }
  }; 

  function GUIElement_Refresh () {
    if (this.RContext !== null) {
      this.Dirty = false;
      this.CreateMesh();
    }
  }; 

  function GUIElement_Render (rc) {
    this.PreRender(rc);
    var clipPivot = $S00().Construct((+(((+(this.GUIElement$XPivot$value) * 2) / +(this.RContext.RenderContext$ViewportWidth$value))) - 1), (1 - +(((+(this.GUIElement$YPivot$value) * 2) / +(this.RContext.RenderContext$ViewportHeight$value)))), 0);
    var guiXForm = $S01().CallStatic($T12(), "op_Multiply", null, 
      $S01().CallStatic($T12(), "op_Multiply", null, 
        $S01().CallStatic($T12(), "op_Multiply", null, 
          $S01().CallStatic($T12(), "op_Multiply", null, 
            $T12().CreateTranslation(clipPivot.MemberwiseClone()).MemberwiseClone(), 
            $T12().CreateScale(1, +((+(this.RContext.RenderContext$ViewportWidth$value) / +(this.RContext.RenderContext$ViewportHeight$value))), 1).MemberwiseClone()
          ).MemberwiseClone(), 
          $T12().CreateRotationZ(this.GUIElement$ZRot$value).MemberwiseClone()
        ).MemberwiseClone(), 
        $T12().CreateScale(1, +((+(this.RContext.RenderContext$ViewportHeight$value) / +(this.RContext.RenderContext$ViewportWidth$value))), 1).MemberwiseClone()
      ).MemberwiseClone(), 
      $T12().CreateTranslation($T16().op_UnaryNegation(clipPivot.MemberwiseClone()).MemberwiseClone()).MemberwiseClone()
    );
    if (this.FontMap !== null) {
      (this.TextShader).SetEffectParam("guiXForm", guiXForm.MemberwiseClone());
    } else {
      (this.GUIShader).SetEffectParam("guiXForm", guiXForm.MemberwiseClone());
    }
    var flag2 = (this.GUIShader !== null) && 
    (this.GUIElement$GUIMesh$value !== null);
    if (flag2) {
      (this.GUIShader).RenderMesh(this.GUIElement$GUIMesh$value);
    }
    var flag3 = (this.TextShader !== null) && 
    (this.GUIElement$TextMesh$value !== null);
    if (flag3) {
      (this.TextShader).SetEffectParam("uColor", this._textColor.MemberwiseClone());
      (this.TextShader).RenderMesh(this.GUIElement$TextMesh$value);
    }
  }; 

  function GUIElement_set_GUIMesh (value) {
    this.GUIElement$GUIMesh$value = value;
  }; 

  function GUIElement_set_OffsetX (value) {
    var flag = (value | 0) !== (this._offsetX | 0);
    if (flag) {
      this.Dirty = true;
    }
    this._offsetX = (value | 0);
  }; 

  function GUIElement_set_OffsetY (value) {
    var flag = (value | 0) !== (this._offsetY | 0);
    if (flag) {
      this.Dirty = true;
    }
    this._offsetY = (value | 0);
  }; 

  function GUIElement_set_OffsetZ (value) {
    var flag = (value | 0) !== (this._offsetZ | 0);
    if (flag) {
      this.Dirty = true;
    }
    this._offsetZ = (value | 0);
  }; 

  function GUIElement_set_PosX (value) {
    var flag = (value | 0) !== (this._posX | 0);
    if (flag) {
      this.Dirty = true;
    }
    this._posX = (value | 0);
  }; 

  function GUIElement_set_PosY (value) {
    var flag = (value | 0) !== (this._posY | 0);
    if (flag) {
      this.Dirty = true;
    }
    this._posY = (value | 0);
  }; 

  function GUIElement_set_Tag (value) {
    this.GUIElement$Tag$value = value;
  }; 

  function GUIElement_set_Text (value) {
    var flag = (value != this._text);
    if (flag) {
      this.Dirty = true;
    }
    this._text = value;
  }; 

  function GUIElement_set_TextColor (value) {
    this._textColor = value.MemberwiseClone();
  }; 

  function GUIElement_set_TextMesh (value) {
    this.GUIElement$TextMesh$value = value;
  }; 

  function GUIElement_set_XPivot (value) {
    this.GUIElement$XPivot$value = (value | 0);
  }; 

  function GUIElement_set_YPivot (value) {
    this.GUIElement$YPivot$value = (value | 0);
  }; 

  function GUIElement_set_ZRot (value) {
    this.GUIElement$ZRot$value = +value;
  }; 

  function GUIElement_SetRectangleMesh (borderWidth, rectColor, borderColor) {
    var x = (((this.get_PosX() | 0) + (this.get_OffsetX() | 0)) | 0);
    var y = (((this.get_PosY() | 0) + (this.get_OffsetY() | 0)) | 0);
    var scaleX = +((2 / +(this.RContext.RenderContext$ViewportWidth$value)));
    var scaleY = +((2 / +(this.RContext.RenderContext$ViewportHeight$value)));
    var xS = -1 + (+x * scaleX);
    var yS = 1 - (+y * scaleY);
    var width = +(this.Width) * scaleX;
    var height = +(this.Height) * scaleY;
    var borderX = +$T1B().Max(0, +borderWidth * scaleX);
    var borderY = +$T1B().Max(0, +borderWidth * scaleY);
    var vertices = new JSIL.BoxedVariable(JSIL.Array.New($T16(), (
          (+borderWidth > 0)
             ? 8
             : 4)
      ));
    var uvs = JSIL.Array.New($T1C(), (
        (+borderWidth > 0)
           ? 8
           : 4)
    );
    var indices = new JSIL.BoxedVariable(JSIL.Array.New($T19(), (
          (+borderWidth > 0)
             ? 12
             : 6)
      ));
    var colors = new JSIL.BoxedVariable(JSIL.Array.New($T17(), (
          (+borderWidth > 0)
             ? 8
             : 4)
      ));
    var c = xS + borderX;
    var c2 = (xS - borderX) + width;
    var c3 = (yS - height) + borderY;
    var c4 = yS - borderY;
    this.DrawRectangle(
      c, 
      c2, 
      c3, 
      c4, 
      0, 
      0, 
      rectColor, 
      /* ref */ vertices, 
      /* ref */ indices, 
      /* ref */ colors
    );
    if (+borderWidth > 0) {
      c = xS;
      c2 = xS + width;
      c3 = yS - height;
      c4 = yS;
      this.DrawRectangle(
        c, 
        c2, 
        c3, 
        c4, 
        4, 
        6, 
        borderColor, 
        /* ref */ vertices, 
        /* ref */ indices, 
        /* ref */ colors
      );
    }
    this.CreateGUIMesh(vertices.get(), uvs, indices.get(), colors.get());
  }; 

  function GUIElement_SetTextMesh (posX, posY) {
    var $temp00, $temp01, $temp02, $temp03, $temp04, $temp05;
    if (this.FontMap !== null) {
      var scaleX = +((2 / +(this.RContext.RenderContext$ViewportWidth$value)));
      var scaleY = +((2 / +(this.RContext.RenderContext$ViewportHeight$value)));
      var x = -1 + (+posX * scaleX);
      var y = 1 - (+posY * scaleY);
      var vertices = JSIL.Array.New($T16(), Math.imul(4, this.get_Text().length));
      var uvs = JSIL.Array.New($T1C(), Math.imul(4, this.get_Text().length));
      var indices = JSIL.Array.New($T19(), Math.imul(6, this.get_Text().length));
      var atlasWidth = ((this.FontMap).get_Image().Width | 0);
      var atlasHeight = ((this.FontMap).get_Image().Height | 0);
      var index = 0;
      var vertex = 0;
      var text = this.get_Text();

      for (var i = 0; i < (text.length | 0); i = ((i + 1) | 0)) {
        var letter = (text[i]);
        var glyphOnMap = (this.FontMap).GetGlyphOnMap(letter.charCodeAt(0)).MemberwiseClone();
        var glyphInfo = ((this.FontMap).get_Font()).GetGlyphInfo(letter.charCodeAt(0)).MemberwiseClone();
        var x2 = x + (+glyphOnMap.BitmapL * scaleX);
        var y2 = -y - (+glyphOnMap.BitmapT * scaleY);
        var w = +glyphOnMap.BitmapW * scaleX;
        var h = +glyphOnMap.BitmapH * scaleY;
        x += +glyphInfo.AdvanceX * scaleX;
        y += +glyphInfo.AdvanceY * scaleY;
        if (!((w <= 1.192093E-07) || (h <= 1.192093E-07))) {
          var bitmapW = +glyphOnMap.BitmapW;
          var bitmapH = +glyphOnMap.BitmapH;
          var texOffsetX = +glyphOnMap.TexOffX;
          var texOffsetY = +glyphOnMap.TexOffY;
          vertices[vertex] = $S00().Construct(x2, (-y2 - h), 0);
          vertices[((vertex + 1) & 0xFFFF)] = $S00().Construct(x2, -y2, 0);
          vertices[((vertex + 2) & 0xFFFF)] = $S00().Construct((x2 + w), (-y2 - h), 0);
          vertices[((vertex + 3) & 0xFFFF)] = $S00().Construct((x2 + w), -y2, 0);
          uvs[vertex] = $S02().Construct(texOffsetX, (texOffsetY + +((bitmapH / +atlasHeight))));
          uvs[((vertex + 1) & 0xFFFF)] = $S02().Construct(texOffsetX, texOffsetY);
          uvs[((vertex + 2) & 0xFFFF)] = $S02().Construct((texOffsetX + +((bitmapW / +atlasWidth))), (texOffsetY + +((bitmapH / +atlasHeight))));
          uvs[((vertex + 3) & 0xFFFF)] = $S02().Construct((texOffsetX + +((bitmapW / +atlasWidth))), texOffsetY);
          indices[($temp00 = index, 
            index = ((index + 1) | 0), 
            $temp00)] = (((vertex + 1) >>> 0) & 0xFFFF);
          indices[($temp01 = index, 
            index = ((index + 1) | 0), 
            $temp01)] = vertex;
          indices[($temp02 = index, 
            index = ((index + 1) | 0), 
            $temp02)] = (((vertex + 2) >>> 0) & 0xFFFF);
          indices[($temp03 = index, 
            index = ((index + 1) | 0), 
            $temp03)] = (((vertex + 1) >>> 0) & 0xFFFF);
          indices[($temp04 = index, 
            index = ((index + 1) | 0), 
            $temp04)] = (((vertex + 2) >>> 0) & 0xFFFF);
          indices[($temp05 = index, 
            index = ((index + 1) | 0), 
            $temp05)] = (((vertex + 3) >>> 0) & 0xFFFF);
          vertex = (((vertex + 4) >>> 0) & 0xFFFF);
        }
      }
      vertices = (this.FontMap).FixTextKerning(vertices, this.get_Text(), scaleX);
      this.CreateTextMesh(vertices, uvs, indices);
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.GUI.GUIElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 10, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap"), 
          $.Int32, $.Int32, 
          $.Int32, $.Int32, 
          $.Int32, $.Single, 
          $.Int32, $.Int32
        ]), 
      GUIElement__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "AttachToContext", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      GUIElement_AttachToContext
    );

    $.Method({Static:false, Public:false}, "CreateGUIMesh", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]), $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float2")]), 
          $jsilcore.TypeRef("System.Array", [$.UInt16]), $jsilcore.TypeRef("System.Array", [$.UInt32])
        ]), 
      GUIElement_CreateGUIMesh
    );

    $.Method({Static:false, Public:false, Virtual:true }, "CreateGUIShader", 
      JSIL.MethodSignature.Void, 
      GUIElement_CreateGUIShader
    );

    $.Method({Static:false, Public:false}, "CreateTextMesh", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")]), $jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float2")]), 
          $jsilcore.TypeRef("System.Array", [$.UInt16])
        ]), 
      GUIElement_CreateTextMesh
    );

    $.Method({Static:false, Public:false}, "CreateTextShader", 
      JSIL.MethodSignature.Action($asm03.TypeRef("Fusee.Engine.Common.ITexture")), 
      GUIElement_CreateTextShader
    );

    $.Method({Static:false, Public:false, Virtual:true }, "DetachFromContext", 
      JSIL.MethodSignature.Void, 
      GUIElement_DetachFromContext
    );

    $.Method({Static:false, Public:false}, "DrawRectangle", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Int32, $.Int32, 
          $asm09.TypeRef("Fusee.Math.Core.float4"), $jsilcore.TypeRef("JSIL.Reference", [$jsilcore.TypeRef("System.Array", [$asm09.TypeRef("Fusee.Math.Core.float3")])]), 
          $jsilcore.TypeRef("JSIL.Reference", [$jsilcore.TypeRef("System.Array", [$.UInt16])]), $jsilcore.TypeRef("JSIL.Reference", [$jsilcore.TypeRef("System.Array", [$.UInt32])])
        ]), 
      GUIElement_DrawRectangle
    );

    $.Method({Static:false, Public:true }, "get_GUIMesh", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      GUIElement_get_GUIMesh
    );

    $.Method({Static:false, Public:false}, "get_OffsetX", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIElement_get_OffsetX
    );

    $.Method({Static:false, Public:false}, "get_OffsetY", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIElement_get_OffsetY
    );

    $.Method({Static:false, Public:false}, "get_OffsetZ", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIElement_get_OffsetZ
    );

    $.Method({Static:false, Public:true }, "get_PosX", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIElement_get_PosX
    );

    $.Method({Static:false, Public:true }, "get_PosY", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIElement_get_PosY
    );

    $.Method({Static:false, Public:true }, "get_Tag", 
      JSIL.MethodSignature.Return($.Object), 
      GUIElement_get_Tag
    );

    $.Method({Static:false, Public:true }, "get_Text", 
      JSIL.MethodSignature.Return($.String), 
      GUIElement_get_Text
    );

    $.Method({Static:false, Public:true }, "get_TextColor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIElement_get_TextColor
    );

    $.Method({Static:false, Public:true }, "get_TextMesh", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      GUIElement_get_TextMesh
    );

    $.Method({Static:false, Public:true }, "get_XPivot", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIElement_get_XPivot
    );

    $.Method({Static:false, Public:true }, "get_YPivot", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIElement_get_YPivot
    );

    $.Method({Static:false, Public:false}, "get_ZIndex", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIElement_get_ZIndex
    );

    $.Method({Static:false, Public:true }, "get_ZRot", 
      JSIL.MethodSignature.Return($.Single), 
      GUIElement_get_ZRot
    );

    $.Method({Static:false, Public:false, Virtual:true }, "PreRender", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      GUIElement_PreRender
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Refresh", 
      JSIL.MethodSignature.Void, 
      GUIElement_Refresh
    );

    $.Method({Static:false, Public:true }, "Render", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      GUIElement_Render
    );

    $.Method({Static:false, Public:false}, "set_GUIMesh", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      GUIElement_set_GUIMesh
    );

    $.Method({Static:false, Public:false}, "set_OffsetX", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIElement_set_OffsetX
    );

    $.Method({Static:false, Public:false}, "set_OffsetY", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIElement_set_OffsetY
    );

    $.Method({Static:false, Public:false}, "set_OffsetZ", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIElement_set_OffsetZ
    );

    $.Method({Static:false, Public:true }, "set_PosX", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIElement_set_PosX
    );

    $.Method({Static:false, Public:true }, "set_PosY", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIElement_set_PosY
    );

    $.Method({Static:false, Public:true }, "set_Tag", 
      JSIL.MethodSignature.Action($.Object), 
      GUIElement_set_Tag
    );

    $.Method({Static:false, Public:true }, "set_Text", 
      JSIL.MethodSignature.Action($.String), 
      GUIElement_set_Text
    );

    $.Method({Static:false, Public:true }, "set_TextColor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIElement_set_TextColor
    );

    $.Method({Static:false, Public:false}, "set_TextMesh", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.Mesh")), 
      GUIElement_set_TextMesh
    );

    $.Method({Static:false, Public:true }, "set_XPivot", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIElement_set_XPivot
    );

    $.Method({Static:false, Public:true }, "set_YPivot", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIElement_set_YPivot
    );

    $.Method({Static:false, Public:true }, "set_ZRot", 
      JSIL.MethodSignature.Action($.Single), 
      GUIElement_set_ZRot
    );

    $.Method({Static:false, Public:false}, "SetRectangleMesh", 
      new JSIL.MethodSignature(null, [
          $.Single, $asm09.TypeRef("Fusee.Math.Core.float4"), 
          $asm09.TypeRef("Fusee.Math.Core.float4")
        ]), 
      GUIElement_SetRectangleMesh
    );

    $.Method({Static:false, Public:false}, "SetTextMesh", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32]), 
      GUIElement_SetTextMesh
    );

    $.Field({Static:false, Public:false}, "RContext", $asm04.TypeRef("Fusee.Engine.Core.RenderContext"));

    $.Field({Static:false, Public:false}, "Dirty", $.Boolean);

    $.Field({Static:false, Public:false}, "Height", $.Int32);

    $.Field({Static:false, Public:false}, "Width", $.Int32);

    $.Field({Static:false, Public:false}, "PosZ", $.Int32);

    $.Field({Static:false, Public:false}, "FontMap", $asm04.TypeRef("Fusee.Engine.Core.FontMap"));

    $.Field({Static:false, Public:false}, "ImgSrc", $asm00.TypeRef("Fusee.Base.Common.ImageData"));

    $.Field({Static:false, Public:false}, "GUITexture", $asm03.TypeRef("Fusee.Engine.Common.ITexture"));

    $.Field({Static:false, Public:false}, "GUIShader", $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"));

    $.Field({Static:false, Public:false}, "TextShader", $asm04.TypeRef("Fusee.Engine.Core.ShaderEffect"));

    $.Field({Static:false, Public:false}, "ColorParam", $asm03.TypeRef("Fusee.Engine.Common.IShaderParam"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "GUIVS", $.String);

    $.Field({Static:false, Public:false, ReadOnly:true }, "GUIPS", $.String);

    $.Field({Static:false, Public:false, ReadOnly:true }, "TEXTPS", $.String);

    $.Field({Static:false, Public:false}, "_posX", $.Int32);

    $.Field({Static:false, Public:false}, "_posY", $.Int32);

    $.Field({Static:false, Public:false}, "_rotation", $asm09.TypeRef("Fusee.Math.Core.float4x4"));

    $.Field({Static:false, Public:false}, "_offsetX", $.Int32);

    $.Field({Static:false, Public:false}, "_offsetY", $.Int32);

    $.Field({Static:false, Public:false}, "_offsetZ", $.Int32);

    $.Field({Static:false, Public:false}, "_text", $.String);

    $.Field({Static:false, Public:false}, "_textColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Field({Static:false, Public:false}, "GUIElement$ZRot$value", $.Single);

    $.Field({Static:false, Public:false}, "GUIElement$XPivot$value", $.Int32);

    $.Field({Static:false, Public:false}, "GUIElement$YPivot$value", $.Int32);

    $.Field({Static:false, Public:false}, "GUIElement$Tag$value", $.Object);

    $.Field({Static:false, Public:false}, "GUIElement$GUIMesh$value", $asm04.TypeRef("Fusee.Engine.Core.Mesh"));

    $.Field({Static:false, Public:false}, "GUIElement$TextMesh$value", $asm04.TypeRef("Fusee.Engine.Core.Mesh"));

    $.Property({Static:false, Public:false}, "OffsetX", $.Int32);

    $.Property({Static:false, Public:false}, "OffsetY", $.Int32);

    $.Property({Static:false, Public:false}, "OffsetZ", $.Int32);

    $.Property({Static:false, Public:false}, "ZIndex", $.Int32);

    $.Property({Static:false, Public:true }, "TextColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Property({Static:false, Public:true }, "Text", $.String);

    $.Property({Static:false, Public:true }, "PosX", $.Int32);

    $.Property({Static:false, Public:true }, "PosY", $.Int32);

    $.Property({Static:false, Public:true }, "ZRot", $.Single);

    $.Property({Static:false, Public:true }, "XPivot", $.Int32);

    $.Property({Static:false, Public:true }, "YPivot", $.Int32);

    $.Property({Static:false, Public:true }, "Tag", $.Object);

    $.Property({Static:false, Public:true }, "GUIMesh", $asm04.TypeRef("Fusee.Engine.Core.Mesh"));

    $.Property({Static:false, Public:true }, "TextMesh", $asm04.TypeRef("Fusee.Engine.Core.Mesh"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GUI.GUIButton */ 

(function GUIButton$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIElement)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.FontMap)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIButtonHandler)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Delegate)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Threading.Interlocked)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIText)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Math)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.Double)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm04.Fusee.Engine.Core.Input)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.ButtonValueChangedArgs))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.AxisValueChangedArgs))) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm04.Fusee.Engine.Core.MouseDevice)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm03.Fusee.Engine.Common.ButtonValueChangedArgs)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIButtonEventArgs)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisValueChangedArgs)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.ButtonValueChangedArgs]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.AxisValueChangedArgs]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float4, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };


  function GUIButton__ctor$00 (x, y, width, height) {
    $T01().prototype._ctor.call(this, 
      $T02().Empty, 
      null, 
      x, 
      y, 
      0, 
      width, 
      height, 
      0, 
      0, 
      0
    );
    this.SetupButton();
  }; 

  function GUIButton__ctor$01 (x, y, z, width, height) {
    $T01().prototype._ctor.call(this, 
      $T02().Empty, 
      null, 
      x, 
      y, 
      z, 
      width, 
      height, 
      0, 
      0, 
      0
    );
    this.SetupButton();
  }; 

  function GUIButton__ctor$02 (text, fontMap, x, y, width, height) {
    $T01().prototype._ctor.call(this, 
      text, 
      fontMap, 
      x, 
      y, 
      0, 
      width, 
      height, 
      0, 
      0, 
      0
    );
    this.SetupButton();
  }; 

  function GUIButton__ctor$03 (text, fontMap, x, y, z, width, height) {
    $T01().prototype._ctor.call(this, 
      text, 
      fontMap, 
      x, 
      y, 
      z, 
      width, 
      height, 
      0, 
      0, 
      0
    );
    this.SetupButton();
  }; 

  function GUIButton_add_OnGUIButtonDown (value) {
    var gUIButtonHandler = this.OnGUIButtonDown;

    do {
      var gUIButtonHandler2 = gUIButtonHandler;
      var value2 = $T05().Combine(gUIButtonHandler2, value);
      gUIButtonHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIButtonDown"), value2, gUIButtonHandler2);
    } while (gUIButtonHandler !== gUIButtonHandler2);
  }; 

  function GUIButton_add_OnGUIButtonEnter (value) {
    var gUIButtonHandler = this.OnGUIButtonEnter;

    do {
      var gUIButtonHandler2 = gUIButtonHandler;
      var value2 = $T05().Combine(gUIButtonHandler2, value);
      gUIButtonHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIButtonEnter"), value2, gUIButtonHandler2);
    } while (gUIButtonHandler !== gUIButtonHandler2);
  }; 

  function GUIButton_add_OnGUIButtonLeave (value) {
    var gUIButtonHandler = this.OnGUIButtonLeave;

    do {
      var gUIButtonHandler2 = gUIButtonHandler;
      var value2 = $T05().Combine(gUIButtonHandler2, value);
      gUIButtonHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIButtonLeave"), value2, gUIButtonHandler2);
    } while (gUIButtonHandler !== gUIButtonHandler2);
  }; 

  function GUIButton_add_OnGUIButtonUp (value) {
    var gUIButtonHandler = this.OnGUIButtonUp;

    do {
      var gUIButtonHandler2 = gUIButtonHandler;
      var value2 = $T05().Combine(gUIButtonHandler2, value);
      gUIButtonHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIButtonUp"), value2, gUIButtonHandler2);
    } while (gUIButtonHandler !== gUIButtonHandler2);
  }; 

  function GUIButton_CreateMesh () {
    this.SetRectangleMesh(
      +(this.get_BorderWidth()), 
      this.get_ButtonColor(), 
      this.get_BorderColor()
    );
    var x = (((this.get_PosX() | 0) + (this.get_OffsetX() | 0)) | 0);
    var y = (((this.get_PosY() | 0) + (this.get_OffsetY() | 0)) | 0);
    var maxW = +$T08().GetTextWidth(this.get_Text(), this.FontMap);
    x = ((Math.round(+x + +(((+(this.Width) - maxW) / 2)))) | 0);
    var maxH = +$T08().GetTextHeight(this.get_Text(), this.FontMap);
    y = ((Math.round((+y + maxH) + +(((+(this.Height) - maxH) / 2)))) | 0);
    this.SetTextMesh(x, y);
  }; 

  function GUIButton_DetachFromContext () {
    $T01().prototype.DetachFromContext.call(this);
    var flag = $T0C().get_Mouse() !== null;
    if (flag) {
      $T0C().get_Mouse().remove_ButtonValueChanged($T0E().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseButton", $S00(), false, false)));
      $T0C().get_Mouse().remove_AxisValueChanged($T0F().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseMove", $S01(), false, false)));
    }
    var flag2 = $T0C().get_Touch() !== null;
    if (flag2) {
      $T0C().get_Touch().remove_ButtonValueChanged($T0E().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseButton", $S00(), false, false)));
      $T0C().get_Touch().remove_AxisValueChanged($T0F().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseMove", $S01(), false, false)));
    }
  }; 

  function GUIButton_get_BorderColor () {
    return this._borderColor;
  }; 

  function GUIButton_get_BorderWidth () {
    return this._borderWidth;
  }; 

  function GUIButton_get_ButtonColor () {
    return this._buttonColor;
  }; 

  function GUIButton_MouseOnButton () {
    var x = ($T0C().get_Mouse().get_PositionInt().x | 0);
    var y = ($T0C().get_Mouse().get_PositionInt().y | 0);
    return (!((x < (((this.get_PosX() | 0) + (this.get_OffsetX() | 0)) | 0)) || 
        (x > (((((this.get_PosX() | 0) + (this.get_OffsetX() | 0)) | 0) + (this.Width | 0)) | 0)) || 
        (y < (((this.get_PosY() | 0) + (this.get_OffsetY() | 0)) | 0))) && (y <= (((((this.get_PosY() | 0) + (this.get_OffsetY() | 0)) | 0) + (this.Height | 0)) | 0)));
  }; 

  function GUIButton_OnMouseButton (sender, bvca) {
    var flag = this.MouseOnButton();
    if (flag) {
      var pressed = bvca.Pressed;
      if (pressed) {
        var expr_1E = this.OnGUIButtonDown;
        if (expr_1E !== null) {
          var expr_2A = new ($T13())();
          expr_2A.mouseX = ($T0C().get_Mouse().get_PositionInt().x | 0);
          expr_2A.mouseY = ($T0C().get_Mouse().get_PositionInt().y | 0);
          expr_1E(this, expr_2A);
        }
      } else {
        var expr_62 = this.OnGUIButtonUp;
        if (expr_62 !== null) {
          var expr_6E = new ($T13())();
          expr_6E.mouseX = ($T0C().get_Mouse().get_PositionInt().x | 0);
          expr_6E.mouseY = ($T0C().get_Mouse().get_PositionInt().y | 0);
          expr_62(this, expr_6E);
        }
      }
    }
  }; 

  function GUIButton_OnMouseMove (sender, bvca) {
    var flag = this.MouseOnButton();
    if (flag) {
      var mouseOnButton = this._mouseOnButton;
      if (!mouseOnButton) {
        this._mouseOnButton = true;
        if (this.OnGUIButtonEnter !== null) {
          var arg_6A_0 = this.OnGUIButtonEnter;
          var expr_40 = new ($T13())();
          expr_40.mouseX = ($T0C().get_Mouse().get_PositionInt().x | 0);
          expr_40.mouseY = ($T0C().get_Mouse().get_PositionInt().y | 0);
          arg_6A_0(this, expr_40);
        }
      }
    } else {
      if (this._mouseOnButton) {
        this._mouseOnButton = false;
        if (this.OnGUIButtonLeave !== null) {
          var arg_D1_0 = this.OnGUIButtonLeave;
          var expr_A7 = new ($T13())();
          expr_A7.mouseX = ($T0C().get_Mouse().get_PositionInt().x | 0);
          expr_A7.mouseY = ($T0C().get_Mouse().get_PositionInt().y | 0);
          arg_D1_0(this, expr_A7);
        }
      }
    }
  }; 

  function GUIButton_remove_OnGUIButtonDown (value) {
    var gUIButtonHandler = this.OnGUIButtonDown;

    do {
      var gUIButtonHandler2 = gUIButtonHandler;
      var value2 = $T05().Remove(gUIButtonHandler2, value);
      gUIButtonHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIButtonDown"), value2, gUIButtonHandler2);
    } while (gUIButtonHandler !== gUIButtonHandler2);
  }; 

  function GUIButton_remove_OnGUIButtonEnter (value) {
    var gUIButtonHandler = this.OnGUIButtonEnter;

    do {
      var gUIButtonHandler2 = gUIButtonHandler;
      var value2 = $T05().Remove(gUIButtonHandler2, value);
      gUIButtonHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIButtonEnter"), value2, gUIButtonHandler2);
    } while (gUIButtonHandler !== gUIButtonHandler2);
  }; 

  function GUIButton_remove_OnGUIButtonLeave (value) {
    var gUIButtonHandler = this.OnGUIButtonLeave;

    do {
      var gUIButtonHandler2 = gUIButtonHandler;
      var value2 = $T05().Remove(gUIButtonHandler2, value);
      gUIButtonHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIButtonLeave"), value2, gUIButtonHandler2);
    } while (gUIButtonHandler !== gUIButtonHandler2);
  }; 

  function GUIButton_remove_OnGUIButtonUp (value) {
    var gUIButtonHandler = this.OnGUIButtonUp;

    do {
      var gUIButtonHandler2 = gUIButtonHandler;
      var value2 = $T05().Remove(gUIButtonHandler2, value);
      gUIButtonHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIButtonUp"), value2, gUIButtonHandler2);
    } while (gUIButtonHandler !== gUIButtonHandler2);
  }; 

  function GUIButton_set_BorderColor (value) {
    this._borderColor = value.MemberwiseClone();
    this.Dirty = true;
  }; 

  function GUIButton_set_BorderWidth (value) {
    this._borderWidth = (value | 0);
    this.Dirty = true;
  }; 

  function GUIButton_set_ButtonColor (value) {
    this._buttonColor = value.MemberwiseClone();
    this.Dirty = true;
  }; 

  function GUIButton_SetupButton () {
    (this.ButtonColor = $S02().Construct(1, 1, 1, 1));
    (this.GUIElement$TextColor = $S02().Construct(0, 0, 0, 1));
    this.set_BorderWidth(1);
    (this.BorderColor = $S02().Construct(0, 0, 0, 1));
    var flag = $T0C().get_Mouse() !== null;
    if (flag) {
      $T0C().get_Mouse().add_ButtonValueChanged($T0E().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseButton", $S00(), false, false)));
      $T0C().get_Mouse().add_AxisValueChanged($T0F().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseMove", $S01(), false, false)));
    }
    var flag2 = $T0C().get_Touch() !== null;
    if (flag2) {
      $T0C().get_Touch().add_ButtonValueChanged($T0E().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseButton", $S00(), false, false)));
      $T0C().get_Touch().add_AxisValueChanged($T0F().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseMove", $S01(), false, false)));
    }
    this._mouseOnButton = false;
    this.CreateGUIShader();
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement"), 
      Name: "Fusee.Engine.Core.GUI.GUIButton", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 7, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32, $.Int32
        ]), 
      GUIButton__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32, $.Int32, 
          $.Int32
        ]), 
      GUIButton__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap"), 
          $.Int32, $.Int32, 
          $.Int32, $.Int32
        ]), 
      GUIButton__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap"), 
          $.Int32, $.Int32, 
          $.Int32, $.Int32, 
          $.Int32
        ]), 
      GUIButton__ctor$03
    );

    $.Method({Static:false, Public:true }, "add_OnGUIButtonDown", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler")), 
      GUIButton_add_OnGUIButtonDown
    );

    $.Method({Static:false, Public:true }, "add_OnGUIButtonEnter", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler")), 
      GUIButton_add_OnGUIButtonEnter
    );

    $.Method({Static:false, Public:true }, "add_OnGUIButtonLeave", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler")), 
      GUIButton_add_OnGUIButtonLeave
    );

    $.Method({Static:false, Public:true }, "add_OnGUIButtonUp", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler")), 
      GUIButton_add_OnGUIButtonUp
    );

    $.Method({Static:false, Public:false, Virtual:true }, "CreateMesh", 
      JSIL.MethodSignature.Void, 
      GUIButton_CreateMesh
    );

    $.Method({Static:false, Public:false, Virtual:true }, "DetachFromContext", 
      JSIL.MethodSignature.Void, 
      GUIButton_DetachFromContext
    );

    $.Method({Static:false, Public:true }, "get_BorderColor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIButton_get_BorderColor
    );

    $.Method({Static:false, Public:true }, "get_BorderWidth", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIButton_get_BorderWidth
    );

    $.Method({Static:false, Public:true }, "get_ButtonColor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIButton_get_ButtonColor
    );

    $.Method({Static:false, Public:false}, "MouseOnButton", 
      JSIL.MethodSignature.Return($.Boolean), 
      GUIButton_MouseOnButton
    );

    $.Method({Static:false, Public:false}, "OnMouseButton", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.ButtonValueChangedArgs")]), 
      GUIButton_OnMouseButton
    );

    $.Method({Static:false, Public:false}, "OnMouseMove", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.AxisValueChangedArgs")]), 
      GUIButton_OnMouseMove
    );

    $.Method({Static:false, Public:true }, "remove_OnGUIButtonDown", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler")), 
      GUIButton_remove_OnGUIButtonDown
    );

    $.Method({Static:false, Public:true }, "remove_OnGUIButtonEnter", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler")), 
      GUIButton_remove_OnGUIButtonEnter
    );

    $.Method({Static:false, Public:true }, "remove_OnGUIButtonLeave", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler")), 
      GUIButton_remove_OnGUIButtonLeave
    );

    $.Method({Static:false, Public:true }, "remove_OnGUIButtonUp", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler")), 
      GUIButton_remove_OnGUIButtonUp
    );

    $.Method({Static:false, Public:true }, "set_BorderColor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIButton_set_BorderColor
    );

    $.Method({Static:false, Public:true }, "set_BorderWidth", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIButton_set_BorderWidth
    );

    $.Method({Static:false, Public:true }, "set_ButtonColor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIButton_set_ButtonColor
    );

    $.Method({Static:false, Public:false}, "SetupButton", 
      JSIL.MethodSignature.Void, 
      GUIButton_SetupButton
    );

    $.Field({Static:false, Public:false}, "_buttonColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Field({Static:false, Public:false}, "_borderWidth", $.Int32);

    $.Field({Static:false, Public:false}, "_borderColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Field({Static:false, Public:false}, "_mouseOnButton", $.Boolean);

    $.Field({Static:false, Public:false}, "OnGUIButtonDown", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler"));

    $.Field({Static:false, Public:false}, "OnGUIButtonUp", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler"));

    $.Field({Static:false, Public:false}, "OnGUIButtonEnter", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler"));

    $.Field({Static:false, Public:false}, "OnGUIButtonLeave", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler"));

    $.Property({Static:false, Public:true }, "ButtonColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Property({Static:false, Public:true }, "BorderWidth", $.Int32);

    $.Property({Static:false, Public:true }, "BorderColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Event({Static:false, Public:true }, "OnGUIButtonDown", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler"));

    $.Event({Static:false, Public:true }, "OnGUIButtonUp", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler"));

    $.Event({Static:false, Public:true }, "OnGUIButtonEnter", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler"));

    $.Event({Static:false, Public:true }, "OnGUIButtonLeave", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIButtonHandler"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GUI.GUIHandler */ 

(function GUIHandler$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.Collections.Generic.List$b1.Of($asm04.Fusee.Engine.Core.GUI.GUIElement))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIElement)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Engine.Core.GUI.GUIElement))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm03.Fusee.Engine.Common.ClearFlags)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement")]))) ();
  };


  function GUIHandler__ctor$00 () {
    $T00().prototype._ctor.call(this);
  }; 

  function GUIHandler__ctor$01 (rc) {
    $T00().prototype._ctor.call(this);
    this._renderContext = rc;
  }; 

  function GUIHandler_Add$02 (item) {
    $S00().Call($T00().prototype, "Add", null, this, item);
    item.AttachToContext(this._renderContext);
  }; 

  function GUIHandler_AttachToContext (rc) {
    this._renderContext = rc;
  }; 

  function GUIHandler_DetachFromContext () {
    var $temp00;

    for (var a$0 = this._items, i$0 = 0, l$0 = (this._size | 0); i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var element = a$0[i$0];
      element.DetachFromContext();
    }
    this._renderContext = null;
  }; 

  function GUIHandler_Refresh () {
    var $temp00;

    for (var a$0 = this._items, i$0 = 0, l$0 = (this._size | 0); i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var guiElement = a$0[i$0];
      guiElement.Refresh();
    }
  }; 

  function GUIHandler_RenderGUI () {
    var tmpArray = new JSIL.BoxedVariable(null);
    if (this._renderContext !== null) {
      tmpArray.set($T00().prototype.ToArray.call(this));
      this.SortArray(/* ref */ tmpArray);
      var curZ = (($T00().prototype.get_Item.call(this, 0)).get_ZIndex() | 0);
      var array = tmpArray.get();

      for (var i = 0; i < (array.length | 0); i = ((i + 1) | 0)) {
        var guiElement = array[i];
        var flag2 = (guiElement.get_ZIndex() | 0) !== curZ;
        if (flag2) {
          (this._renderContext).Clear($T06().Depth);
          curZ = (guiElement.get_ZIndex() | 0);
        }
        guiElement.Render(this._renderContext);
      }
    }
  }; 


  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Collections.Generic.List`1", [$asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement")]), 
      Name: "Fusee.Engine.Core.GUI.GUIHandler", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      GUIHandler__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      GUIHandler__ctor$01
    );

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement")), 
      GUIHandler_Add$02
    );

    $.Method({Static:false, Public:true }, "AttachToContext", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      GUIHandler_AttachToContext
    );

    $.Method({Static:false, Public:true }, "DetachFromContext", 
      JSIL.MethodSignature.Void, 
      GUIHandler_DetachFromContext
    );

    $.Method({Static:false, Public:true }, "Refresh", 
      JSIL.MethodSignature.Void, 
      GUIHandler_Refresh
    );

    $.Method({Static:false, Public:true }, "RenderGUI", 
      JSIL.MethodSignature.Void, 
      GUIHandler_RenderGUI
    );

    $.ExternalMethod({Static:false, Public:false}, "SortArray", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$jsilcore.TypeRef("System.Array", [$asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement")])]))
    );

    $.Field({Static:false, Public:false}, "_renderContext", $asm04.TypeRef("Fusee.Engine.Core.RenderContext"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GUI.GUIHandler+<>c */ 

(function $l$gc$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIElement)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Int32)) ();
  };


  function $l$gc__ctor () {
  }; 

  function $l$gc_$lSortArray$gb__7_0 (x, y) {
    return JSIL.CompareValues(x.get_ZIndex(), y.get_ZIndex());
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.GUI.GUIHandler+<>c", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__ctor
    );

    $.Method({Static:false, Public:false}, "$lSortArray$gb__7_0", 
      new JSIL.MethodSignature($.Int32, [$asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement"), $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement")]), 
      $l$gc_$lSortArray$gb__7_0
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "$l$g9", $.Type);

    $.Field({Static:true , Public:true }, "$l$g9__7_0", $asm0E.TypeRef("System.Comparison`1", [$asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement")]));


    function $l$gc__cctor () {
      $thisType.$l$g9 = new $thisType();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__cctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GUI.GUIText */ 

(function GUIText$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.FontMap)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIElement)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Char)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Math)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm01.Fusee.Base.Core.Font)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float4, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };


  function GUIText__ctor$00 (text, fontMap, x, y, zRot, xPivot, yPivot) {
    $T04().prototype._ctor.call(this, 
      text, 
      fontMap, 
      x, 
      y, 
      0, 
      0, 
      0, 
      zRot, 
      xPivot, 
      yPivot
    );
    (this.GUIElement$TextColor = $S00().Construct(0, 0, 0, 1));
  }; 

  function GUIText__ctor$01 (text, fontMap, x, y, z, zRot, xPivot, yPivot) {
    $T04().prototype._ctor.call(this, 
      text, 
      fontMap, 
      x, 
      y, 
      z, 
      0, 
      0, 
      zRot, 
      xPivot, 
      yPivot
    );
    (this.GUIElement$TextColor = $S00().Construct(0, 0, 0, 1));
  }; 

  function GUIText__ctor$02 (text, fontMap, x, y, z, color, zRot, xPivot, yPivot) {
    $T04().prototype._ctor.call(this, 
      text, 
      fontMap, 
      x, 
      y, 
      z, 
      0, 
      0, 
      zRot, 
      xPivot, 
      yPivot
    );
    (this.GUIElement$TextColor = color.MemberwiseClone());
  }; 

  function GUIText__ctor$03 (text, fontMap, x, y, color) {
    $T04().prototype._ctor.call(this, 
      text, 
      fontMap, 
      x, 
      y, 
      0, 
      0, 
      0, 
      0, 
      0, 
      0
    );
    (this.GUIElement$TextColor = color.MemberwiseClone());
  }; 

  function GUIText_CreateMesh () {
    this.SetTextMesh(
      (((this.get_PosX() | 0) + (this.get_OffsetX() | 0)) | 0), 
      (((this.get_PosY() | 0) + (this.get_OffsetY() | 0)) | 0)
    );
  }; 

  function GUIText_GetTextHeight (text, fontMap) {
    var maxH = 0;

    for (var i = 0; i < (text.length | 0); i = ((i + 1) | 0)) {
      var letter = (text[i]);
      maxH = +$T07().Max(maxH, fontMap.GetGlyphOnMap(letter.charCodeAt(0)).BitmapH);
    }
    return maxH;
  }; 

  function GUIText_GetTextWidth (text, fontMap) {
    var maxW = 0;

    for (var i = 0; i < (text.length | 0); i = ((i + 1) | 0)) {
      var letter = (text[i]);
      maxW += +(fontMap.get_Font()).GetGlyphInfo(letter.charCodeAt(0)).AdvanceX;
    }
    return maxW;
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement"), 
      Name: "Fusee.Engine.Core.GUI.GUIText", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 9, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap"), 
          $.Int32, $.Int32, 
          $.Single, $.Int32, 
          $.Int32
        ]), 
      GUIText__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap"), 
          $.Int32, $.Int32, 
          $.Int32, $.Single, 
          $.Int32, $.Int32
        ]), 
      GUIText__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap"), 
          $.Int32, $.Int32, 
          $.Int32, $asm09.TypeRef("Fusee.Math.Core.float4"), 
          $.Single, $.Int32, 
          $.Int32
        ]), 
      GUIText__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap"), 
          $.Int32, $.Int32, 
          $asm09.TypeRef("Fusee.Math.Core.float4")
        ]), 
      GUIText__ctor$03
    );

    $.Method({Static:false, Public:false, Virtual:true }, "CreateMesh", 
      JSIL.MethodSignature.Void, 
      GUIText_CreateMesh
    );

    $.Method({Static:true , Public:true }, "GetTextHeight", 
      new JSIL.MethodSignature($.Single, [$.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap")]), 
      GUIText_GetTextHeight
    );

    $.Method({Static:true , Public:true }, "GetTextWidth", 
      new JSIL.MethodSignature($.Single, [$.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap")]), 
      GUIText_GetTextWidth
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate Fusee.Engine.Core.GUI.GUIPanelHandler */ 

JSIL.MakeDelegate("Fusee.Engine.Core.GUI.GUIPanelHandler", true, [], 
  new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanel"), $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelEventArgs")]));

/* class Fusee.Engine.Core.GUI.GUIPanelEventArgs */ 

(function GUIPanelEventArgs$Members () {
  var $, $thisType;

  function GUIPanelEventArgs__ctor () {
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "Fusee.Engine.Core.GUI.GUIPanelEventArgs", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      GUIPanelEventArgs__ctor
    );

    $.Field({Static:false, Public:true }, "mouseX", $.Int32);

    $.Field({Static:false, Public:true }, "mouseY", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GUI.GUIPanel */ 

(function GUIPanel$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Engine.Core.FontMap)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIElement)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIPanelHandler)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Delegate)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0E.System.Threading.Interlocked)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0E.System.Single)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIText)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0E.System.Math)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0E.System.Double)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Engine.Core.MouseDevice)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm04.Fusee.Engine.Core.Input)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0E.System.Object)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm03.Fusee.Engine.Common.ButtonValueChangedArgs)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIPanelEventArgs)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm03.Fusee.Engine.Common.AxisValueChangedArgs)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm04.Fusee.Engine.Core.GUI.GUIElement))) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0E.System.Collections.ObjectModel.Collection$b1.Of($asm04.Fusee.Engine.Core.GUI.GUIElement))) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0E.System.Collections.IEnumerator)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0E.System.IDisposable)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm04.Fusee.Engine.Core.InputDevice)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.ButtonValueChangedArgs))) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0E.System.EventHandler$b1.Of($asm03.Fusee.Engine.Common.AxisValueChangedArgs))) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0E.System.Collections.ObjectModel.Collection$b1.Of($asm04.Fusee.Engine.Core.GUI.GUIElement), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float4, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.ButtonValueChangedArgs]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0E.System.Object, $asm03.Fusee.Engine.Common.AxisValueChangedArgs]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0E.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerator$b1.Of($asm04.Fusee.Engine.Core.GUI.GUIElement).get_Current)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0E.System.IDisposable.Dispose)) ();
  };


  function GUIPanel__ctor$00 (text, fontMap, x, y, z, width, height) {
    $T03().prototype._ctor.call(this, 
      text, 
      fontMap, 
      x, 
      y, 
      z, 
      width, 
      height, 
      0, 
      0, 
      0
    );
    this.SetupPanel();
  }; 

  function GUIPanel__ctor$01 (text, fontMap, x, y, width, height) {
    $T03().prototype._ctor.call(this, 
      text, 
      fontMap, 
      x, 
      y, 
      0, 
      width, 
      height, 
      0, 
      0, 
      0
    );
    this.SetupPanel();
  }; 

  function GUIPanel_add_OnGUIPanelDown (value) {
    var gUIPanelHandler = this.OnGUIPanelDown;

    do {
      var gUIPanelHandler2 = gUIPanelHandler;
      var value2 = $T05().Combine(gUIPanelHandler2, value);
      gUIPanelHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIPanelDown"), value2, gUIPanelHandler2);
    } while (gUIPanelHandler !== gUIPanelHandler2);
  }; 

  function GUIPanel_add_OnGUIPanelEnter (value) {
    var gUIPanelHandler = this.OnGUIPanelEnter;

    do {
      var gUIPanelHandler2 = gUIPanelHandler;
      var value2 = $T05().Combine(gUIPanelHandler2, value);
      gUIPanelHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIPanelEnter"), value2, gUIPanelHandler2);
    } while (gUIPanelHandler !== gUIPanelHandler2);
  }; 

  function GUIPanel_add_OnGUIPanelLeave (value) {
    var gUIPanelHandler = this.OnGUIPanelLeave;

    do {
      var gUIPanelHandler2 = gUIPanelHandler;
      var value2 = $T05().Combine(gUIPanelHandler2, value);
      gUIPanelHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIPanelLeave"), value2, gUIPanelHandler2);
    } while (gUIPanelHandler !== gUIPanelHandler2);
  }; 

  function GUIPanel_add_OnGUIPanelUp (value) {
    var gUIPanelHandler = this.OnGUIPanelUp;

    do {
      var gUIPanelHandler2 = gUIPanelHandler;
      var value2 = $T05().Combine(gUIPanelHandler2, value);
      gUIPanelHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIPanelUp"), value2, gUIPanelHandler2);
    } while (gUIPanelHandler !== gUIPanelHandler2);
  }; 

  function GUIPanel_CreateMesh () {
    this.SetRectangleMesh(
      +(this.get_BorderWidth()), 
      this.get_PanelColor(), 
      this.get_BorderColor()
    );
    var x = (((this.get_PosX() | 0) + (this.get_OffsetX() | 0)) | 0);
    var y = (((this.get_PosY() | 0) + (this.get_OffsetY() | 0)) | 0);
    var maxW = +$T08().GetTextWidth(this.get_Text(), this.FontMap);
    x = ((Math.round(+x + +(((+(this.Width) - maxW) / 2)))) | 0);
    this.SetTextMesh(x, ((y + 20) | 0));
  }; 

  function GUIPanel_get_BorderColor () {
    return this._borderColor;
  }; 

  function GUIPanel_get_BorderWidth () {
    return this._borderWidth;
  }; 

  function GUIPanel_get_PanelColor () {
    return this._panelColor;
  }; 

  function GUIPanel_MouseOnPanel () {
    var x = ($T0C().get_Mouse().get_PositionInt().x | 0);
    var y = ($T0C().get_Mouse().get_PositionInt().y | 0);
    return (!((x < (((this.get_PosX() | 0) + (this.get_OffsetX() | 0)) | 0)) || 
        (x > (((((this.get_PosX() | 0) + (this.get_OffsetX() | 0)) | 0) + (this.Width | 0)) | 0)) || 
        (y < (((this.get_PosY() | 0) + (this.get_OffsetY() | 0)) | 0))) && (y <= (((((this.get_PosY() | 0) + (this.get_OffsetY() | 0)) | 0) + (this.Height | 0)) | 0)));
  }; 

  function GUIPanel_OnMouseButton (sender, bvca) {
    var flag = this.MouseOnPanel();
    if (flag) {
      var pressed = bvca.Pressed;
      if (pressed) {
        var expr_1E = this.OnGUIPanelDown;
        if (expr_1E !== null) {
          var expr_2A = new ($T10())();
          expr_2A.mouseX = ($T0C().get_Mouse().get_PositionInt().x | 0);
          expr_2A.mouseY = ($T0C().get_Mouse().get_PositionInt().y | 0);
          expr_1E(this, expr_2A);
        }
      } else {
        var expr_62 = this.OnGUIPanelUp;
        if (expr_62 !== null) {
          var expr_6E = new ($T10())();
          expr_6E.mouseX = ($T0C().get_Mouse().get_PositionInt().x | 0);
          expr_6E.mouseY = ($T0C().get_Mouse().get_PositionInt().y | 0);
          expr_62(this, expr_6E);
        }
      }
    }
  }; 

  function GUIPanel_OnMouseMove (sender, avca) {
    var flag = this.MouseOnPanel();
    if (flag) {
      var mouseOnPanel = this._mouseOnPanel;
      if (!mouseOnPanel) {
        this._mouseOnPanel = true;
        if (this.OnGUIPanelEnter !== null) {
          var arg_6A_0 = this.OnGUIPanelEnter;
          var expr_40 = new ($T10())();
          expr_40.mouseX = ($T0C().get_Mouse().get_PositionInt().x | 0);
          expr_40.mouseY = ($T0C().get_Mouse().get_PositionInt().y | 0);
          arg_6A_0(this, expr_40);
        }
      }
    } else {
      if (this._mouseOnPanel) {
        this._mouseOnPanel = false;
        if (this.OnGUIPanelLeave !== null) {
          var arg_D1_0 = this.OnGUIPanelLeave;
          var expr_A7 = new ($T10())();
          expr_A7.mouseX = ($T0C().get_Mouse().get_PositionInt().x | 0);
          expr_A7.mouseY = ($T0C().get_Mouse().get_PositionInt().y | 0);
          arg_D1_0(this, expr_A7);
        }
      }
    }
  }; 

  function GUIPanel_PreRender (rc) {
    $T03().prototype.PreRender.call(this, rc);
    var enumerator = (this.ChildElements).GetEnumerator();
    try {

      while ($IM00().Call(enumerator, null)) {
        var childElement = $IM01().Call(enumerator, null);
        childElement.set_OffsetX(this.get_PosX());
        childElement.set_OffsetY(this.get_PosY());
        childElement.set_OffsetZ(this.PosZ);
        childElement.Render(rc);
      }
    } finally {
      if (enumerator !== null) {
        $IM02().Call(enumerator, null);
      }
    }
  }; 

  function GUIPanel_Refresh () {
    $T03().prototype.Refresh.call(this);
    var enumerator = (this.ChildElements).GetEnumerator();
    try {

      while ($IM00().Call(enumerator, null)) {
        var childElement = $IM01().Call(enumerator, null);
        childElement.Refresh();
      }
    } finally {
      if (enumerator !== null) {
        $IM02().Call(enumerator, null);
      }
    }
  }; 

  function GUIPanel_remove_OnGUIPanelDown (value) {
    var gUIPanelHandler = this.OnGUIPanelDown;

    do {
      var gUIPanelHandler2 = gUIPanelHandler;
      var value2 = $T05().Remove(gUIPanelHandler2, value);
      gUIPanelHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIPanelDown"), value2, gUIPanelHandler2);
    } while (gUIPanelHandler !== gUIPanelHandler2);
  }; 

  function GUIPanel_remove_OnGUIPanelEnter (value) {
    var gUIPanelHandler = this.OnGUIPanelEnter;

    do {
      var gUIPanelHandler2 = gUIPanelHandler;
      var value2 = $T05().Remove(gUIPanelHandler2, value);
      gUIPanelHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIPanelEnter"), value2, gUIPanelHandler2);
    } while (gUIPanelHandler !== gUIPanelHandler2);
  }; 

  function GUIPanel_remove_OnGUIPanelLeave (value) {
    var gUIPanelHandler = this.OnGUIPanelLeave;

    do {
      var gUIPanelHandler2 = gUIPanelHandler;
      var value2 = $T05().Remove(gUIPanelHandler2, value);
      gUIPanelHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIPanelLeave"), value2, gUIPanelHandler2);
    } while (gUIPanelHandler !== gUIPanelHandler2);
  }; 

  function GUIPanel_remove_OnGUIPanelUp (value) {
    var gUIPanelHandler = this.OnGUIPanelUp;

    do {
      var gUIPanelHandler2 = gUIPanelHandler;
      var value2 = $T05().Remove(gUIPanelHandler2, value);
      gUIPanelHandler = $T06().CompareExchange$b1($T04())(/* ref */ new JSIL.MemberReference(this, "OnGUIPanelUp"), value2, gUIPanelHandler2);
    } while (gUIPanelHandler !== gUIPanelHandler2);
  }; 

  function GUIPanel_set_BorderColor (value) {
    this._borderColor = value.MemberwiseClone();
    this.Dirty = true;
  }; 

  function GUIPanel_set_BorderWidth (value) {
    this._borderWidth = (value | 0);
    this.Dirty = true;
  }; 

  function GUIPanel_set_PanelColor (value) {
    this._panelColor = value.MemberwiseClone();
    this.Dirty = true;
  }; 

  function GUIPanel_SetupPanel () {
    this.ChildElements = $S00().Construct();
    (this.PanelColor = $S01().Construct(0.1, 0.1, 0.1, 0.5));
    (this.GUIElement$TextColor = $S01().Construct(0.9, 0.9, 0.9, 1));
    this.set_BorderWidth(1);
    (this.BorderColor = $S01().Construct(0.2, 0.2, 0.2, 0.5));
    $T0C().get_Mouse().add_ButtonValueChanged($T19().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseButton", $S02(), false, false)));
    $T0C().get_Mouse().add_AxisValueChanged($T1A().New(this, null, new JSIL.MethodPointerInfo($thisType, "OnMouseMove", $S03(), false, false)));
    this.CreateGUIShader();
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement"), 
      Name: "Fusee.Engine.Core.GUI.GUIPanel", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 7, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap"), 
          $.Int32, $.Int32, 
          $.Int32, $.Int32, 
          $.Int32
        ]), 
      GUIPanel__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm04.TypeRef("Fusee.Engine.Core.FontMap"), 
          $.Int32, $.Int32, 
          $.Int32, $.Int32
        ]), 
      GUIPanel__ctor$01
    );

    $.Method({Static:false, Public:true }, "add_OnGUIPanelDown", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler")), 
      GUIPanel_add_OnGUIPanelDown
    );

    $.Method({Static:false, Public:true }, "add_OnGUIPanelEnter", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler")), 
      GUIPanel_add_OnGUIPanelEnter
    );

    $.Method({Static:false, Public:true }, "add_OnGUIPanelLeave", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler")), 
      GUIPanel_add_OnGUIPanelLeave
    );

    $.Method({Static:false, Public:true }, "add_OnGUIPanelUp", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler")), 
      GUIPanel_add_OnGUIPanelUp
    );

    $.Method({Static:false, Public:false, Virtual:true }, "CreateMesh", 
      JSIL.MethodSignature.Void, 
      GUIPanel_CreateMesh
    );

    $.Method({Static:false, Public:true }, "get_BorderColor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIPanel_get_BorderColor
    );

    $.Method({Static:false, Public:true }, "get_BorderWidth", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIPanel_get_BorderWidth
    );

    $.Method({Static:false, Public:true }, "get_PanelColor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIPanel_get_PanelColor
    );

    $.Method({Static:false, Public:false}, "MouseOnPanel", 
      JSIL.MethodSignature.Return($.Boolean), 
      GUIPanel_MouseOnPanel
    );

    $.Method({Static:false, Public:false}, "OnMouseButton", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.ButtonValueChangedArgs")]), 
      GUIPanel_OnMouseButton
    );

    $.Method({Static:false, Public:false}, "OnMouseMove", 
      new JSIL.MethodSignature(null, [$.Object, $asm03.TypeRef("Fusee.Engine.Common.AxisValueChangedArgs")]), 
      GUIPanel_OnMouseMove
    );

    $.Method({Static:false, Public:false, Virtual:true }, "PreRender", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      GUIPanel_PreRender
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Refresh", 
      JSIL.MethodSignature.Void, 
      GUIPanel_Refresh
    );

    $.Method({Static:false, Public:true }, "remove_OnGUIPanelDown", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler")), 
      GUIPanel_remove_OnGUIPanelDown
    );

    $.Method({Static:false, Public:true }, "remove_OnGUIPanelEnter", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler")), 
      GUIPanel_remove_OnGUIPanelEnter
    );

    $.Method({Static:false, Public:true }, "remove_OnGUIPanelLeave", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler")), 
      GUIPanel_remove_OnGUIPanelLeave
    );

    $.Method({Static:false, Public:true }, "remove_OnGUIPanelUp", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler")), 
      GUIPanel_remove_OnGUIPanelUp
    );

    $.Method({Static:false, Public:true }, "set_BorderColor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIPanel_set_BorderColor
    );

    $.Method({Static:false, Public:true }, "set_BorderWidth", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIPanel_set_BorderWidth
    );

    $.Method({Static:false, Public:true }, "set_PanelColor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIPanel_set_PanelColor
    );

    $.Method({Static:false, Public:false}, "SetupPanel", 
      JSIL.MethodSignature.Void, 
      GUIPanel_SetupPanel
    );

    $.Field({Static:false, Public:false}, "_panelColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Field({Static:false, Public:false}, "_borderWidth", $.Int32);

    $.Field({Static:false, Public:false}, "_borderColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Field({Static:false, Public:false}, "_mouseOnPanel", $.Boolean);

    $.Field({Static:false, Public:true }, "ChildElements", $asm0E.TypeRef("System.Collections.ObjectModel.Collection`1", [$asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement")]));

    $.Field({Static:false, Public:false}, "OnGUIPanelDown", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler"));

    $.Field({Static:false, Public:false}, "OnGUIPanelUp", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler"));

    $.Field({Static:false, Public:false}, "OnGUIPanelEnter", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler"));

    $.Field({Static:false, Public:false}, "OnGUIPanelLeave", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler"));

    $.Property({Static:false, Public:true }, "PanelColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Property({Static:false, Public:true }, "BorderWidth", $.Int32);

    $.Property({Static:false, Public:true }, "BorderColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Event({Static:false, Public:true }, "OnGUIPanelDown", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler"));

    $.Event({Static:false, Public:true }, "OnGUIPanelUp", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler"));

    $.Event({Static:false, Public:true }, "OnGUIPanelEnter", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler"));

    $.Event({Static:false, Public:true }, "OnGUIPanelLeave", $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIPanelHandler"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.Core.GUI.GUIImage */ 

(function GUIImage$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm00.Fusee.Base.Common.ImageData)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Engine.Core.GUI.GUIElement)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderContext)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0E.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm09.Fusee.Math.Core.M)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Engine.Core.EffectPassDeclaration))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Engine.Core.EffectPassDeclaration)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Engine.Core.RenderStateSet)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm03.Fusee.Engine.Common.Blend)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize(System.Array.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration))) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm04.Fusee.Engine.Core.EffectParameterDeclaration)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm09.Fusee.Math.Core.float4x4)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm04.Fusee.Engine.Core.ShaderEffect)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0E.System.Collections.Generic.IEnumerable$b1.Of($asm04.Fusee.Engine.Core.EffectParameterDeclaration))) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm09.Fusee.Math.Core.float4)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize(System.Array.Of($asm09.Fusee.Math.Core.float2))) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm04.Fusee.Engine.Core.Mesh)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm09.Fusee.Math.Core.float2)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float4, [
        $asm0E.System.Single, $asm0E.System.Single, 
        $asm0E.System.Single, $asm0E.System.Single
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm09.Fusee.Math.Core.float2, [$asm0E.System.Single, $asm0E.System.Single]))) ();
  };


  function GUIImage__ctor$00 (image, x, y, z, width, height) {
    $T02().prototype._ctor.call(this, 
      $T03().Empty, 
      null, 
      x, 
      y, 
      z, 
      width, 
      height, 
      0, 
      0, 
      0
    );
    this.ImgSrc = image.MemberwiseClone();
    this.set_BorderWidth(0);
  }; 

  function GUIImage__ctor$01 (image, x, y, width, height) {
    $T02().prototype._ctor.call(this, 
      $T03().Empty, 
      null, 
      x, 
      y, 
      0, 
      width, 
      height, 
      0, 
      0, 
      0
    );
    this.ImgSrc = image.MemberwiseClone();
    this.set_BorderWidth(0);
  }; 

  function GUIImage_AttachToContext (rc) {
    var flag = this.RContext === rc;
    if (!flag) {
      var flag2 = !(this.ImgSrc).get_IsEmpty();
      if (flag2) {
        this.GUITexture = rc.CreateTexture(this.ImgSrc.MemberwiseClone(), $T06().IsPowerOfTwo(this.ImgSrc.Width) && 
          $T06().IsPowerOfTwo(this.ImgSrc.Height));
        this.CreateGUIShader();
      }
      $T02().prototype.AttachToContext.call(this, rc);
    }
  }; 

  function GUIImage_CreateGUIShader () {
    var expr_08 = JSIL.Array.New($T08(), 1);
    var effectPassDeclaration = new ($T08())();
    effectPassDeclaration.VS = this.GUIVS;
    effectPassDeclaration.PS = "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif    \r\n  \r\n            varying vec2 vUV;\r\n            varying vec4 vColor;\r\n\r\n            uniform sampler2D tex;\r\n\r\n            void main(void) {\r\n                if (vUV.x == -1.0)\r\n                    gl_FragColor = vColor;\r\n                else\r\n                    gl_FragColor = texture2D(tex, vUV);\r\n            }";
    var expr_32 = new ($T09())();
    expr_32.set_AlphaBlendEnable(true);
    expr_32.set_SourceBlend($T0A().SourceAlpha);
    expr_32.set_DestinationBlend($T0A().InverseSourceAlpha);
    expr_32.set_ZEnable(true);
    effectPassDeclaration.StateSet = expr_32;
    expr_08[0] = effectPassDeclaration.MemberwiseClone();
    var expr_63 = JSIL.Array.New($T0C(), 2);
    var effectParameterDeclaration = new ($T0C())();
    effectParameterDeclaration.Name = "tex";
    effectParameterDeclaration.Value = this.GUITexture;
    expr_63[0] = effectParameterDeclaration.MemberwiseClone();
    effectParameterDeclaration = new ($T0C())();
    effectParameterDeclaration.Name = "guiXForm";
    effectParameterDeclaration.Value = $T0D().Identity.MemberwiseClone();
    expr_63[1] = effectParameterDeclaration.MemberwiseClone();
    this.GUIShader = new ($T0E())(expr_08, $T0F().$Cast(expr_63));
  }; 

  function GUIImage_CreateMesh () {
    this.SetRectangleMesh(
      +(this.get_BorderWidth()), 
      $S00().Construct(1, 1, 1, 1), 
      this.get_BorderColor()
    );
    var uvs = (this.GUIElement$GUIMesh$value).get_UVs();
    uvs[0] = $S01().Construct(0, 0);
    uvs[1] = $S01().Construct(0, 1);
    uvs[2] = $S01().Construct(1, 0);
    uvs[3] = $S01().Construct(1, 1);
    var flag = (this.get_BorderWidth() | 0) > 0;
    if (flag) {

      for (var i = 4; i < 8; i = ((i + 1) | 0)) {
        uvs[i] = $S01().Construct(-1, -1);
      }
    }
    (this.GUIElement$GUIMesh$value).set_UVs(uvs);
  }; 

  function GUIImage_get_BorderColor () {
    return this._borderColor;
  }; 

  function GUIImage_get_BorderWidth () {
    return this._borderWidth;
  }; 

  function GUIImage_set_BorderColor (value) {
    this._borderColor = value.MemberwiseClone();
    this.Dirty = true;
  }; 

  function GUIImage_set_BorderWidth (value) {
    this._borderWidth = (value | 0);
    this.Dirty = true;
  }; 

  JSIL.MakeType({
      BaseType: $asm04.TypeRef("Fusee.Engine.Core.GUI.GUIElement"), 
      Name: "Fusee.Engine.Core.GUI.GUIImage", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 6, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm00.TypeRef("Fusee.Base.Common.ImageData"), $.Int32, 
          $.Int32, $.Int32, 
          $.Int32, $.Int32
        ]), 
      GUIImage__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm00.TypeRef("Fusee.Base.Common.ImageData"), $.Int32, 
          $.Int32, $.Int32, 
          $.Int32
        ]), 
      GUIImage__ctor$01
    );

    $.Method({Static:false, Public:false, Virtual:true }, "AttachToContext", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Engine.Core.RenderContext")), 
      GUIImage_AttachToContext
    );

    $.Method({Static:false, Public:false, Virtual:true }, "CreateGUIShader", 
      JSIL.MethodSignature.Void, 
      GUIImage_CreateGUIShader
    );

    $.Method({Static:false, Public:false, Virtual:true }, "CreateMesh", 
      JSIL.MethodSignature.Void, 
      GUIImage_CreateMesh
    );

    $.Method({Static:false, Public:true }, "get_BorderColor", 
      JSIL.MethodSignature.Return($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIImage_get_BorderColor
    );

    $.Method({Static:false, Public:true }, "get_BorderWidth", 
      JSIL.MethodSignature.Return($.Int32), 
      GUIImage_get_BorderWidth
    );

    $.Method({Static:false, Public:true }, "set_BorderColor", 
      JSIL.MethodSignature.Action($asm09.TypeRef("Fusee.Math.Core.float4")), 
      GUIImage_set_BorderColor
    );

    $.Method({Static:false, Public:true }, "set_BorderWidth", 
      JSIL.MethodSignature.Action($.Int32), 
      GUIImage_set_BorderWidth
    );

    $.Constant({Static:true , Public:false}, "IMGPS", $.String, "\r\n            #ifdef GL_ES\r\n                precision highp float;\r\n            #endif    \r\n  \r\n            varying vec2 vUV;\r\n            varying vec4 vColor;\r\n\r\n            uniform sampler2D tex;\r\n\r\n            void main(void) {\r\n                if (vUV.x == -1.0)\r\n                    gl_FragColor = vColor;\r\n                else\r\n                    gl_FragColor = texture2D(tex, vUV);\r\n            }");

    $.Field({Static:false, Public:false}, "_borderColor", $asm09.TypeRef("Fusee.Math.Core.float4"));

    $.Field({Static:false, Public:false}, "_borderWidth", $.Int32);

    $.Property({Static:false, Public:true }, "BorderWidth", $.Int32);

    $.Property({Static:false, Public:true }, "BorderColor", $asm09.TypeRef("Fusee.Math.Core.float4"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class <PrivateImplementationDetails> */ 

(function $lPrivateImplementationDetails$g$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0E.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0E.System.UInt32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0E.System.Int32)) ();
  };


  function $lPrivateImplementationDetails$g_ComputeStringHash (s) {
    if (s !== null) {
      var num = 2166136261;

      for (var i = 0; i < (s.length | 0); i = ((i + 1) | 0)) {
        num = (Math.imul((((s[i]).charCodeAt(0) | 0) ^ num), 16777619) >>> 0);
      }
    }
    return num;
  }; 

  JSIL.MakeType({
      BaseType: $asm0E.TypeRef("System.Object"), 
      Name: "<PrivateImplementationDetails>", 
      IsPublic: false, 
      IsReferenceType: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:true , Public:false}, "ComputeStringHash", 
      new JSIL.MethodSignature($.UInt32, [$.String]), 
      $lPrivateImplementationDetails$g_ComputeStringHash
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

